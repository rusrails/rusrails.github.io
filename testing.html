<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8">
<meta content="Ruby on Rails, Ruby, Rails, Rails 3, Rails 4, Rails 5, Rails 6, Rails 6.0, Rails 6.1, Rails 7.0, Rails 7.1 руководство, начинающим, самоучитель, manual, мануал, справочник, учебник, примеры, Руби, рельсы" name="keywords"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" name="description"/>
<meta content="product" property="twitter:card"/>
<meta content="@rusrails" property="twitter:site"/>
<meta content="Rusrails: Тестирование приложений на Rails" property="twitter:title"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" property="twitter:description"/>
<meta content="@rusrails" property="twitter:creator"/>
<meta content="http://rusrails.ru/assets/rusrails.png" property="twitter:image"/>
<meta content="website" property="og:type"/>
<meta content="Rusrails: Тестирование приложений на Rails" property="og:title"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" property="og:description"/>
<meta content="http://localhost:3000/testing" property="og:url"/>
<meta content="http://rusrails.ru/assets/rusrails.png" property="og:image"/>
    <title>
      Rusrails: Тестирование приложений на Rails
    </title>
    <link rel="stylesheet" href="/assets/application-f9dfa6ce7fa871006d478e422639671663284ddaa3126cf81ddfe371ac3533c4.css" />
  </head>
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="brand" href="/"></a>
          <ul class="nav pull-right top-menu">
            <li>
              <a href="/">Главная</a>
            </li>
            <li class="dropdown">
              <a class="index-popover" href="#">
                Содержание
                <b class="caret"></b>
</a>              <div class="index-popover-content hide">
                  <ul><li><p><strong>С чего начать?</strong></p><ul><li><a href="/getting-started">Rails для начинающих</a>
</li></ul></li><li><p><strong>Модели</strong></p><ul><li><a href="/active-record-basics">Основы Active Record</a>
</li><li><a href="/active-record-migrations">Миграции Active Record</a>
</li><li><a href="/active-record-validations">Валидации Active Record</a>
</li><li><a href="/active-record-callbacks">Колбэки Active Record</a>
</li><li><a href="/active-record-associations">Связи (ассоциации) Active Record</a>
</li><li><a href="/active-record-querying">Интерфейс запросов Active Record</a>
</li><li><a href="/active-model-basics">Основы Active Model</a>
</li></ul></li><li><p><strong>Вью</strong></p><ul><li><a href="/action-view-overview">Обзор Action View</a>
</li><li><a href="/layouts-and-rendering">Макеты и рендеринг в Rails</a>
</li><li><a href="/action-view-helpers">Хелперы Action View</a>
</li><li><a href="/form-helpers">Хелперы форм в Action View</a>
</li></ul></li><li><p><strong>Контроллеры</strong></p><ul><li><a href="/action-controller-overview">Обзор Action Controller</a>
</li><li><a href="/routing">Роутинг в Rails</a>
</li></ul></li><li><p><strong>Другие компоненты</strong></p><ul><li><a href="/active-support-core-extensions">Расширения ядра Active Support</a>
</li><li><a href="/action-mailer-basics">Основы Action Mailer</a>
</li><li><a href="/action-mailbox-basics">Основы Action Mailbox</a>
</li><li><a href="/action-text-overview">Обзор Action Text</a>
</li><li><a href="/active_job_basics">Основы Active Job</a>
</li><li><a href="/active_storage_overview">Обзор Active Storage</a>
</li><li><a href="/action-cable-overview">Обзор Action Cable</a>
</li></ul></li><li><p><strong>Копаем глубже</strong></p><ul><li><a href="/i18n">API интернационализации Rails (I18n)</a>
</li><li><a href="/testing">Тестирование приложений на Rails</a>
</li><li><a href="/security">Безопасность приложений на Rails</a>
</li><li><a href="/error-reporting">Отчет об ошибках в приложениях Rails</a>
</li></ul></li></ul><p>next_column</p><ul><li><p><strong>Копаем глубже</strong></p><ul><li><a href="/debugging-rails-applications">Отладка приложений на Rails</a>
</li><li><a href="/configuring">Конфигурирование приложений на Rails</a>
</li><li><a href="/command-line">Командная строка Rails</a>
</li><li><a href="/asset-pipeline">Asset Pipeline</a>
</li><li><a href="/working-with-javascript-in-rails">Работа с JavaScript в Rails</a>
</li><li><a href="/initialization">Процесс инициализации в Rails</a>
</li><li><a href="/autoloading-and-reloading-constants">Автозагрузка и перезагрузка констант</a>
</li><li><a href="/classic-to-zeitwerk-howto">Как перейти с Classic на Zeitwerk</a>
</li><li><a href="/caching-with-rails">Кэширование с Rails: Обзор</a>
</li><li><a href="/active-support-instrumentation">Инструментарий Active Support</a>
</li><li><a href="/api-app">Использование Rails для API-приложений</a>
</li><li><a href="/active-record-postgresql">Active Record для PostgreSQL</a>
</li><li><a href="/active-record-multiple-databases">Несколько баз данных с Active Record</a>
</li><li><a href="/active-record-encryption">Шифрование Active Record</a>
</li></ul></li><li><p><strong>Расширяем Rails</strong></p><ul><li><a href="/plugins">Основы создания плагинов Rails</a>
</li><li><a href="/rails-on-rack">Rails on Rack</a>
</li><li><a href="/generators">Создание и настройка генераторов и шаблонов Rails</a>
</li><li><a href="/engines">Engine для начинающих</a>
</li><li><a href="/threading_and_code_execution">Треды и выполнение кода в Rails</a>
</li><li><a href="/rails-application-templates">Шаблоны приложения Rails</a>
</li></ul></li><li><p><strong>Вносим вклад в Ruby on Rails</strong></p><ul><li><a href="/contributing_to_ruby_on_rails">Вносим вклад в Ruby on Rails</a>
</li><li><a href="/api_documentation_guidelines">Рекомендации по документированию API</a>
</li><li><a href="/ruby_on_rails_guides_guidelines">Рекомендации для руководств по Ruby on Rails</a>
</li><li><a href="/development_dependencies_install">Установка зависимостей для разработки</a>
</li><li><a href="/maintenance-policy">Политика поддержки (версий)</a>
</li></ul></li><li><p><strong>Заметки о релизах</strong></p><ul><li><a href="/upgrading-ruby-on-rails">Апгрейд Ruby on Rails</a>
</li><li><a href="/7_1_release_notes">Версия 7.1 - Октябрь 2023</a>
</li><li><a href="/7_0_release_notes">Версия 7.0 - Декабрь 2021</a>
</li><li><a href="/6_1_release_notes">Версия 6.1 - Декабрь 2020</a>
</li><li><a href="/6_0_release_notes">Версия 6.0 - Август 2019</a>
</li></ul></li></ul>
              </div>
            </li>
            <li>
              <a href="/search">Поиск</a>
            </li>
            <li>
              <a target="blank" href="http://api.rusrails.ru">Ruby &amp; Rails API</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content-wrapper">
      <div class="container-fluid">
        <div class="row-fluid">
          <div class="span3 pull-right">
            <div class="well social">
              <h4>Принимаем пожелания и пул-реквесты!</h4>
              <iframe allowtransparency="true" frameborder="0" height="30" src="http://ghbtns.com/github-btn.html?user=rusrails&repo=rusrails&type=watch&count=true&size=large" width="180"></iframe>
              <p></p>
              <a class="twitter-follow-button" data-lang="ru" href="https://twitter.com/rusrails"></a>
            </div>
              <div class="well menu">
                    <ul class="nav nav-list">
      <li>
        <h4>
          <a href="#zachem-pisat-testy-dlya-prilozheniya-na-rails">1. Зачем писать тесты для приложения на Rails?</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#vvedenie-v-testirovanie">2. Введение в тестирование</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#nastroyka-rails-dlya-testirovaniya-s-nulya">2.1. Настройка Rails для тестирования с нуля</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#testovaya-sreda-razrabotki">2.2. Тестовая среда разработки</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#rails-vstretilsya-s-minitest">2.3. Rails встретился с Minitest</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#vash-pervyy-padayuschiy-test">2.3.1. Ваш первый падающий тест</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#kak-vyglyadit-oshibka">2.3.2. Как выглядит ошибка</a>
</h6>      </li>
      <li>
        <h5>
          <a href="#dostupnye-utverzhdeniya">2.4. Доступные утверждения</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#spetsifichnye-utverzhdeniya-rails">2.5. Специфичные утверждения Rails</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#kratkaya-zametka-o-testovyh-sluchayah">2.6. Краткая заметка о тестовых случаях</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#zapusk-testov-rails">2.7. Запуск тестов Rails</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#running-tests-in-continuous-integration-ci">2.8. Запуск тестов в Непрерывной Интеграции (CI)</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#parallel-testing">3. Параллельное тестирование</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#parallelnoe-testirovanie-s-pomoschyu-protsessov">3.1. Параллельное тестирование с помощью процессов</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#parallelnoe-testirovanie-s-pomoschyu-tredov">3.2. Параллельное тестирование с помощью тредов</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#testirovanie-parallelnyh-tranzaktsiy">3.3. Тестирование параллельных транзакций</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#porog-rasparallelivaniya-testov">3.4. Порог распараллеливания тестов</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#testovaya-baza-dannyh">4. Тестовая база данных</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#podderzhka-shemy-testovoy-bazy-dannyh">4.1. Поддержка схемы тестовой базы данных</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#the-low-down-on-fixtures">4.2. Полная информация по фикстурам</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#chto-takoe-fikstury">4.2.1. Что такое фикстуры?</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#yaml">4.2.2. YAML</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#fikstury-dlya-faylovyh-vlozheniy">4.2.3. Фикстуры для файловых вложений</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#erb">4.2.4. ERb</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#fikstury-v-deystvii">4.2.5. Фикстуры в действии</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#fikstury-eto-ob-ekty-active-record">4.2.6. Фикстуры это объекты Active Record</a>
</h6>      </li>
      <li>
        <h4>
          <a href="#testirovanie-modeley">5. Тестирование моделей</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#system-testing">6. Системное тестирование</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#izmenenie-nastroek-po-umolchaniyu">6.1. Изменение настроек по умолчанию</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#helper-dlya-skrinshotov">6.2. Хелпер для скриншотов</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#realizatsiya-sistemnogo-testa">6.3. Реализация системного теста</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#sistemnyy-test-dlya-sozdaniya-statey">6.3.1. Системный тест для создания статей</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#testirovanie-dlya-neskolkih-razmerov-ekrana">6.3.2. Тестирование для нескольких размеров экрана</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#chto-dalshe">6.3.3. Что дальше?</a>
</h6>      </li>
      <li>
        <h4>
          <a href="#integratsionnoe-testirovanie">7. Интеграционное тестирование</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#helpery-dostupnye-dlya-integratsionnyh-testov">7.1. Хелперы, доступные для интеграционных тестов</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#realizatsiya-integratsionnogo-testa">7.2. Реализация интеграционного теста</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#sozdanie-integratsii-statey">7.2.1. Создание интеграции статей</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#idem-dalshe">7.2.2. Идем дальше</a>
</h6>      </li>
      <li>
        <h4>
          <a href="#funktsionalnye-testy-dlya-vashih-kontrollerov">8. Функциональные тесты для ваших контроллеров</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#chto-vklyuchat-v-funktsionalnye-testy">8.1. Что включать в функциональные тесты</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#dostupnye-tipy-zaprosov-dlya-funktsionalnyh-testov">8.2. Доступные типы запросов для функциональных тестов</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#testirovanie-zaprosov-xhr-ajax">8.3. Тестирование запросов XHR (Ajax)</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#tri-hesha-apokalipsisa-the-three-hashes-of-the-apocalypse">8.4. Три Хэша Апокалипсиса (The Three Hashes of the Apocalypse)</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#dostupnye-peremennye-ekzemplyara">8.5. Доступные переменные экземпляра</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#ustanovka-zagolovkov-i-peremennyh-cgi">8.6. Установка заголовков и переменных CGI</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#testirovanie-soobscheniy-flash">8.7. Тестирование сообщений <code>flash</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#obobschenie-izlozhennogo">8.8. Обобщение изложенного</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#testovye-helpery">8.9. Тестовые хелперы</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#ispolzovanie-otdelnyh-faylov">8.9.1. Использование отдельных файлов</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#neterpelivaya-zagruzka-helperov">8.9.2. Нетерпеливая загрузка хелперов</a>
</h6>      </li>
      <li>
        <h4>
          <a href="#testirovanie-marshrutov">9. Тестирование маршрутов</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#testing-views">10. Тестирование вью</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#additional-view-based-assertions">10.1. Дополнительные утверждения, основанные на вью</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#testirovanie-partialov-vyu">11. Тестирование партиалов вью</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#testirovanie-helperov">12. Тестирование хелперов</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#testing-your-mailers">13. Тестирование почтовых рассыльщиков</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#derzhim-otpravku-pochty-pod-kontrolem">13.1. Держим отправку почты под контролем</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#so-vseh-storon">13.1.1. Со всех сторон</a>
</h6>      </li>
      <li>
        <h5>
          <a href="#yunit-testirovanie">13.2. Юнит-тестирование</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#revansh-fikstur">13.2.1. Реванш фикстур</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#bazovyy-testovyy-sluchay">13.2.2. Базовый тестовый случай</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#testing-enqueued-emails">13.2.3. Тестирование электронных писем в очереди</a>
</h6>      </li>
      <li>
        <h5>
          <a href="#functional-and-system-testing">13.3. Функциональное и системное тестирование</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#jobs-testing">14. Тестирование заданий</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#testirovanie-zadaniy-v-izolyatsii">14.1. Тестирование заданий в изоляции</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#testirovanie-zadaniy-v-kontekste">14.2. Тестирование заданий в контексте</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#testirovanie-vozniknoveniya-isklyucheniy">14.3. Тестирование возникновения исключений</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#testing-action-cable">15. Тестирование Action Cable</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#testovyy-sluchay-dlya-soedineniya">15.1. Тестовый случай для соединения</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#testovyy-sluchay-dlya-kanala">15.2. Тестовый случай для канала</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#polzovatelskie-utverzhdeniya-i-testirovanie-translyatsiy-vnutri-drugih-komponent">15.3. Пользовательские утверждения и тестирование трансляций внутри других компонент</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#testing-eager-loading">16. Тестирование нетерпеливой загрузки</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#nepreryvnaya-integratsiya">16.1. Непрерывная интеграция</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#chistye-testovye-sluchai">16.2. Чистые тестовые случаи</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#minitest">16.2.1. Minitest</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#rspec">16.2.2. RSpec</a>
</h6>      </li>
      <li>
        <h4>
          <a href="#dopolnitelnye-resursy-po-testirovaniyu">17. Дополнительные ресурсы по тестированию</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#testirovanie-koda-zavisimogo-ot-vremeni">17.1. Тестирование кода, зависимого от времени</a>
</h5>      </li>
</ul>

              </div>
            <div class="well banner300 banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<!-- sidebar rusrails -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-7764391801669990"
     data-ad-slot="6089520660"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
          </div>
          <div class="span9 content pull-left">
            <div class="banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <!-- top rusrails -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:980px;height:120px"
       data-ad-client="ca-pub-7764391801669990"
       data-ad-slot="4891989065"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
              <h2 id='testirovanie-prilozheniy-na-rails' class='inside_page_header'> Тестирование приложений на Rails</h2><p>Это руководство раскрывает встроенные в Rails механизмы для тестирования вашего приложения.</p><p>После его прочтения, вы узнаете:</p><ul><li>О терминологии тестирования Rails.
</li><li>Как писать юнит-, функциональные, интеграционные и системные тесты для вашего приложения.
</li><li>О других популярных подходах к тестированию и плагинах.
</li></ul><h3 id='zachem-pisat-testy-dlya-prilozheniya-na-rails' class='inside_page_header'><a href="#zachem-pisat-testy-dlya-prilozheniya-na-rails">1.</a> Зачем писать тесты для приложения на Rails?</h3><p>Rails предлагает писать тесты очень просто. Когда вы создаете свои модели и контроллеры, он начинает создавать скелет тестового кода.</p><p>Запуск тестов Rails позволяет убедиться, что ваш код придерживается нужной функциональности даже после большой переделки кода.</p><p>Тесты Rails также могут симулировать запросы браузера, таким образом, можно тестировать отклик своего приложения без необходимости тестирования с использованием браузера.</p><h3 id='vvedenie-v-testirovanie' class='inside_page_header'><a href="#vvedenie-v-testirovanie">2.</a> Введение в тестирование</h3><p>Поддержка тестирования встроена в Rails с самого начала. И это не было так: &quot;О! Давайте внесем поддержку запуска тестов, это ново и круто!&quot;</p><h4 id='nastroyka-rails-dlya-testirovaniya-s-nulya' class='inside_page_header'><a href="#nastroyka-rails-dlya-testirovaniya-s-nulya">2.1.</a> Настройка Rails для тестирования с нуля</h4><p>Rails создает директорию <code>test</code> как только вы создаете проект Rails, используя <code>rails new _application_name_</code>. Если посмотрите список содержимого этой папки, то увидите:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">ls</span> <span class="nt">-F</span> <span class="nb">test</span>
<span class="go">
application_system_test_case.rb  controllers/                     helpers/                         mailers/                         system/
channels/                        fixtures/                        integration/                     models/                          test_helper.rb
</span></code></pre>
</div>
<p>Директории <code>helpers</code>, <code>mailers</code> и <code>models</code> предназначены содержать тесты для хелперов вью, рассыльщиков и моделей соответственно. Директория <code>channels</code> предназначена содержать тесты для соединений и каналов Action Cable. Директория <code>controllers</code> предназначена содержать тесты для ваших контроллеров, маршрутов и вью. Директория <code>integration</code> предназначена содержать тесты для взаимодействия между контроллерами.</p><p>Директория <code>system</code> содержит системные тесты, используемые для полного браузерного тестирования вашего приложения. Системные тесты позволяют тестировать приложение так, как ваши пользователи взаимодействуют с ним, а также тестировать ваш JavaScript. Системные тесты наследуются от Capybara и выполняются в браузере.</p><p>Фикстуры это способ организации тестовых данных; они находятся в директории <code>fixtures</code>.</p><p>Также будет создана директория <code>jobs</code>, как только первый связанные тест будет сгенерирован.</p><p>Файл <code>test_helper.rb</code> содержит конфигурацию по умолчанию для ваших тестов.</p><p><code>application_system_test_case.rb</code> содержит настройки по умолчанию для ваших системных тестов.</p><h4 id='testovaya-sreda-razrabotki' class='inside_page_header'><a href="#testovaya-sreda-razrabotki">2.2.</a> Тестовая среда разработки</h4><p>По умолчанию каждое приложение на Rails имеет три среды разработки: development, test и production. База данных для каждой из них настраивается в <code>config/database.yml</code>.</p><p>Схожим образом можно модифицировать конфигурацию среды. В этом случае можно модифицировать тестовую среду, изменяя опции в <code>config/environments/test.rb</code>.</p><div class="note"><p>Ваши тесты запускаются с <code>RAILS_ENV=test</code>.</p></div><h4 id='rails-vstretilsya-s-minitest' class='inside_page_header'><a href="#rails-vstretilsya-s-minitest">2.3.</a> Rails встретился с Minitest</h4><p>Если помните, мы использовали команду <code>bin/rails generate model</code> в руководстве <a href="/getting-started">Rails для начинающих</a>. Мы создали нашу первую модель, где, среди прочего, создались незаконченные тесты в папке <code>test</code>:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate model article title:string body:text
<span class="c">...
</span><span class="go">create  app/models/article.rb
create  test/models/article_test.rb
create  test/fixtures/articles.yml
</span><span class="c">...
</span></code></pre>
</div>
<p>Незаконченный тест по умолчанию в <code>test/models/article_test.rb</code> выглядит так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ArticleTest</span> <span class="o">&lt;</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="c1"># test "the truth" do</span>
  <span class="c1">#   assert true</span>
  <span class="c1"># end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Построчное изучение этого файла поможет ориентироваться в коде тестирования и терминологии Rails.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>
</code></pre>
</div>
<p>Требуя этот файл, загружается конфигурация по умолчанию <code>test_helper.rb</code> для запуска наших тестов. Мы будем включать эту строку во все написанные тесты, таким образом, все методы, добавленные в этот файл, будут доступны во всех наших тестах.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ArticleTest</span> <span class="o">&lt;</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Класс <code>ArticleTest</code> определяет <em>тестовый случай</em>, поскольку он унаследован от <code>ActiveSupport::TestCase</code>. Поэтому <code>ArticleTest</code> имеет все методы, доступные в <code>ActiveSupport::TestCase</code>. Позже в этом руководстве мы увидим некоторые из методов, которые он нам дает.</p><p>Любой метод, определенный в классе, унаследованном от <code>Minitest::Test</code> (который является суперклассом для <code>ActiveSupport::TestCase</code>), начинающийся с <code>test_</code>, просто вызывает тест. Таким образом, методы, определенные как <code>test_password</code> и <code>test_valid_password</code>, это правильные имена тестов, и запустятся автоматически при запуске тестового случая.</p><p>Rails также добавляет метод <code>test</code>, который принимает имя теста и блок. Он генерирует обычный тест <code>MiniTest::Unit</code> с именем метода, начинающегося с <code>test_</code>, поэтому можно не беспокоиться об именовании методов, а просто писать так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"the truth"</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Это является приблизительно тем же, как если бы написали:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">def</span> <span class="nf">test_the_truth</span>
  <span class="n">assert</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Хотя вы все еще можете использовать обычные определения методов, использование макроса <code>test</code> позволяет получить более читаемое имя теста.</p><div class="note"><p>Имя метода генерируется, заменяя пробелы на подчеркивания. Впрочем, результат не должен быть валидным идентификатором Ruby - имя может содержать знаки пунктуации и т.д. Это связано с тем, что в Ruby технически любая строка может быть именем метода. Это может потребовать, чтобы вызовы <code>define_method</code> и <code>send</code> функционировали правильно, но формально есть только небольшое ограничение на имя.</p></div><p>Далее посмотрим на наше первое утверждение:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">assert</span> <span class="kp">true</span>
</code></pre>
</div>
<p>Утверждение (assertion) - это строчка кода, которая вычисляет объект (или выражение) для ожидаемых результатов. Например, утверждение может проверить:</p><ul><li>является ли это значение равным тому значению?
</li><li>является ли этот объект <code>nil</code>?
</li><li>вызывает ли эта строчка кода исключение?
</li><li>является ли пароль пользователя больше, чем 5 символов?
</li></ul><p>Каждый тест должен содержать одно или более утверждений, без ограничений на их максимальное количество. Только когда все утверждения успешны, тест проходит.</p><h5 id='vash-pervyy-padayuschiy-test' class='inside_page_header'><a href="#vash-pervyy-padayuschiy-test">2.3.1.</a> Ваш первый падающий тест</h5><p>Чтобы увидеть, как сообщается провал теста, вы можете добавить проваливающийся тест в тестовый случай <code>article_test.rb</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"should not save article without title"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">new</span>
  <span class="n">assert_not</span> <span class="n">article</span><span class="p">.</span><span class="nf">save</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Давайте запустим только что добавленный тест (где <code>6</code> - это номер строчки, где определен тест).</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/models/article_test.rb:6
<span class="go">Run options: --seed 44656

</span><span class="gp">#</span><span class="w"> </span>Running:
<span class="go">
F

Failure:
</span><span class="gp">ArticleTest#</span>test_should_not_save_article_without_title <span class="o">[</span>/path/to/blog/test/models/article_test.rb:6]:
<span class="go">Expected true to be nil or false


bin/rails test test/models/article_test.rb:6


Finished in 0.023918s, 41.8090 runs/s, 41.8090 assertions/s.

1 runs, 1 assertions, 1 failures, 0 errors, 0 skips
</span></code></pre>
</div>
<p>В результате <code>F</code> обозначает провал. Можете увидеть соответствующую трассировку под <code>Failure</code> вместе с именем провалившегося теста. Следующие несколько строчек содержат трассировку стека, затем сообщение, где упомянуто фактическое значение и ожидаемое в утверждении значение. По умолчанию сообщение для утверждения предоставляет достаточно информации, чтобы помочь выявить ошибку. Чтобы сделать сообщение о провале для утверждения более читаемым, каждое утверждение предоставляет опциональный параметр для сообщения, как показано тут:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"should not save article without title"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">new</span>
  <span class="n">assert_not</span> <span class="n">article</span><span class="p">.</span><span class="nf">save</span><span class="p">,</span> <span class="s2">"Saved the article without a title"</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Запуск этого теста покажет более дружелюбное сообщение для утверждения:</p><div class="code_container">
  <pre><code class="highlight plaintext">Failure:
ArticleTest#test_should_not_save_article_without_title [/path/to/blog/test/models/article_test.rb:6]:
Saved the article without a title
</code></pre>
</div>
<p>Теперь, чтобы этот тест прошел, можно добавить валидацию на уровне модели для поля <em>title</em>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">validates</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Теперь тест пройдет. Давайте убедимся в этом, запустив его снова:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/models/article_test.rb:6
<span class="go">Run options: --seed 31252

</span><span class="gp">#</span><span class="w"> </span>Running:
<span class="go">
</span><span class="c">.
</span><span class="go">Finished in 0.027476s, 36.3952 runs/s, 36.3952 assertions/s.

1 runs, 1 assertions, 0 failures, 0 errors, 0 skips
</span></code></pre>
</div>
<p>Теперь, если вы заметили, мы сначала написали провальный тест для желаемой функциональности, затем мы написали некоторый код, добавляющий функциональность, и, наконец, мы убедились, что наш тест прошел. Этот подход к разработке программного обеспечения называют <a href="http://c2.com/cgi/wiki?TestDrivenDevelopment"><em>Разработка через тестирование, Test-Driven Development</em> (TDD)</a>.</p><h5 id='kak-vyglyadit-oshibka' class='inside_page_header'><a href="#kak-vyglyadit-oshibka">2.3.2.</a> Как выглядит ошибка</h5><p>Чтобы увидеть, как сообщается об ошибке, вот тест, содержащий ошибку:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"should report error"</span> <span class="k">do</span>
  <span class="c1"># переменная some_undefined_variable не определена в другом месте тестового случая</span>
  <span class="n">some_undefined_variable</span>
  <span class="n">assert</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Теперь вы увидите чуть больше результата в консоли от запуска тестов:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/models/article_test.rb
<span class="go">Run options: --seed 1808

</span><span class="gp">#</span><span class="w"> </span>Running:
<span class="go">
.E

Error:
</span><span class="gp">ArticleTest#</span>test_should_report_error:
<span class="gp">NameError: undefined local variable or method 'some_undefined_variable' for #</span>&lt;ArticleTest:0x007fee3aa71798&gt;
<span class="gp">    test/models/article_test.rb:11:in 'block in &lt;class:ArticleTest&gt;</span><span class="s1">'
</span><span class="go">

bin/rails test test/models/article_test.rb:9



Finished in 0.040609s, 49.2500 runs/s, 24.6250 assertions/s.

2 runs, 1 assertions, 0 failures, 1 errors, 0 skips
</span></code></pre>
</div>
<p>Отметьте &#39;E&#39; в результате. Она отмечает тест с ошибкой.</p><div class="note"><p>Выполнение каждого тестового метода останавливается, как только возникают какие-либо ошибки или провал утверждения, и тестовый набор продолжается со следующего метода. Все тестовые методы выполняются в случайном порядке. Для настройки порядка тестирования может быть использована опция <a href="/configuring#configuring-active-support"><code>config.active_support.test_order</code></a>.</p></div><p>Когда тест проваливается, вам показывается соответствующий бэктрейс. По умолчанию Rails фильтрует этот бэктрейс и печатает только строчки, относящиеся к вашему приложению. Это устраняет шум от фреймворка и помогает сфокусироваться на вашем коде. Однако, бывают ситуации, когда вам захочется увидеть полный бэктрейс. Установите аргумент <code>-b</code> (или <code>--backtrace</code>) для включения этого поведения:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test</span> <span class="nt">-b</span> <span class="nb">test</span>/models/article_test.rb
</code></pre>
</div>
<p>Если хотите, чтобы этот тест прошел, можно его модифицировать, используя <code>assert_raises</code> следующим образом:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"should report error"</span> <span class="k">do</span>
  <span class="c1"># переменная some_undefined_variable не определена в тесте</span>
  <span class="n">assert_raises</span><span class="p">(</span><span class="no">NameError</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">some_undefined_variable</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Теперь этот тест должен пройти.</p><h4 id='dostupnye-utverzhdeniya' class='inside_page_header'><a href="#dostupnye-utverzhdeniya">2.4.</a> Доступные утверждения</h4><p>К этому моменту вы уже увидели некоторые из имеющихся утверждений. Утверждения - это рабочие лошадки тестирования. Они единственные, кто фактически выполняет проверки, чтобы убедиться, что все работает как задумано.</p><p>Ниже представлена выдержка утверждений, которые вы можете использовать с <a href="https://github.com/minitest/minitest"><code>Minitest</code></a>, библиотекой тестирования, используемой Rails по умолчанию. Параметр <code>[msg]</code> - это опциональное строковое сообщение, которое вы можете указать для того, чтобы сделать сообщение о провале более ясным.</p><table class='table table-striped'><tr>
<th>Утверждение</th>
<th>Назначение</th>
</tr>
<tr>
<td><code>assert( test, [msg] )</code></td>
<td>Утверждает, что <code>test</code> истинно.</td>
</tr>
<tr>
<td><code>assert_not( test, [msg] )</code></td>
<td>Утверждает, что <code>test</code> ложно.</td>
</tr>
<tr>
<td><code>assert_equal( expected, actual, [msg] )</code></td>
<td>Утверждает, что <code>expected == actual</code> истинно.</td>
</tr>
<tr>
<td><code>assert_not_equal( expected, actual, [msg] )</code></td>
<td>Утверждает, что <code>expected != actual</code> истинно.</td>
</tr>
<tr>
<td><code>assert_same( expected, actual, [msg] )</code></td>
<td>Утверждает, что <code>expected.equal?(actual)</code> истинно.</td>
</tr>
<tr>
<td><code>assert_not_same( expected, actual, [msg] )</code></td>
<td>Утверждает, что <code>expected.equal?(actual)</code> ложно.</td>
</tr>
<tr>
<td><code>assert_nil( obj, [msg] )</code></td>
<td>Утверждает, что <code>obj.nil?</code> истинно.</td>
</tr>
<tr>
<td><code>assert_not_nil( obj, [msg] )</code></td>
<td>Утверждает, что <code>obj.nil?</code> ложно.</td>
</tr>
<tr>
<td><code>assert_empty( obj, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> является <code>empty?</code>.</td>
</tr>
<tr>
<td><code>assert_not_empty( obj, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> не является <code>empty?</code>.</td>
</tr>
<tr>
<td><code>assert_match( regexp, string, [msg] )</code></td>
<td>Утверждает, что строка соответствует регулярному выражению.</td>
</tr>
<tr>
<td><code>assert_no_match( regexp, string, [msg] )</code></td>
<td>Утверждает, что строка не соответствует регулярному выражению.</td>
</tr>
<tr>
<td><code>assert_includes( collection, obj, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> находится в <code>collection</code>.</td>
</tr>
<tr>
<td><code>assert_not_includes( collection, obj, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> не находится в <code>collection</code>.</td>
</tr>
<tr>
<td><code>assert_in_delta( expected, actual, [delta], [msg] )</code></td>
<td>Утверждает, что между числами <code>expected</code> и <code>actual</code> разницу <code>delta</code>.</td>
</tr>
<tr>
<td><code>assert_not_in_delta( expected, actual, [delta], [msg] )</code></td>
<td>Утверждает, что между числами <code>expected</code> и <code>actual</code> разница, отличная от <code>delta</code>.</td>
</tr>
<tr>
<td><code>assert_in_epsilon ( expected, actual, [epsilon], [msg] )</code></td>
<td>Утверждает, что между числами <code>expected</code> и <code>actual</code> относительная погрешность меньше, чем <code>epsilon</code>.</td>
</tr>
<tr>
<td><code>assert_not_in_epsilon ( expected, actual, [epsilon], [msg] )</code></td>
<td>Утверждает, что между числами <code>expected</code> и <code>actual</code> относительная погрешность не меньше, чем <code>epsilon</code>.</td>
</tr>
<tr>
<td><code>assert_throws( symbol, [msg] ) { block }</code></td>
<td>Утверждает, что переданный блок бросает symbol.</td>
</tr>
<tr>
<td><code>assert_raises( exception1, exception2, ... ) { block }</code></td>
<td>Утверждает, что переданный блок генерирует одно из переданных исключений.</td>
</tr>
<tr>
<td><code>assert_instance_of( class, obj, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> является экземпляром <code>class</code>.</td>
</tr>
<tr>
<td><code>assert_not_instance_of( class, obj, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> не является экземпляром <code>class</code>.</td>
</tr>
<tr>
<td><code>assert_kind_of( class, obj, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> является экземпляром <code>class</code> или класса, наследуемого от него.</td>
</tr>
<tr>
<td><code>assert_not_kind_of( class, obj, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> не является экземпляром <code>class</code> или класса, наследуемого от него.</td>
</tr>
<tr>
<td><code>assert_respond_to( obj, symbol, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> отвечает на <code>symbol</code>.</td>
</tr>
<tr>
<td><code>assert_not_respond_to( obj, symbol, [msg] )</code></td>
<td>Утверждает, что <code>obj</code> не отвечает на <code>symbol</code>.</td>
</tr>
<tr>
<td><code>assert_operator( obj1, operator, [obj2], [msg] )</code></td>
<td>Утверждает, что <code>obj1.operator(obj2)</code> истинно.</td>
</tr>
<tr>
<td><code>assert_not_operator( obj1, operator, [obj2], [msg] )</code></td>
<td>Утверждает, что <code>obj1.operator(obj2)</code> ложно.</td>
</tr>
<tr>
<td><code>assert_predicate ( obj, predicate, [msg] )</code></td>
<td>Утверждает, что <code>obj.predicate</code> истинно, т.е. <code>assert_predicate str, :empty?</code></td>
</tr>
<tr>
<td><code>assert_not_predicate ( obj, predicate, [msg] )</code></td>
<td>Утверждает, что <code>obj.predicate</code> ложно, т.е. <code>assert_not_predicate str, :empty?</code></td>
</tr>
<tr>
<td><code>assert_error_reported(class) { block }</code></td>
<td>Утверждает, что был сообщен класс ошибки, например <code>assert_error_reported IOError { Rails.error.report(IOError.new(&quot;Oops&quot;)) }</code></td>
</tr>
<tr>
<td><code>assert_no_error_reported { block }</code></td>
<td>Утверждает, что ни одной ошибки не было сообщено, например <code>assert_no_error_reported { perform_service }</code></td>
</tr>
<tr>
<td><code>flunk( [msg] )</code></td>
<td>Утверждает провал. Это полезно для явного указания теста, который еще не закончен.</td>
</tr>
</table><p>Представленный выше список утверждений поддерживается minitest. Более полный и более актуальный список всех доступных утверждений смотрите в <a href="http://docs.seattlerb.org/minitest/">документации Minitest API</a>, в частности <a href="http://docs.seattlerb.org/minitest/Minitest/Assertions.html"><code>Minitest::Assertions</code></a></p><p>В силу модульной природы фреймворка тестирования, возможно создать свои собственные утверждения. Фактически Rails так и делает. Он включает некоторые специализированные утверждения, чтобы сделать жизнь разработчика проще.</p><div class="note"><p>Создание собственных утверждений это особый разговор, которого мы касаться не будем.</p></div><h4 id='spetsifichnye-utverzhdeniya-rails' class='inside_page_header'><a href="#spetsifichnye-utverzhdeniya-rails">2.5.</a> Специфичные утверждения Rails</h4><p>Rails добавляет некоторые свои утверждения в фреймворк <code>minitest</code>:</p><table class='table table-striped'><tr>
<th>Утверждение</th>
<th>Назначение</th>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_difference)"><code>assert_difference(expressions, difference = 1, message = nil) {...}</code></a></td>
<td>Тестирует числовую разницу между возвращаемым значением expression и результатом вычисления в данном блоке.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_no_difference"><code>assert_no_difference(expressions, message = nil, &amp;block)</code></a></td>
<td>Утверждает, что числовой результат вычисления expression не изменяется до и после применения переданного в блоке.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_changes"><code>assert_changes(expressions, message = nil, from:, to:, &amp;block)</code></a></td>
<td>Тестирует, что результат вычисления expression изменится после применения переданного в блоке.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_no_changes"><code>assert_no_changes(expressions, message = nil, &amp;block)</code></a></td>
<td>Тестирует, что результат вычисления expression не изменится после применения переданного в блоке.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_nothing_raised"><code>assert_nothing_raised { block }</code></a></td>
<td>Обеспечивает, что данный блок не вызывает какие-либо исключения.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html#method-i-assert_recognizes"><code>assert_recognizes(expected_options, path, extras={}, message=nil)</code></a></td>
<td>Обеспечивает, что роутинг данного path был правильно обработан, и что проанализированные опции (заданные в хэше expected_options) соответствуют path. По существу он утверждает, что Rails распознает маршрут, заданный в expected_options.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html#method-i-assert_generates"><code>assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)</code></a></td>
<td>Утверждает, что предоставленные options могут быть использованы для генерации предоставленного пути. Это противоположность assert_recognizes. Параметр extras используется, чтобы сообщить запросу имена и значения дополнительных параметров запроса, которые могут быть в строке запроса. Параметр message позволяет определить свое сообщение об ошибке при провале утверждения.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActionDispatch/Assertions/ResponseAssertions.html#method-i-assert_response"><code>assert_response(type, message = nil)</code></a></td>
<td>Утверждает, что отклик идет с определенным кодом статуса. Можете определить <code>:success</code> для обозначения 200-299, <code>:redirect</code> для обозначения 300-399, <code>:missing</code> для обозначения 404, или <code>:error</code> для соответствия интервалу 500-599. Можно передать явный номер статуса или его символьный эквивалент. Более подробно смотрите в <a href="https://rubydoc.info/gems/rack/Rack/Utils#HTTP_STATUS_CODES-constant">полном списке кодов статуса</a> и как работает их <a href="https://rubydoc.info/gems/rack/Rack/Utils#SYMBOL_TO_STATUS_CODE-constant">привязка</a>.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActionDispatch/Assertions/ResponseAssertions.html#method-i-assert_redirected_to"><code>assert_redirected_to(options = {}, message=nil)</code></a></td>
<td>Утверждает, что отклик - это перенаправление на URL, соответствующий заданным опциям. Также можно передать именованные маршруты, как в <code>assert_redirected_to root_path</code>, и объекты Active Record, как в <code>assert_redirected_to @article</code>.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActiveRecord/Assertions/QueryAssertions.html#method-i-assert_queries_count"><code>assert_queries_count(count = nil, include_schema: false, &amp;block)</code></a></td>
<td>Утверждает, что  <code>&amp;block</code> генерирует <code>int</code> раз запросы SQL.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActiveRecord/Assertions/QueryAssertions.html#method-i-assert_no_queries"><code>assert_no_queries(include_schema: false, &amp;block)</code></a></td>
<td>Утверждает, что  <code>&amp;block</code> не генерирует запросы SQL.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActiveRecord/Assertions/QueryAssertions.html#method-i-assert_queries_match"><code>assert_queries_match(pattern, count: nil, include_schema: false, &amp;block)</code></a></td>
<td>Утверждает, что <code>&amp;block</code> генерирует запросы SQL, соответствующие образцу.</td>
</tr>
<tr>
<td><a href="https://api.rubyonrails.org/classes/ActiveRecord/Assertions/QueryAssertions.html#method-i-assert_no_queries_match"><code>assert_no_queries_match(pattern, &amp;block)</code></a></td>
<td>Утверждает, что  <code>&amp;block</code> не генерирует запросы SQL, соответствующие образцу.</td>
</tr>
</table><p>Вы увидите использование некоторых из этих утверждений в следующей части.</p><h4 id='kratkaya-zametka-o-testovyh-sluchayah' class='inside_page_header'><a href="#kratkaya-zametka-o-testovyh-sluchayah">2.6.</a> Краткая заметка о тестовых случаях</h4><p>Все основные утверждения, такие как <code>assert_equal</code>, определенные в <code>Minitest::Assertions</code>, также доступны в классах, используемых в наших тестовых случаях. Фактически, Rails представляет вам следующие классы для наследования:</p><ul><li><a href="https://api.rubyonrails.org/classes/ActiveSupport/TestCase.html"><code>ActiveSupport::TestCase</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActionMailer/TestCase.html"><code>ActionMailer::TestCase</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActionView/TestCase.html"><code>ActionView::TestCase</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveJob/TestCase.html"><code>ActiveJob::TestCase</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActionDispatch/IntegrationTest.html"><code>ActionDispatch::IntegrationTest</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActionDispatch/SystemTestCase.html"><code>ActionDispatch::SystemTestCase</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/Rails/Generators/TestCase.html"><code>Rails::Generators::TestCase</code></a>
</li></ul><p>Каждый из этих классов включает <code>Minitest::Assertions</code>, позволяя использовать все основные утверждения в наших тестах.</p><div class="note"><p>За подробностями о <code>Minitest</code> обратитесь к <a href="http://docs.seattlerb.org/minitest">его документации</a></p></div><h4 id='zapusk-testov-rails' class='inside_page_header'><a href="#zapusk-testov-rails">2.7.</a> Запуск тестов Rails</h4><p>Можно запустить все тесты за раз с помощью команды <code>bin/rails test</code>.</p><p>Или можно запустить отдельный тест, передав команде <code>bin/rails test</code> имя файла, содержащего тестовые случаи.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/models/article_test.rb
<span class="go">Run options: --seed 1559

</span><span class="gp">#</span><span class="w"> </span>Running:
<span class="go">
</span><span class="c">..
</span><span class="go">
Finished in 0.027034s, 73.9810 runs/s, 110.9715 assertions/s.

2 runs, 3 assertions, 0 failures, 0 errors, 0 skips
</span></code></pre>
</div>
<p>Это запустит все тестовые методы из тестового случая.</p><p>Также можете запустить определенный тестовый метод из тестового случая, предоставив флажок <code>-n</code> или <code>--name</code> и имя метода теста.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/models/article_test.rb <span class="nt">-n</span> test_the_truth
<span class="go">Run options: -n test_the_truth --seed 43583

</span><span class="gp">#</span><span class="w"> </span>Running:
<span class="go">
</span><span class="c">.
</span><span class="go">
Finished tests in 0.009064s, 110.3266 tests/s, 110.3266 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
</span></code></pre>
</div>
<p>Также можно запустить тест в определенной строчке, предоставив номер строчки.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/models/article_test.rb:6 <span class="c"># запускает определенный тест и строчку</span>
</code></pre>
</div>
<p>Также можно запустить ряд тестов, предоставив ряд строк.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/models/article_test.rb:6-20 <span class="c"># запускает тесты со строчки 6 до 20</span>
</code></pre>
</div>
<p>Также можно запустить целую директорию тестов, предоставив путь к этой директории.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/controllers <span class="c"># запускает все тесты из определенной директории</span>
</code></pre>
</div>
<p>Для запуска тестов также имеется множество других особенностей, таких как падение при первой ошибке (failing fast), вывод результатов тестов после запуска тестов и так далее. Документацию по запуску тестов можно просмотреть так:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test</span> <span class="nt">-h</span>
<span class="go">
Usage: rails test [options] [files or directories]

You can run a single test by appending a line number to a filename:

    bin/rails test test/models/user_test.rb:27

You can run multiple tests with in a line range by appending the line range to a filename:

    bin/rails test test/models/user_test.rb:10-20

You can run multiple files and directories at the same time:

    bin/rails test test/controllers test/integration/login_test.rb

By default test failures and errors are reported inline during a run.

minitest options:
    -h, --help                       Display this help.
</span><span class="gp">        --no-plugins                 Bypass minitest plugin auto-loading (or set $</span>MT_NO_PLUGINS<span class="o">)</span><span class="nb">.</span>
<span class="go">    -s, --seed SEED                  Sets random seed. Also via env. Eg: SEED=n rake
    -v, --verbose                    Verbose. Show progress processing files.
    -n, --name PATTERN               Filter run on /regexp/ or string.
        --exclude PATTERN            Exclude /regexp/ or string from run.

Known extensions: rails, pride
    -w, --warnings                   Run with Ruby warnings enabled
    -e, --environment ENV            Run tests in the ENV environment
    -b, --backtrace                  Show the complete backtrace
    -d, --defer-output               Output test failures and errors after the test run
    -f, --fail-fast                  Abort test run on first failure or error
    -c, --[no-]color                 Enable color in the output
    -p, --pride                      Pride. Show your testing pride!
</span></code></pre>
</div>
<h4 id='running-tests-in-continuous-integration-ci' class='inside_page_header'><a href="#running-tests-in-continuous-integration-ci">2.8.</a> Запуск тестов в Непрерывной Интеграции (CI)</h4><p>Для запуска всех тестов в среде CI достаточно одной команды:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test</span>
</code></pre>
</div>
<p>Однако, данная команда не запускает <a href="#system-testing">системные тесты</a> (обычно более медленные), если вы их используете. Для включения системных тестов, добавьте еще один шаг CI, который выполняет команду <code>bin/rails test:system</code>, либо измените свой начальный шаг на <code>bin/rails test:all</code>, которая запускает все тесты, включая системные.</p><h3 id='parallel-testing' class='inside_page_header'><a href="#parallel-testing">3.</a> Параллельное тестирование</h3><p>Параллельное тестирование позволяет распараллелить тестовый набор. Хотя форк процессов является методом по умолчанию, треды также поддерживаются. Запуск тестов параллельно сокращает время, затрачиваемое на запуск всего тестового набора.</p><h4 id='parallelnoe-testirovanie-s-pomoschyu-protsessov' class='inside_page_header'><a href="#parallelnoe-testirovanie-s-pomoschyu-protsessov">3.1.</a> Параллельное тестирование с помощью процессов</h4><p>Дефолтный метод распараллеливания - это форк процессов с помощью системы DRb. Процессы форкаются, основываясь на количестве предоставленных воркеров. Значение по умолчанию равно фактическому количеству ядер машины, но может быть изменено на число, переданное методу parallelize.</p><p>Чтобы включить распараллеливание, добавьте следующее в <code>test_helper.rb</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ActiveSupport::TestCase</span>
  <span class="n">parallelize</span><span class="p">(</span><span class="ss">workers: </span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Количество переданных воркеров равно количеству раз, когда процесс будет форкнут. Возможно, может понадобиться распараллелить локальный тестовый набор отлично от CI, поэтому предоставляется переменная среды, позволяющая легко изменять количество воркеров, которые должны использоваться для запуска теста:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nv">PARALLEL_WORKERS</span><span class="o">=</span>15 <span class="nb">bin/rails test</span>
</code></pre>
</div>
<p>При распараллеливании тестов Active Record автоматически обрабатывает создание базы данных и загрузку схемы в базу данных для каждого процесса. Базы данных будут иметь суффикс с цифрой, соответствующей воркеру. Например, если есть 2 воркера, тесты создадут <code>test-database-0</code> и<code>test-database-1</code> соответственно.</p><p>Если количество переданных воркеров равно 1 или менее, процессы не будут форкнуты, и тесты не будут распараллелены, и тесты будут использовать исходную базу данных <code>test-database</code>.</p><p>Предоставляются два хука, один запускается, когда процесс был форкнут, и еще один запускается до закрытия форкнутого процесса. Они могут быть полезны, если приложение использует несколько баз данных или выполняет другие задачи, зависящие от количества воркеров.</p><p>Метод <code>parallelize_setup</code> вызывается сразу после того, как процессы форкнуты. Метод <code>parallelize_teardown</code> вызывается непосредственно до закрытия процессов.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ActiveSupport::TestCase</span>
  <span class="n">parallelize_setup</span> <span class="k">do</span> <span class="o">|</span><span class="n">worker</span><span class="o">|</span>
    <span class="c1"># настройки баз данных</span>
  <span class="k">end</span>

  <span class="n">parallelize_teardown</span> <span class="k">do</span> <span class="o">|</span><span class="n">worker</span><span class="o">|</span>
    <span class="c1"># очистка баз данных</span>
  <span class="k">end</span>

  <span class="n">parallelize</span><span class="p">(</span><span class="ss">workers: :number_of_processors</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Эти методы не нужны или не доступны при параллельном тестировании с помощью тредов.</p><h4 id='parallelnoe-testirovanie-s-pomoschyu-tredov' class='inside_page_header'><a href="#parallelnoe-testirovanie-s-pomoschyu-tredov">3.2.</a> Параллельное тестирование с помощью тредов</h4><p>Если предпочитаете использовать треды или используете JRuby, предоставляется тредовая опция распараллеливания. Тредовый распараллеливатель поддерживается <code>Parallel::Executor</code> в Minitest.</p><p>Чтобы изменить метод распараллеливания для использования тредов над форками, необходимо добавить в <code>test_helper.rb</code></p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ActiveSupport::TestCase</span>
  <span class="n">parallelize</span><span class="p">(</span><span class="ss">workers: :number_of_processors</span><span class="p">,</span> <span class="ss">with: :threads</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Приложения Rails, сгенерированные от JRuby или TruffleRuby автоматически включают опцию <code>with: :threads</code>.</p><p>Число переданных воркеров в <code>parallelize</code> определяет количество тредов, которые будут использоваться в тестах. Возможно, может понадобиться распараллелить локальный тестовый набор отлично от CI, поэтому предоставляется переменная среды, позволяющая легко изменять количество воркеров, которые должны использоваться для запуска теста:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nv">PARALLEL_WORKERS</span><span class="o">=</span>15 <span class="nb">bin/rails test</span>
</code></pre>
</div>
<h4 id='testirovanie-parallelnyh-tranzaktsiy' class='inside_page_header'><a href="#testirovanie-parallelnyh-tranzaktsiy">3.3.</a> Тестирование параллельных транзакций</h4><p>Rails автоматически оборачивает тестовый случай в транзакцию базы данных, которая откатывается после завершения теста. Это обеспечивает независимость тестовых случаев друг от друга, и изменения в базе данных видны только в рамках отдельного теста.</p><p>когда нужно протестировать код, запускающий параллельные транзакции в тредах, транзакции могут блокировать друг друга, так как они уже вложены в транзакцию теста.</p><p>В классе тестового случая можно отключить транзакции, установив <code>self.use_transactional_tests = false</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">WorkerTest</span> <span class="o">&lt;</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">use_transactional_tests</span> <span class="o">=</span> <span class="kp">false</span>

  <span class="nb">test</span> <span class="s2">"parallel transactions"</span> <span class="k">do</span>
    <span class="c1"># запускайте несколько тредов, создающих транзакции</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="note"><p>В тестах с отключенными транзакциями необходимо очищать любые созданные тестовые данные, так как изменения не будут автоматически откачены после завершения теста.</p></div><h4 id='porog-rasparallelivaniya-testov' class='inside_page_header'><a href="#porog-rasparallelivaniya-testov">3.4.</a> Порог распараллеливания тестов</h4><p>Параллельный запуск тестов добавляет дополнительную нагрузку в терминах настройки базы данных и загрузки фикстур. Поэтому Rails не будет распараллеливать запуски, вовлекающие менее, чем 50 тестов.</p><p>Этот порог можно сконфигурировать в вашем <code>test.rb</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">config</span><span class="p">.</span><span class="nf">active_support</span><span class="p">.</span><span class="nf">test_parallelization_threshold</span> <span class="o">=</span> <span class="mi">100</span>
</code></pre>
</div>
<p>А также настроить распараллеливание на уровне тестового случая:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ActiveSupport::TestCase</span>
  <span class="n">parallelize</span> <span class="ss">threshold: </span><span class="mi">100</span>
<span class="k">end</span>
</code></pre>
</div>
<h3 id='testovaya-baza-dannyh' class='inside_page_header'><a href="#testovaya-baza-dannyh">4.</a> Тестовая база данных</h3><p>Почти каждое приложение на Rails сильно взаимодействует с базой данных, и, как результат, тестам также требуется база данных для работы. Чтобы писать эффективные тесты, следует понять, как настроить эту базу данных и наполнить ее образцом данных.</p><p>По умолчанию каждое приложение на Rails имеет три среды разработки: development, test и production. База данных для каждой из них настраивается в <code>config/database.yml</code>.</p><p>Отдельная тестовая база данных позволяет настраивать и работать с данными в изоляции. Таким образом, тесты могут искажать тестовые данные с уверенностью, не беспокоясь о данных в базах данных development или production.</p><h4 id='podderzhka-shemy-testovoy-bazy-dannyh' class='inside_page_header'><a href="#podderzhka-shemy-testovoy-bazy-dannyh">4.1.</a> Поддержка схемы тестовой базы данных</h4><p>Чтобы запустить тесты, ваша тестовая база данных должна иметь текущую структуры. Тестовый хелпер проверяет, не имеет ли ваша тестовая база данных отложенных миграций. Он пытается загрузить ваши <code>db/schema.rb</code> или <code>db/structure.sql</code> в тестовую базу данных. Если есть отложенные миграции - будет вызвана ошибка. Обычно это указывает на то, что ваша схема не полностью мигрирована. Запуск миграций для базы данных development (<code>bin/rails db:migrate</code>) приведет схему в актуальное состояние.</p><div class="note"><p>Если были модификации в существующих миграциях, нужно перестроить тестовую базу данных. Это делается с помощью выполнения <code>bin/rails db:test:prepare</code>.</p></div><h4 id='the-low-down-on-fixtures' class='inside_page_header'><a href="#the-low-down-on-fixtures">4.2.</a> Полная информация по фикстурам</h4><p>Для хороших тестов необходимо подумать о настройке тестовых данных. В Rails этим можно управлять, определяя и настраивая фикстуры. Подробности можно узнать в <a href="https://api.rubyonrails.org/classes/ActiveRecord/FixtureSet.html">документации API фикстур</a>.</p><h5 id='chto-takoe-fikstury' class='inside_page_header'><a href="#chto-takoe-fikstury">4.2.1.</a> Что такое фикстуры?</h5><p><em>Fixtures</em> это выдуманное слово для образцов данных. Фикстуры позволяют заполнить вашу тестовую базу данных предопределенными данными до запуска тестов. Фикстуры независимы от типа базы данных и написаны на YAML. На каждую модель имеется отдельный файл.</p><div class="note"><p>Фикстуры не разработаны для создания каждого объекта, требуемого в ваших тестах, и они лучше всего подходят только при использовании для данных по умолчанию, которые применимы в общем случае.</p></div><p>Фикстуры расположены в директории <code>test/fixtures</code>. Когда запускаете <code>bin/rails generate model</code> для создания новой модели, Rails автоматически создаст незаконченные фикстуры в этой директории.</p><h5 id='yaml' class='inside_page_header'><a href="#yaml">4.2.2.</a> YAML</h5><p>Фикстуры в формате YAML являются дружелюбным способом описать ваш образец данных. Этот тип фикстур имеет расширение файла <em>.yml</em> (как в <code>users.yml</code>).</p><p>Вот образец файла фикстуры YAML:</p><div class="code_container">
  <pre><code class="highlight yaml"><span class="c1"># О чудо! Я комментарий YAML!</span>
<span class="na">david</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">David Heinemeier Hansson</span>
  <span class="na">birthday</span><span class="pi">:</span> <span class="s">1979-10-15</span>
  <span class="na">profession</span><span class="pi">:</span> <span class="s">Systems development</span>

<span class="na">steve</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">Steve Ross Kellock</span>
  <span class="na">birthday</span><span class="pi">:</span> <span class="s">1974-09-27</span>
  <span class="na">profession</span><span class="pi">:</span> <span class="s">guy with keyboard</span>
</code></pre>
</div>
<p>Каждой фикстуре дается имя со следующим за ним списком с отступом пар ключ/значение, разделенных двоеточием. Записи обычно разделяются пустой строчкой. Можете помещать комментарии в файл фикстуры, используя символ # в первом столбце.</p><p>Если работаете со <a href="/active-record-associations">связями</a>, можно определить ссылку между двумя различными фикстурами. Вот пример для связи <code>belongs_to</code>/<code>has_many</code>:</p><div class="code_container">
  <pre><code class="highlight yaml"><span class="c1"># test/fixtures/categories.yml</span>
<span class="na">about</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">About</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight yaml"><span class="c1"># test/fixtures/articles.yml</span>
<span class="na">first</span><span class="pi">:</span>
  <span class="na">title</span><span class="pi">:</span> <span class="s">Welcome to Rails!</span>
  <span class="na">body</span><span class="pi">:</span> <span class="s">Hello world!</span>
  <span class="na">category</span><span class="pi">:</span> <span class="s">about</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight yaml"><span class="c1"># test/fixtures/action_text/rich_texts.yml</span>
<span class="na">first_content</span><span class="pi">:</span>
  <span class="na">record</span><span class="pi">:</span> <span class="s">first (Article)</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">content</span>
  <span class="na">body</span><span class="pi">:</span> <span class="s">&lt;div&gt;Hello, from &lt;strong&gt;a fixture&lt;/strong&gt;&lt;/div&gt;</span>
</code></pre>
</div>
<p>Отметьте, что у ключа <code>category</code> в статье <code>first</code> из <code>fixtures/articles.yml</code> значение <code>about</code>, и что у ключа <code>record</code> в позиции <code>first_content</code> из <code>fixtures/action_text/rich_texts.yml</code> значение <code>first (Article)</code>. Это подсказывает Active Record загрузить категорию <code>about</code> из <code>fixtures/categories.yml</code> для первого, и Action Text загрузить статью <code>first</code> из <code>fixtures/articles.yml</code> для последнего.</p><div class="note"><p>При связи двух записей по имени в связанных фикстурах можно использовать имя фикстуры вместо атрибута <code>id:</code> связанной фикстуры. Rails автоматически назначит первичный ключ, согласующийся между запусками. Подробнее об этом поведении связей можно прочитать в <a href="https://api.rubyonrails.org/classes/ActiveRecord/FixtureSet.html">документации API фикстур</a>.</p></div><h5 id='fikstury-dlya-faylovyh-vlozheniy' class='inside_page_header'><a href="#fikstury-dlya-faylovyh-vlozheniy">4.2.3.</a> Фикстуры для файловых вложений</h5><p>Подобно другим моделям Active Record, записи вложений Active Storage наследуются от экземпляров ActiveRecord::Base и, поэтому, могут создаваться фикстурами.</p><p>Рассмотрим модель <code>Article</code> со связанным изображением, вложенным как <code>thumbnail</code>, вместе с данными фикстуры YAML:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Article</span>
  <span class="n">has_one_attached</span> <span class="ss">:thumbnail</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight yaml"><span class="c1"># test/fixtures/articles.yml</span>
<span class="na">first</span><span class="pi">:</span>
  <span class="na">title</span><span class="pi">:</span> <span class="s">An Article</span>
</code></pre>
</div>
<p>Допустим, что у нас есть файл, кодированный как <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#image_types">image/png</a>, в <code>test/fixtures/files/first.png</code>, следующие позиции фикстуры YAML сгенерируют соответствующие записи <code>ActiveStorage::Blob</code> и <code>ActiveStorage::Attachment</code>:</p><div class="code_container">
  <pre><code class="highlight yaml"><span class="c1"># test/fixtures/active_storage/blobs.yml</span>
<span class="na">first_thumbnail_blob</span><span class="pi">:</span> <span class="s">&lt;%= ActiveStorage::FixtureSet.blob filename</span><span class="pi">:</span> <span class="s2">"</span><span class="s">first.png"</span> <span class="err">%</span><span class="pi">&gt;</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight yaml"><span class="c1"># test/fixtures/active_storage/attachments.yml</span>
<span class="na">first_thumbnail_attachment</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">thumbnail</span>
  <span class="na">record</span><span class="pi">:</span> <span class="s">first (Article)</span>
  <span class="na">blob</span><span class="pi">:</span> <span class="s">first_thumbnail_blob</span>
</code></pre>
</div>
<h5 id='erb' class='inside_page_header'><a href="#erb">4.2.4.</a> ERb</h5><p>ERb позволяет встраивать код Ruby в шаблоны. Формат фикстур YAML предварительно обрабатывается с помощью ERb при загрузке фикстур. Это позволяет использовать Ruby для помощи в генерации некоторых образцов данных. Например, следующий код сгенерирует тысячу пользователей:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="cp">&lt;%</span> <span class="mi">1000</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="cp">%&gt;</span>
  user_<span class="cp">&lt;%=</span> <span class="n">n</span> <span class="cp">%&gt;</span>:
    username: <span class="cp">&lt;%=</span> <span class="s2">"user</span><span class="si">#{</span><span class="n">n</span><span class="si">}</span><span class="s2">"</span> <span class="cp">%&gt;</span>
    email: <span class="cp">&lt;%=</span> <span class="s2">"user</span><span class="si">#{</span><span class="n">n</span><span class="si">}</span><span class="s2">@example.com"</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<h5 id='fikstury-v-deystvii' class='inside_page_header'><a href="#fikstury-v-deystvii">4.2.5.</a> Фикстуры в действии</h5><p>Rails по умолчанию автоматически загружает все фикстуры из директории <code>test/fixtures</code> для ваших тестов моделей и контроллеров. Загрузка состоит из трех этапов:</p><ul><li>Убираются любые существующие данные из таблицы, соответствующей фикстуре
</li><li>Загружаются данные фикстуры в таблицу
</li><li>Выгружаются данные фикстуры в переменную, в случае, если вы хотите обращаться к ним напрямую
</li></ul><div class="info"><p>Чтобы убрать существующие данные из базы, Rails пытается отключить триггеры ссылочной целостности (такие как внешние ключи и проверки ограничений). Если вы получаете надоедливые ошибки прав доступа при запуске тестов, убедитесь, что у пользователя базы данных есть права на отключение этих триггеров в тестовой среде. (В PostgreSQL только суперпользователи могут отключать все триггеры. Подробнее о правах доступа в PostgreSQL читайте <a href="https://www.postgresql.org/docs/current/sql-altertable.html">здесь</a>)</p></div><h5 id='fikstury-eto-ob-ekty-active-record' class='inside_page_header'><a href="#fikstury-eto-ob-ekty-active-record">4.2.6.</a> Фикстуры это объекты Active Record</h5><p>Фикстуры являются экземплярами Active Record. Как упоминалось в этапе №3 выше, Вы можете обращаться к объекту напрямую, поскольку он автоматически доступен как метод, область видимости которого локальна для тестового случая. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># это возвратит объект User для фикстуры с именем david</span>
<span class="n">users</span><span class="p">(</span><span class="ss">:david</span><span class="p">)</span>

<span class="c1"># это возвратит свойство для david, названное id</span>
<span class="n">users</span><span class="p">(</span><span class="ss">:david</span><span class="p">).</span><span class="nf">id</span>

<span class="c1"># он имеет доступ к методам, доступным для класса User</span>
<span class="n">david</span> <span class="o">=</span> <span class="n">users</span><span class="p">(</span><span class="ss">:david</span><span class="p">)</span>
<span class="n">david</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">david</span><span class="p">.</span><span class="nf">partner</span><span class="p">)</span>
</code></pre>
</div>
<p>Чтобы получить несколько фикстур за раз, вы можете передать список имен фикстур. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># это возвратит массив, содержащий фикстуры david и steve</span>
<span class="n">users</span><span class="p">(</span><span class="ss">:david</span><span class="p">,</span> <span class="ss">:steve</span><span class="p">)</span>
</code></pre>
</div>
<h3 id='testirovanie-modeley' class='inside_page_header'><a href="#testirovanie-modeley">5.</a> Тестирование моделей</h3><p>Тесты моделей используются для тестирования различных моделей вашего приложения.</p><p>Тесты моделей Rails хранятся в директории <code>test/models</code> directory. Rails предоставляет генератор для создания скелета теста модели.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate test_unit:model article title:string body:text
<span class="go">create  test/models/article_test.rb
create  test/fixtures/articles.yml
</span></code></pre>
</div>
<p>У тестов модели нет своего собственного суперкласса, такого как <code>ActionMailer::TestCase</code>. Вместо этого они наследуются от <a href="https://api.rubyonrails.org/classes/ActiveSupport/TestCase.html"><code>ActiveSupport::TestCase</code></a>.</p><h3 id='system-testing' class='inside_page_header'><a href="#system-testing">6.</a> Системное тестирование</h3><p>Системные тесты позволяют тестировать взаимодействие пользователя с вашим приложением, запускать тесты либо в реальном, либо в headless браузере. Системные тесты используют Capybara под капотом.</p><p>Для создания системных тестов Rails используют директорию приложения <code>test/system</code>. Rails предоставляет генератор для создания скелета системного теста.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate system_test <span class="nb">users</span>
<span class="go">      invoke test_unit
      create test/system/users_test.rb
</span></code></pre>
</div>
<p>Вот как выглядит свежесгенерированный системный тест:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"application_system_test_case"</span>

<span class="k">class</span> <span class="nc">UsersTest</span> <span class="o">&lt;</span> <span class="no">ApplicationSystemTestCase</span>
  <span class="c1"># test "visiting the index" do</span>
  <span class="c1">#   visit users_url</span>
  <span class="c1">#</span>
  <span class="c1">#   assert_selector "h1", text: "Users"</span>
  <span class="c1"># end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>По умолчанию системные тесты запускаются с помощью драйвера Selenium с использованием браузера Chrome и разрешения экрана 1400x1400. Следующий раздел объясняет, как изменить настройки по умолчанию.</p><p>По умолчанию Rails пытается обработать исключения, возникшие во время тестов, и отобразить страницы ошибок в формате HTML. Это поведение можно контролировать с помощью настройки <a href="/configuring#config-action-dispatch-show-exceptions"><code>config.action_dispatch.show_exceptions</code></a>.</p><h4 id='izmenenie-nastroek-po-umolchaniyu' class='inside_page_header'><a href="#izmenenie-nastroek-po-umolchaniyu">6.1.</a> Изменение настроек по умолчанию</h4><p>В Rails изменить настройки по умолчанию для системных тестов очень просто. Все настройки абстрагированы, поэтому вы можете сфокусироваться на написании своих тестов.</p><p>При генерации нового приложения или скаффолда, в тестовой директории будет создан файл <code>application_system_test_case.rb</code>. Это то самое место, где должны находиться все настройки для ваших системных тестов.</p><p>Если хотите изменить настройки по умолчанию, надо изменить то, с помощью чего &quot;запускаются&quot; ваши системные тесты. Скажем, вы хотите изменить драйвер с Selenium на Cuprite. Сначала добавьте гем <code>cuprite</code> в свой <code>Gemfile</code>. Затем сделайте в своем файле <code>application_system_test_case.rb</code> следующее:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>
<span class="nb">require</span> <span class="s2">"capybara/cuprite"</span>

<span class="k">class</span> <span class="nc">ApplicationSystemTestCase</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">SystemTestCase</span>
  <span class="n">driven_by</span> <span class="ss">:cuprite</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Имя драйвера — обязательный аргумент для <code>driven_by</code>. Опциональные аргументы, который можно передать в <code>driven_by</code> это <code>:using</code> для браузера (используется только в Selenium), :screen_size, чтобы изменить размер экрана для скриншотов, и <code>:options</code>, которые могут использоваться для установки опций, поддерживаемых драйвером.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ApplicationSystemTestCase</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">SystemTestCase</span>
  <span class="n">driven_by</span> <span class="ss">:selenium</span><span class="p">,</span> <span class="ss">using: :firefox</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Если необходимо использовать headless-браузер, можно использовать Headless Chrome или Headless Firefox, добавив <code>headless_chrome</code> или <code>headless_firefox</code> в аргумент <code>:using</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ApplicationSystemTestCase</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">SystemTestCase</span>
  <span class="n">driven_by</span> <span class="ss">:selenium</span><span class="p">,</span> <span class="ss">using: :headless_chrome</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Если хотите использовать удаленный браузер, например <a href="https://github.com/SeleniumHQ/docker-selenium">Headless Chrome in Docker</a>, нужно добавить удаленный <code>url</code> и установить удаленный <code>browser</code> в <code>options</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ApplicationSystemTestCase</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">SystemTestCase</span>
  <span class="n">url</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"SELENIUM_REMOTE_URL"</span><span class="p">,</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="n">options</span> <span class="o">=</span> <span class="k">if</span> <span class="n">url</span>
    <span class="p">{</span> <span class="ss">browser: :remote</span><span class="p">,</span> <span class="ss">url: </span><span class="n">url</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="p">{</span> <span class="ss">browser: :chrome</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="n">driven_by</span> <span class="ss">:selenium</span><span class="p">,</span> <span class="ss">using: :headless_chrome</span><span class="p">,</span> <span class="ss">options: </span><span class="n">options</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Теперь следует получить соединение с удаленным браузером.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nv">SELENIUM_REMOTE_URL</span><span class="o">=</span>http://localhost:4444/wd/hub <span class="nb">bin/rails test</span>:system
</code></pre>
</div>
<p>Если ваше приложение в тестах также запускается удаленно, например в контейнере Docker, Capybara нужно больше данных, как <a href="https://github.com/teamcapybara/capybara#calling-remote-servers">вызывать удаленные серверы</a>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ApplicationSystemTestCase</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">SystemTestCase</span>
  <span class="k">def</span> <span class="nf">setup</span>
    <span class="no">Capybara</span><span class="p">.</span><span class="nf">server_host</span> <span class="o">=</span> <span class="s2">"0.0.0.0"</span> <span class="c1"># bind to all interfaces</span>
    <span class="no">Capybara</span><span class="p">.</span><span class="nf">app_host</span> <span class="o">=</span> <span class="s2">"http://</span><span class="si">#{</span><span class="no">IPSocket</span><span class="p">.</span><span class="nf">getaddress</span><span class="p">(</span><span class="no">Socket</span><span class="p">.</span><span class="nf">gethostname</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"SELENIUM_REMOTE_URL"</span><span class="p">].</span><span class="nf">present?</span>
    <span class="k">super</span>
  <span class="k">end</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Теперь следует получить соединение к удаленным браузеру и серверу, независимо, запущен он в контейнере Docker или CI.</p><p>Если вашей конфигурации для Capybara требуется больше настроек, чем предоставлено Rails, то эту дополнительную конфигурацию можно поместить в файл <code>application_system_test_case.rb</code>.</p><p>За дополнительными настройками обратитесь к <a href="https://github.com/teamcapybara/capybara#setup">документации Capybara</a>.</p><h4 id='helper-dlya-skrinshotov' class='inside_page_header'><a href="#helper-dlya-skrinshotov">6.2.</a> Хелпер для скриншотов</h4><p><code>ScreenshotHelper</code> - это хелпер, разработанный для захвата скриншотов ваших тестов.
Это полезно для просмотра браузера в момент, когда упал тест, или для просмотра скриншотов для отладки.</p><p>Предоставляются два метода: <code>take_screenshot</code> и <code>take_failed_screenshot</code>. <code>take_failed_screenshot</code> автоматически включается в <code>before_teardown</code> внутри Rails.</p><p>Вспомогательный метод <code>take_screenshot</code> может быть включен где угодно в ваших тестах, чтобы снять скриншот браузера.</p><h4 id='realizatsiya-sistemnogo-testa' class='inside_page_header'><a href="#realizatsiya-sistemnogo-testa">6.3.</a> Реализация системного теста</h4><p>Теперь мы собираемся добавить системный тест в наше приложение блога. Мы продемонстрируем написание системного теста для посещения индексной страницы и для создания статьи в блоге.</p><p>При использовании генератора скаффолда, автоматически создавался скелет системного теста. Если не использовать генератор скаффолда, нужно начать с создания скелета системного теста.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate system_test articles
</code></pre>
</div>
<p>Это создаст файл теста. В результате выполнения предыдущей команды вы увидите:</p><div class="code_container">
  <pre><code class="highlight plaintext">      invoke  test_unit
      create    test/system/articles_test.rb
</code></pre>
</div>
<p>Теперь откройте этот файл и напишите первой утверждение:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"application_system_test_case"</span>

<span class="k">class</span> <span class="nc">ArticlesTest</span> <span class="o">&lt;</span> <span class="no">ApplicationSystemTestCase</span>
  <span class="nb">test</span> <span class="s2">"viewing the index"</span> <span class="k">do</span>
    <span class="n">visit</span> <span class="n">articles_path</span>
    <span class="n">assert_selector</span> <span class="s2">"h1"</span><span class="p">,</span> <span class="ss">text: </span><span class="s2">"Articles"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Тест должен увидеть, что на индексной странице статей есть <code>h1</code> и пройти.</p><p>Запустите системные тесты.</p><div class="code_container">
  <pre><code class="highlight console"><span class="go">bin/rails test:system
</span></code></pre>
</div>
<div class="note"><p>По умолчанию, выполнение <code>bin/rails test</code> не будет запускать ваши системные тесты. Убедитесь, что вы выполняете <code>bin/rails test:system</code>, чтобы на самом деле запустить их. Также можно запустить <code>bin/rails test:all</code> для запуска всех тестов, включая системные тесты.</p></div><h5 id='sistemnyy-test-dlya-sozdaniya-statey' class='inside_page_header'><a href="#sistemnyy-test-dlya-sozdaniya-statey">6.3.1.</a> Системный тест для создания статей</h5><p>Теперь давайте протестируем процесс создания новой статьи в нашем блоге.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"should create Article"</span> <span class="k">do</span>
  <span class="n">visit</span> <span class="n">articles_path</span>

  <span class="n">click_on</span> <span class="s2">"New Article"</span>

  <span class="n">fill_in</span> <span class="s2">"Title"</span><span class="p">,</span> <span class="ss">with: </span><span class="s2">"Creating an Article"</span>
  <span class="n">fill_in</span> <span class="s2">"Body"</span><span class="p">,</span> <span class="ss">with: </span><span class="s2">"Created this article successfully!"</span>

  <span class="n">click_on</span> <span class="s2">"Create Article"</span>

  <span class="n">assert_text</span> <span class="s2">"Creating an Article"</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Первый шаг — это вызов <code>visit articles_path</code>. Это приведет тест на индексную страницу статей.</p><p>Затем <code>click_on &quot;New Article&quot;</code> найдет кнопку &quot;New Article&quot; на индексной странице. Это перенаправит браузер на <code>/articles/new</code>.</p><p>Затем браузер заполнит title и body статьи представленным текстом. Как только поля будут заполнены, будет нажата &quot;Create Article&quot;, что отправит запрос POST для создания новой статьи в базе данных.</p><p>Мы будем перенаправлены обратно на индексную страницу статей, где мы убедимся, что текст заголовка новой статьи присутствует на индексной странице статей.</p><h5 id='testirovanie-dlya-neskolkih-razmerov-ekrana' class='inside_page_header'><a href="#testirovanie-dlya-neskolkih-razmerov-ekrana">6.3.2.</a> Тестирование для нескольких размеров экрана</h5><p>Если необходимо протестировать размеры мобильных устройств поверх тестирования для десктопных, можно создать другой класс, который наследуется от <code>ActionDispatch::SystemTestCase</code> и использовать в тестовом наборе. В этом примере файл, называемый <code>mobile_system_test_case.rb</code>, создается в директории <code>/test</code> со следующей конфигурацией.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">MobileSystemTestCase</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">SystemTestCase</span>
  <span class="n">driven_by</span> <span class="ss">:selenium</span><span class="p">,</span> <span class="ss">using: :chrome</span><span class="p">,</span> <span class="ss">screen_size: </span><span class="p">[</span><span class="mi">375</span><span class="p">,</span> <span class="mi">667</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Чтобы использовать эту конфигурацию, нужно создать тест внутри <code>test/system</code>, который наследуется от <code>MobileSystemTestCase</code>. Теперь можно протестировать приложение, используя несколько разных конфигураций.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"mobile_system_test_case"</span>

<span class="k">class</span> <span class="nc">PostsTest</span> <span class="o">&lt;</span> <span class="no">MobileSystemTestCase</span>
  <span class="nb">test</span> <span class="s2">"visiting the index"</span> <span class="k">do</span>
    <span class="n">visit</span> <span class="n">posts_url</span>
    <span class="n">assert_selector</span> <span class="s2">"h1"</span><span class="p">,</span> <span class="ss">text: </span><span class="s2">"Posts"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h5 id='chto-dalshe' class='inside_page_header'><a href="#chto-dalshe">6.3.3.</a> Что дальше?</h5><p>Красота системного тестирования в том, что оно похоже на интеграционное тестирование в том, что оно тестирует взаимодействие пользователя с вашими контроллерами, моделями и вью, но системное тестирование более адекватное и фактически тестирует ваше приложение так, как его будет использовать реальный пользователь. Двигаясь дальше, можно протестировать все, что пользователь сможет делать в вашем приложении - комментирование, удаление статей, публикацию черновиков и так далее.</p><h3 id='integratsionnoe-testirovanie' class='inside_page_header'><a href="#integratsionnoe-testirovanie">7.</a> Интеграционное тестирование</h3><p>Интеграционные тесты используются для тестирования взаимодействия различных частей нашего приложения. Они в основном используются для тестирования важных рабочих процессов в нашем приложении.</p><p>Для создания интеграционных тестов Rails используется директория &#39;test/integration&#39; нашего приложения. Rails предоставляет нам генератор для создания скелета интеграционного теста.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate integration_test user_flows
<span class="go">      exists  test/integration/
      create  test/integration/user_flows_test.rb
</span></code></pre>
</div>
<p>Вот как выглядит свежесгенерированный интеграционный тест:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">UserFlowsTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="c1"># test "the truth" do</span>
  <span class="c1">#   assert true</span>
  <span class="c1"># end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Здесь тест наследуется от <code>ActionController::IntegrationTest</code>. Это делает доступным несколько дополнительных хелперов для использования в наших интеграционных тестах.</p><p>По умолчанию Rails пытается обработать исключения, возникшие во время тестов, и отобразить страницы ошибок в формате HTML. Это поведение можно контролировать с помощью настройки <a href="/configuring#config-action-dispatch-show-exceptions"><code>config.action_dispatch.show_exceptions</code></a>.</p><h4 id='helpery-dostupnye-dlya-integratsionnyh-testov' class='inside_page_header'><a href="#helpery-dostupnye-dlya-integratsionnyh-testov">7.1.</a> Хелперы, доступные для интеграционных тестов</h4><p>В дополнение к стандартным хелперам тестирования, наследование от <code>ActionDispatch::IntegrationTest</code> дает несколько дополнительных хелперов для написания интеграционных тестов. Давайте для краткости представим три категории хелперов.</p><p>Для работы с runner-ом интеграционных тестов, смотрите <a href="https://api.rubyonrails.org/classes/ActionDispatch/Integration/Runner.html"><code>ActionDispatch::Integration::Runner</code></a>.</p><p>Для выполнения запросов у нас есть <a href="https://api.rubyonrails.org/classes/ActionDispatch/Integration/RequestHelpers.html"><code>ActionDispatch::Integration::RequestHelpers</code></a>.</p><p>Для загрузки файлов нам поможет <a href="https://api.rubyonrails.org/classes/ActionDispatch/TestProcess/FixtureFile.html"><code>ActionDispatch::TestProcess::FixtureFile</code></a>.</p><p>Если хотим модифицировать сессию или состояние вашего интеграционного теста, нам поможет <a href="https://api.rubyonrails.org/classes/ActionDispatch/Integration/Session.html"><code>ActionDispatch::Integration::Session</code></a>.</p><h4 id='realizatsiya-integratsionnogo-testa' class='inside_page_header'><a href="#realizatsiya-integratsionnogo-testa">7.2.</a> Реализация интеграционного теста</h4><p>Давайте добавим интеграционный тест в наше приложение блога. Начнем с основного процесса создания новой статьи блога, чтобы убедиться, что все работает правильно.</p><p>Начнем с генерации скелета нашего интеграционного теста:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate integration_test blog_flow
</code></pre>
</div>
<p>Он должен создать файл для размещения теста, и в результате предыдущей команды мы должны увидеть:</p><div class="code_container">
  <pre><code class="highlight plaintext">      invoke  test_unit
      create    test/integration/blog_flow_test.rb
</code></pre>
</div>
<p>Теперь откроем этот файл и напишем наше первое утверждение:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">BlogFlowTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="nb">test</span> <span class="s2">"can see the welcome page"</span> <span class="k">do</span>
    <span class="n">get</span> <span class="s2">"/"</span>
    <span class="n">assert_select</span> <span class="s2">"h1"</span><span class="p">,</span> <span class="s2">"Welcome#index"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Мы рассмотрим <code>assert_select</code> для запрашивания результирующего HTML запроса в разделе &quot;Тестирование вью&quot; ниже. Он используется для тестирования отклика на наш запрос, убеждаясь в наличии ключевых элементов HTML и их содержимого.</p><p>При посещении корневого пути мы должны увидеть <code>welcome/index.html.erb</code>, отрендеренную для представления. Таким образом, это утверждение должно пройти.</p><h5 id='sozdanie-integratsii-statey' class='inside_page_header'><a href="#sozdanie-integratsii-statey">7.2.1.</a> Создание интеграции статей</h5><p>Как насчет тестирования возможности создавать новую статью в нашем блоге и просматривать полученную статью.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"can create an article"</span> <span class="k">do</span>
  <span class="n">get</span> <span class="s2">"/articles/new"</span>
  <span class="n">assert_response</span> <span class="ss">:success</span>

  <span class="n">post</span> <span class="s2">"/articles"</span><span class="p">,</span>
    <span class="ss">params: </span><span class="p">{</span> <span class="ss">article: </span><span class="p">{</span> <span class="ss">title: </span><span class="s2">"can create"</span><span class="p">,</span> <span class="ss">body: </span><span class="s2">"article successfully."</span> <span class="p">}</span> <span class="p">}</span>
  <span class="n">assert_response</span> <span class="ss">:redirect</span>
  <span class="n">follow_redirect!</span>
  <span class="n">assert_response</span> <span class="ss">:success</span>
  <span class="n">assert_select</span> <span class="s2">"p"</span><span class="p">,</span> <span class="s2">"Title:</span><span class="se">\n</span><span class="s2">  can create"</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Давайте разобьем этот тест на кусочки, чтобы понять его.</p><p>Мы начинаем с вызова экшна <code>:new</code> контроллера Articles. Этот запрос должен быть успешным.</p><p>После этого мы делаем запрос post к экшну <code>:create</code> нашего контроллера Articles:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">post</span> <span class="s2">"/articles"</span><span class="p">,</span>
  <span class="ss">params: </span><span class="p">{</span> <span class="ss">article: </span><span class="p">{</span> <span class="ss">title: </span><span class="s2">"can create"</span><span class="p">,</span> <span class="ss">body: </span><span class="s2">"article successfully."</span> <span class="p">}</span> <span class="p">}</span>
<span class="n">assert_response</span> <span class="ss">:redirect</span>
<span class="n">follow_redirect!</span>
</code></pre>
</div>
<p>Следующие две строчки — это обработка редиректа, который мы настроили при создании новой статьи.</p><div class="note"><p>Не забывайте вызвать <code>follow_redirect!</code> Если планируете сделать последовательные запросы после выполнения редиректа.</p></div><p>Наконец, мы убеждаемся, что наш отклик был успешным, и нашу статью можно прочесть на странице.</p><h5 id='idem-dalshe' class='inside_page_header'><a href="#idem-dalshe">7.2.2.</a> Идем дальше</h5><p>У нас получилось протестировать маленький процесс посещения нашего блога и создания новой статьи. Если мы хотим идти дальше, мы можем добавить тесты для комментирования, удаления статей и редактирования комментариев. Интеграционные тесты — это отличное место для экспериментов с различными сценариями использования приложения.</p><h3 id='funktsionalnye-testy-dlya-vashih-kontrollerov' class='inside_page_header'><a href="#funktsionalnye-testy-dlya-vashih-kontrollerov">8.</a> Функциональные тесты для ваших контроллеров</h3><p>В Rails тестирование различных экшнов контроллера — это форма написания функциональных тестов. Помните, что контроллеры обрабатывают входящие веб-запросы к вашему приложению и в конечном итоге откликаются отрендеренной вью. При написании функциональных тестов, вы тестируете, как ваши экшны обрабатывают запросы, ожидаемый результат или, в некоторых случаях, отклики вью HTML.</p><h4 id='chto-vklyuchat-v-funktsionalnye-testy' class='inside_page_header'><a href="#chto-vklyuchat-v-funktsionalnye-testy">8.1.</a> Что включать в функциональные тесты</h4><p>Следует протестировать такие вещи, как:</p><ul><li>был ли веб-запрос успешным?
</li><li>был ли пользователь перенаправлен на правильную страницу?
</li><li>был ли пользователь успешно аутентифицирован?
</li><li>было ли подходящее сообщение отражено для пользователя во вью
</li><li>была ли правильная информация отображена в отклике?
</li></ul><p>Самым простым способом увидеть функциональные тесты в действии является генерация контроллера с помощью генератора скаффолда:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate scaffold_controller article title:string body:text
<span class="c">...
</span><span class="go">create  app/controllers/articles_controller.rb
</span><span class="c">...
</span><span class="go">invoke  test_unit
create    test/controllers/articles_controller_test.rb
</span><span class="c">...
</span></code></pre>
</div>
<p>Это сгенерирует код контроллера и тестов для ресурса <code>Article</code>. Можете взглянуть на файл <code>articles_controller_test.rb</code> в директории <code>test/controllers</code>.</p><p>Если у вас уже есть контроллер и вы просто хотите сгенерировать код теста скаффолда для каждого из семи экшнов по умолчанию, можете использовать следующую команду:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate test_unit:scaffold article
<span class="c">...
</span><span class="go">invoke  test_unit
create    test/controllers/articles_controller_test.rb
</span><span class="c">...
</span></code></pre>
</div>
<p>Давайте взглянем на один такой тест, <code>test_should_get_index</code> из файла <code>articles_controller_test.rb</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># articles_controller_test.rb</span>
<span class="k">class</span> <span class="nc">ArticlesControllerTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="nb">test</span> <span class="s2">"should get index"</span> <span class="k">do</span>
    <span class="n">get</span> <span class="n">articles_url</span>
    <span class="n">assert_response</span> <span class="ss">:success</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>В тесте <code>test_should_get_index</code>, Rails имитирует запрос к экшну index, убеждается, что запрос был успешным, а также обеспечивает, что генерируется правильное тело отклика.</p><p>Метод <code>get</code> стартует веб-запрос и заполняет результаты в <code>@response</code>. Он может принимать до 6 аргументов:</p><ul><li>URI экшна контроллера, к которому обращаетесь. Он может быть в форме строки или хелпера маршрута (например, <code>articles_url</code>).
</li><li><code>params</code>: опция с хэшем параметров запроса для передачи в экшн (например, параметры строки запроса или переменные для модели article).
</li><li><code>headers</code>: для установки заголовков, которые будут переданы с запросом.
</li><li><code>env</code>: для настройки среды запроса по необходимости.
</li><li><code>xhr</code>: был ли запрос Ajax или нет. Можно установить true для пометки, что запрос является Ajax.
</li><li><code>as</code>: для кодировки запроса другим типом запроса.
</li></ul><p>Все эти аргументы с ключевым словом опциональны.</p><p>Пример: Вызов экшна <code>:show</code> для первого <code>Article</code>, передавая заголовок <code>HTTP_REFERER</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">get</span> <span class="n">article_url</span><span class="p">(</span><span class="no">Article</span><span class="p">.</span><span class="nf">first</span><span class="p">),</span> <span class="ss">headers: </span><span class="p">{</span> <span class="s2">"HTTP_REFERER"</span> <span class="o">=&gt;</span> <span class="s2">"http://example.com/home"</span> <span class="p">}</span>
</code></pre>
</div>
<p>Другой пример: Вызов экшна <code>:update</code> для последнего <code>Article</code>, передавая новый текст для <code>title</code> в <code>params</code>, как запрос Ajax:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">patch</span> <span class="n">article_url</span><span class="p">(</span><span class="no">Article</span><span class="p">.</span><span class="nf">last</span><span class="p">),</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">article: </span><span class="p">{</span> <span class="ss">title: </span><span class="s2">"updated"</span> <span class="p">}</span> <span class="p">},</span> <span class="ss">xhr: </span><span class="kp">true</span>
</code></pre>
</div>
<p>Еще один пример: Вызов экшна <code>:create</code> для создания новой статьи, передавая текст для <code>title</code> в <code>params</code>, как запрос JSON:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">post</span> <span class="n">articles_path</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">article: </span><span class="p">{</span> <span class="ss">title: </span><span class="s2">"Ahoy!"</span> <span class="p">}</span> <span class="p">},</span> <span class="ss">as: :json</span>
</code></pre>
</div>
<div class="note"><p>Если попытаетесь запустить тест <code>test_should_create_article</code> из <code>articles_controller_test.rb</code>, он провалится из-за недавно добавленной валидации на уровне модели, и это правильно.</p></div><p>Давайте модифицируем тест <code>test_should_create_article</code> в <code>articles_controller_test.rb</code> так, чтобы все наши тесты проходили:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"should create article"</span> <span class="k">do</span>
  <span class="n">assert_difference</span><span class="p">(</span><span class="s2">"Article.count"</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">post</span> <span class="n">articles_url</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">article: </span><span class="p">{</span> <span class="ss">body: </span><span class="s2">"Rails is awesome!"</span><span class="p">,</span> <span class="ss">title: </span><span class="s2">"Hello Rails"</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">assert_redirected_to</span> <span class="n">article_path</span><span class="p">(</span><span class="no">Article</span><span class="p">.</span><span class="nf">last</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Теперь можете попробовать запустить все тесты, и они должны пройти.</p><div class="note"><p>Если выполнены шаги в разделе про <a href="/getting-started#basic-authentication">базовую аутентификацию</a>, то необходимо добавить авторизацию в заголовок каждого запроса, чтобы все тесты проходили:</p></div><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">post</span> <span class="n">articles_url</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">article: </span><span class="p">{</span> <span class="ss">body: </span><span class="s2">"Rails is awesome!"</span><span class="p">,</span> <span class="ss">title: </span><span class="s2">"Hello Rails"</span> <span class="p">}</span> <span class="p">},</span> <span class="ss">headers: </span><span class="p">{</span> <span class="no">Authorization</span><span class="p">:</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">HttpAuthentication</span><span class="o">::</span><span class="no">Basic</span><span class="p">.</span><span class="nf">encode_credentials</span><span class="p">(</span><span class="s2">"dhh"</span><span class="p">,</span> <span class="s2">"secret"</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>
<p>По умолчанию Rails пытается обработать исключения, возникшие во время тестов, и отобразить страницы ошибок в формате HTML. Это поведение можно контролировать с помощью настройки <a href="/configuring#config-action-dispatch-show-exceptions"><code>config.action_dispatch.show_exceptions</code></a>.</p><h4 id='dostupnye-tipy-zaprosov-dlya-funktsionalnyh-testov' class='inside_page_header'><a href="#dostupnye-tipy-zaprosov-dlya-funktsionalnyh-testov">8.2.</a> Доступные типы запросов для функциональных тестов</h4><p>Если вы знакомы с протоколом HTTP, то знаете, что <code>get</code> это тип запроса. Имеется 6 типов запросов, поддерживаемых в функциональных тестах Rails:</p><ul><li><code>get</code>
</li><li><code>post</code>
</li><li><code>patch</code>
</li><li><code>put</code>
</li><li><code>head</code>
</li><li><code>delete</code>
</li></ul><p>У всех типов запросов есть эквивалентные методы, которые можно использовать. В обычном приложении C.R.U.D. вы чаще будете использовать <code>get</code>, <code>post</code>, <code>put</code> и <code>delete</code>.</p><div class="note"><p>Функциональные тесты не проверяют, поддерживается ли определенный тип запроса экшном, мы больше беспокоимся о результате. Для этого случая существуют тесты запросов, чтобы сделать ваши тесты более целенаправленными.</p></div><h4 id='testirovanie-zaprosov-xhr-ajax' class='inside_page_header'><a href="#testirovanie-zaprosov-xhr-ajax">8.3.</a> Тестирование запросов XHR (Ajax)</h4><p>Чтобы протестировать запросы Ajax, можно указать опцию <code>xhr: true</code> в методах <code>get</code>, <code>post</code>, <code>patch</code>, <code>put</code> и <code>delete</code>. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"ajax request"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="n">articles</span><span class="p">(</span><span class="ss">:one</span><span class="p">)</span>
  <span class="n">get</span> <span class="n">article_url</span><span class="p">(</span><span class="n">article</span><span class="p">),</span> <span class="ss">xhr: </span><span class="kp">true</span>

  <span class="n">assert_equal</span> <span class="s2">"hello world"</span><span class="p">,</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span>
  <span class="n">assert_equal</span> <span class="s2">"text/javascript"</span><span class="p">,</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">media_type</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='tri-hesha-apokalipsisa-the-three-hashes-of-the-apocalypse' class='inside_page_header'><a href="#tri-hesha-apokalipsisa-the-three-hashes-of-the-apocalypse">8.4.</a> Три Хэша Апокалипсиса (The Three Hashes of the Apocalypse)</h4><p>После того, как запрос был сделан и обработан, у вас будет 3 объекта Hash, готовых для использования:</p><ul><li><code>cookies</code> - Любые установленные куки
</li><li><code>flash</code> - Любые объекты, находящиеся во flash
</li><li><code>session</code> - Любый объекты, находящиеся в переменных сессии
</li></ul><p>Как и в случае с обычными объектами Hash, можете получать доступ к значениям, указав ключ в строке. Также можете указать его именем символа. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">flash</span><span class="p">[</span><span class="s2">"gordon"</span><span class="p">]</span>               <span class="c1"># или flash[:gordon]</span>
<span class="n">session</span><span class="p">[</span><span class="s2">"shmession"</span><span class="p">]</span>          <span class="c1"># или session[:shmession]</span>
<span class="n">cookies</span><span class="p">[</span><span class="s2">"are_good_for_u"</span><span class="p">]</span>     <span class="c1"># или cookies[:are_good_for_u]</span>
</code></pre>
</div>
<h4 id='dostupnye-peremennye-ekzemplyara' class='inside_page_header'><a href="#dostupnye-peremennye-ekzemplyara">8.5.</a> Доступные переменные экземпляра</h4><p><strong>После</strong> того как запрос был выполнен, В ваших функциональных тестах также доступны три переменные экземпляра:</p><ul><li><code>@controller</code> - Контроллер, обрабатывающий запрос
</li><li><code>@request</code> - Объект запроса
</li><li><code>@response</code> - Объект отклика
</li></ul><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ArticlesControllerTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="nb">test</span> <span class="s2">"should get index"</span> <span class="k">do</span>
    <span class="n">get</span> <span class="n">articles_url</span>

    <span class="n">assert_equal</span> <span class="s2">"index"</span><span class="p">,</span> <span class="vi">@controller</span><span class="p">.</span><span class="nf">action_name</span>
    <span class="n">assert_equal</span> <span class="s2">"application/x-www-form-urlencoded"</span><span class="p">,</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">media_type</span>
    <span class="n">assert_match</span> <span class="s2">"Articles"</span><span class="p">,</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='ustanovka-zagolovkov-i-peremennyh-cgi' class='inside_page_header'><a href="#ustanovka-zagolovkov-i-peremennyh-cgi">8.6.</a> Установка заголовков и переменных CGI</h4><p><a href="https://datatracker.ietf.org/doc/html/rfc2616#section-5.3">Заголовки HTTP</a> и <a href="https://datatracker.ietf.org/doc/html/rfc3875#section-4.1">переменные CGI</a> могут быть переданы как заголовки:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># устанавливаем заголовок HTTP</span>
<span class="n">get</span> <span class="n">articles_url</span><span class="p">,</span> <span class="ss">headers: </span><span class="p">{</span> <span class="s2">"Content-Type"</span><span class="p">:</span> <span class="s2">"text/plain"</span> <span class="p">}</span> <span class="c1"># имитировать запрос с пользовательским заголовком</span>

<span class="c1"># устанавливаем переменную CGI</span>
<span class="n">get</span> <span class="n">articles_url</span><span class="p">,</span> <span class="ss">headers: </span><span class="p">{</span> <span class="s2">"HTTP_REFERER"</span><span class="p">:</span> <span class="s2">"http://example.com/home"</span> <span class="p">}</span> <span class="c1"># имитировать запрос с пользовательской env переменной</span>
</code></pre>
</div>
<h4 id='testirovanie-soobscheniy-flash' class='inside_page_header'><a href="#testirovanie-soobscheniy-flash">8.7.</a> Тестирование сообщений <code>flash</code></h4><p>Как помните, одним из трех хэшей был <code>flash</code>.</p><p>Мы хотим добавить сообщение <code>flash</code> в наше приложение блога, всякий раз, когда кто-то успешно создает новый объект Article.</p><p>Давайте начнем с добавления этого утверждения в наш тест <code>test_should_create_article</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">test_should_create_article</span> <span class="k">do</span>
  <span class="n">assert_difference</span><span class="p">(</span><span class="s2">"Article.count"</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">post</span> <span class="n">articles_url</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">article: </span><span class="p">{</span> <span class="ss">title: </span><span class="s2">"Some title"</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">assert_redirected_to</span> <span class="n">article_path</span><span class="p">(</span><span class="no">Article</span><span class="p">.</span><span class="nf">last</span><span class="p">)</span>
  <span class="n">assert_equal</span> <span class="s2">"Article was successfully created."</span><span class="p">,</span> <span class="n">flash</span><span class="p">[</span><span class="ss">:notice</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Если запустить наш тест сейчас, мы увидим ошибку:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/controllers/articles_controller_test.rb <span class="nt">-n</span> test_should_create_article
<span class="go">Run options: -n test_should_create_article --seed 32266

</span><span class="gp">#</span><span class="w"> </span>Running:
<span class="go">
F

Finished in 0.114870s, 8.7055 runs/s, 34.8220 assertions/s.

  1) Failure:
</span><span class="gp">ArticlesControllerTest#</span>test_should_create_article <span class="o">[</span>/test/controllers/articles_controller_test.rb:16]:
<span class="go">--- expected
+++ actual
@@ -1 +1 @@
-"Article was successfully created."
+nil

1 runs, 4 assertions, 1 failures, 0 errors, 0 skips
</span></code></pre>
</div>
<p>Теперь давайте реализуем сообщение flash в нашем контроллере. Наш экшн <code>:create</code> теперь должен выглядеть так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">def</span> <span class="nf">create</span>
  <span class="vi">@article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">article_params</span><span class="p">)</span>

  <span class="k">if</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">save</span>
    <span class="n">flash</span><span class="p">[</span><span class="ss">:notice</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Article was successfully created."</span>
    <span class="n">redirect_to</span> <span class="vi">@article</span>
  <span class="k">else</span>
    <span class="n">render</span> <span class="s2">"new"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Если теперь запустить наши тесты, мы увидим, что он проходит:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails test test</span>/controllers/articles_controller_test.rb <span class="nt">-n</span> test_should_create_article
<span class="go">Run options: -n test_should_create_article --seed 18981

</span><span class="gp">#</span><span class="w"> </span>Running:
<span class="go">
</span><span class="c">.
</span><span class="go">
Finished in 0.081972s, 12.1993 runs/s, 48.7972 assertions/s.

1 runs, 4 assertions, 0 failures, 0 errors, 0 skips
</span></code></pre>
</div>
<h4 id='obobschenie-izlozhennogo' class='inside_page_header'><a href="#obobschenie-izlozhennogo">8.8.</a> Обобщение изложенного</h4><p>С этого момента в нашем контроллере Articles тестируются экшны <code>:index</code>, <code>:new</code> и <code>:create</code>. Но как насчет работы с существующими данными?</p><p>Давайте напишем тест для экшна <code>:show</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"should show article"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="n">articles</span><span class="p">(</span><span class="ss">:one</span><span class="p">)</span>
  <span class="n">get</span> <span class="n">article_url</span><span class="p">(</span><span class="n">article</span><span class="p">)</span>
  <span class="n">assert_response</span> <span class="ss">:success</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Как помните из нашего обсуждения фикстур, что метод <code>articles()</code> дает нам доступ к нашим фикстурам Articles.</p><p>Как насчет удаления существующего объекта Article?</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"should destroy article"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="n">articles</span><span class="p">(</span><span class="ss">:one</span><span class="p">)</span>
  <span class="n">assert_difference</span><span class="p">(</span><span class="s2">"Article.count"</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">delete</span> <span class="n">article_url</span><span class="p">(</span><span class="n">article</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">assert_redirected_to</span> <span class="n">articles_path</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Также можно добавить тест для обновления существующего объекта Article.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"should update article"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="n">articles</span><span class="p">(</span><span class="ss">:one</span><span class="p">)</span>

  <span class="n">patch</span> <span class="n">article_url</span><span class="p">(</span><span class="n">article</span><span class="p">),</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">article: </span><span class="p">{</span> <span class="ss">title: </span><span class="s2">"updated"</span> <span class="p">}</span> <span class="p">}</span>

  <span class="n">assert_redirected_to</span> <span class="n">article_path</span><span class="p">(</span><span class="n">article</span><span class="p">)</span>
  <span class="c1"># Перезагрузим связь, чтобы извлечь обновленные данные и убедиться, что заголовок обновлен.</span>
  <span class="n">article</span><span class="p">.</span><span class="nf">reload</span>
  <span class="n">assert_equal</span> <span class="s2">"updated"</span><span class="p">,</span> <span class="n">article</span><span class="p">.</span><span class="nf">title</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Отметьте, что у нас имеется некоторое дублирование в этих трех тестах, они все получают доступ к одним и тем же данным фикстуры Article. Можно убрать повторения с помощью методов <code>setup</code> и <code>teardown</code>, предоставленных <code>ActiveSupport::Callbacks</code>.</p><p>Наш тест должен быть похож на следующее. Не обращайте внимания, что остальные тесты были убраны для краткости.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ArticlesControllerTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="c1"># вызывается перед каждым отдельным тестом</span>
  <span class="n">setup</span> <span class="k">do</span>
    <span class="vi">@article</span> <span class="o">=</span> <span class="n">articles</span><span class="p">(</span><span class="ss">:one</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># вызывается после каждого отдельного теста</span>
  <span class="n">teardown</span> <span class="k">do</span>
    <span class="c1"># когда контроллер использует кэш, это может быть хорошей идеей сбросить его затем</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">cache</span><span class="p">.</span><span class="nf">clear</span>
  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"should show article"</span> <span class="k">do</span>
    <span class="c1"># повторно используем переменную экземпляра @article из setup</span>
    <span class="n">get</span> <span class="n">article_url</span><span class="p">(</span><span class="vi">@article</span><span class="p">)}</span>
    <span class="n">assert_response</span> <span class="ss">:success</span>
  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"should destroy article"</span> <span class="k">do</span>
    <span class="n">assert_difference</span><span class="p">(</span><span class="s2">"Article.count"</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">delete</span> <span class="n">article_url</span><span class="p">(</span><span class="vi">@article</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">assert_redirected_to</span> <span class="n">articles_path</span>
  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"should update article"</span> <span class="k">do</span>
    <span class="n">patch</span> <span class="n">article_url</span><span class="p">(</span><span class="vi">@article</span><span class="p">),</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">article: </span><span class="p">{</span> <span class="ss">title: </span><span class="s2">"updated"</span> <span class="p">}</span> <span class="p">}</span>

    <span class="n">assert_redirected_to</span> <span class="n">article_path</span><span class="p">(</span><span class="vi">@article</span><span class="p">)</span>
    <span class="c1"># Перезагрузим связь, чтобы извлечь обновленные данные и убедиться, что заголовок обновлен.</span>
    <span class="n">article</span><span class="p">.</span><span class="nf">reload</span>
    <span class="n">assert_equal</span> <span class="s2">"updated"</span><span class="p">,</span> <span class="n">article</span><span class="p">.</span><span class="nf">title</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Подобно другим колбэкам Rails, методы <code>setup</code> и <code>teardown</code> можно использовать, передав блок, lambda или имя метода символом для вызова.</p><h4 id='testovye-helpery' class='inside_page_header'><a href="#testovye-helpery">8.9.</a> Тестовые хелперы</h4><p>Чтобы избежать дублирования кода, можно добавлять собственные тестовые хелперы. Хорошим примером может быть хелпер входа в систему:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># test/test_helper.rb</span>

<span class="k">module</span> <span class="nn">SignInHelper</span>
  <span class="k">def</span> <span class="nf">sign_in_as</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">post</span> <span class="n">sign_in_url</span><span class="p">(</span><span class="ss">email: </span><span class="n">user</span><span class="p">.</span><span class="nf">email</span><span class="p">,</span> <span class="ss">password: </span><span class="n">user</span><span class="p">.</span><span class="nf">password</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">ActionDispatch::IntegrationTest</span>
  <span class="kp">include</span> <span class="no">SignInHelper</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ProfileControllerTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="nb">test</span> <span class="s2">"should show profile"</span> <span class="k">do</span>
    <span class="c1"># теперь хелпер можно повторно использовать в любом тестовом случае контроллера</span>
    <span class="n">sign_in_as</span> <span class="n">users</span><span class="p">(</span><span class="ss">:david</span><span class="p">)</span>

    <span class="n">get</span> <span class="n">profile_url</span>
    <span class="n">assert_response</span> <span class="ss">:success</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h5 id='ispolzovanie-otdelnyh-faylov' class='inside_page_header'><a href="#ispolzovanie-otdelnyh-faylov">8.9.1.</a> Использование отдельных файлов</h5><p>Если ваши хелперы загромоздили <code>test_helper.rb</code>, их можно извлечь в отдельные файлы. Одним из хороших мест их хранения является <code>lib/test</code> или <code>test/test_helpers</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># test/test_helpers/multiple_assertions.rb</span>
<span class="k">module</span> <span class="nn">MultipleAssertions</span>
  <span class="k">def</span> <span class="nf">assert_multiple_of_forty_two</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
    <span class="n">assert</span> <span class="p">(</span><span class="n">number</span> <span class="o">%</span> <span class="mi">42</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">"expected </span><span class="si">#{</span><span class="n">number</span><span class="si">}</span><span class="s2"> to be a multiple of 42"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Затем эти хелперы могут быть явно затребованы или включены по необходимости</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>
<span class="nb">require</span> <span class="s2">"test_helpers/multiple_assertions"</span>

<span class="k">class</span> <span class="nc">NumberTest</span> <span class="o">&lt;</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="kp">include</span> <span class="no">MultipleAssertions</span>

  <span class="nb">test</span> <span class="s2">"420 is a multiple of forty two"</span> <span class="k">do</span>
    <span class="n">assert_multiple_of_forty_two</span> <span class="mi">420</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>или их можно продолжить включать непосредственно в релевантные родительские классы</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># test/test_helper.rb</span>
<span class="nb">require</span> <span class="s2">"test_helpers/sign_in_helper"</span>

<span class="k">class</span> <span class="nc">ActionDispatch::IntegrationTest</span>
  <span class="kp">include</span> <span class="no">SignInHelper</span>
<span class="k">end</span>
</code></pre>
</div>
<h5 id='neterpelivaya-zagruzka-helperov' class='inside_page_header'><a href="#neterpelivaya-zagruzka-helperov">8.9.2.</a> Нетерпеливая загрузка хелперов</h5><p>Может быть удобным нетерпеливо загрузить хелперы в <code>test_helper.rb</code>, таким образом файлы тестов неявно получат к ним доступ. Это можно выполнить с помощью подстановки, следующим образом</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># test/test_helper.rb</span>
<span class="no">Dir</span><span class="p">[</span><span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"test"</span><span class="p">,</span> <span class="s2">"test_helpers"</span><span class="p">,</span> <span class="s2">"**"</span><span class="p">,</span> <span class="s2">"*.rb"</span><span class="p">)].</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span> <span class="nb">require</span> <span class="n">file</span> <span class="p">}</span>
</code></pre>
</div>
<p>В этом есть недостаток в виде увеличения времени загрузки, в противоположность ручного включения только необходимых файлов в отдельные тесты.</p><h3 id='testirovanie-marshrutov' class='inside_page_header'><a href="#testirovanie-marshrutov">9.</a> Тестирование маршрутов</h3><p>Как и все другое в вашем приложении Rails, ваши маршруты можно тестировать. Тесты маршрутов находятся в <code>test/controllers/</code> или являются частью тестов контроллера.</p><div class="note"><p>Если в вашем приложении сложные маршруты, Rails предоставляет ряд полезных хелперов для их тестирования.</p></div><p>Подробности о тестировании маршрутов доступны в Rails, обратитесь к документации API для <a href="https://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html"><code>ActionDispatch::Assertions::RoutingAssertions</code></a>.</p><h3 id='testing-views' class='inside_page_header'><a href="#testing-views">10.</a> Тестирование вью</h3><p>Тестирование отклика на ваш запрос с помощью подтверждения наличия ключевых элементов HTML и их содержимого, это хороший способ протестировать вью вашего приложения. Как и тесты маршрутов, тесты вью находятся в <code>test/controllers/</code> или являются частью тестов контроллера. Метод <code>assert_select</code> позволяет осуществить выборку элементов HTML отклика с помощью простого, но мощного синтаксиса.</p><p>Имеется две формы <code>assert_select</code>:</p><p><code>assert_select(selector, [equality], [message])</code> обеспечивает, что условие equality выполняется для выбранных через selector элементов, selector может быть выражением селектора CSS (String) или выражением с заменяемыми значениями.</p><p><code>assert_select(element, selector, [equality], [message])</code> обеспечивает, что условие equality выполняется для всех элементов, выбранных через selector начиная с <em>element</em> (экземпляра <code>Nokogiri::XML::Node</code> или <code>Nokogiri::XML::NodeSet</code>) и его потомков.</p><p>Например, можно проверить содержимое в элементе <code>title</code> отклика с помощью:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">assert_select</span> <span class="s2">"title"</span><span class="p">,</span> <span class="s2">"Welcome to Rails Testing Guide"</span>
</code></pre>
</div>
<p>Также можно использовать вложенные блоки <code>assert_select</code> для углубленного исследования.</p><p>В следующем примере, внутренний <code>assert_select</code> для <code>li.menu_item</code> запускается для полной коллекции элементов, выбранных во внешнем блоке:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">assert_select</span> <span class="s2">"ul.navigation"</span> <span class="k">do</span>
  <span class="n">assert_select</span> <span class="s2">"li.menu_item"</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Коллекция выбранных элементов может быть перебрана, таким образом <code>assert_select</code> может быть вызван отдельно для каждого элемента.</p><p>Например, если отклик содержит два упорядоченных списка, каждый из четырех элементов, тогда оба следующих теста пройдут.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">assert_select</span> <span class="s2">"ol"</span> <span class="k">do</span> <span class="o">|</span><span class="n">elements</span><span class="o">|</span>
  <span class="n">elements</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="n">assert_select</span> <span class="n">element</span><span class="p">,</span> <span class="s2">"li"</span><span class="p">,</span> <span class="mi">4</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">assert_select</span> <span class="s2">"ol"</span> <span class="k">do</span>
  <span class="n">assert_select</span> <span class="s2">"li"</span><span class="p">,</span> <span class="mi">8</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Это утверждение достаточно мощное. Для более продвинутого использования обратитесь к его <a href="https://github.com/rails/rails-dom-testing/blob/main/lib/rails/dom/testing/assertions/selector_assertions.rb">документации</a>.</p><h4 id='additional-view-based-assertions' class='inside_page_header'><a href="#additional-view-based-assertions">10.1.</a> Дополнительные утверждения, основанные на вью</h4><p>В тестировании вью в основном используется такие утверждения:</p><table class='table table-striped'><tr>
<th>Утверждение</th>
<th>Назначение</th>
</tr>
<tr>
<td><code>assert_select_email</code></td>
<td>Позволяет сделать утверждение относительно тела e-mail.</td>
</tr>
<tr>
<td><code>assert_select_encoded</code></td>
<td>Позволяет сделать утверждение относительно закодированного HTML. Он делает это декодируя содержимое каждого элемента и затем вызывая блок со всеми декодированными элементами.</td>
</tr>
<tr>
<td><code>css_select(selector)</code> или <code>css_select(element, selector)</code></td>
<td>Возвращают массив всех элементов, выбранных через <em>selector</em>. Во втором варианте сначала проверяется соответствие базовому <em>element</em>, а затем пытается применить соответствие выражению <em>selector</em> на каждом из его детей. Если нет соответствий, оба варианта возвращают пустой массив.</td>
</tr>
</table><p>Вот пример использования <code>assert_select_email</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">assert_select_email</span> <span class="k">do</span>
  <span class="n">assert_select</span> <span class="s2">"small"</span><span class="p">,</span> <span class="s2">"Please click the 'Unsubscribe' link if you want to opt-out."</span>
<span class="k">end</span>
</code></pre>
</div>
<h3 id='testirovanie-partialov-vyu' class='inside_page_header'><a href="#testirovanie-partialov-vyu">11.</a> Тестирование партиалов вью</h3><p>Частичные шаблоны, также часто называемые просто партиалами, представляют собой еще один способ разделить процесс рендеринга на более управляемые блоки. С помощью партиалов вы можете извлекать фрагменты кода из ваших шаблонов в отдельные файлы и повторно использовать их в любых других шаблонах.</p><p>Тестирование вью позволяет проверить, что партиалы отображают содержимое так, как вы ожидаете. Тесты партиалов вью располагаются в <code>test/views/</code> и наследуются от <code>ActionView::TestCase</code>.</p><p>Для рендеринга партиала используйте метод <code>render</code> так же, как и в обычном шаблоне. Содержимое доступно через локальный для теста метод <code>#rendered</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ArticlePartialTest</span> <span class="o">&lt;</span> <span class="no">ActionView</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"renders a link to itself"</span> <span class="k">do</span>
    <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">create!</span> <span class="ss">title: </span><span class="s2">"Hello, world"</span>

    <span class="n">render</span> <span class="s2">"articles/article"</span><span class="p">,</span> <span class="ss">article: </span><span class="n">article</span>

    <span class="n">assert_includes</span> <span class="n">rendered</span><span class="p">,</span> <span class="n">article</span><span class="p">.</span><span class="nf">title</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>В тестах, унаследованных от <code>ActionView::TestCase</code> также есть доступ к <a href="#testing-views"><code>assert_select</code></a> и <a href="#additional-view-based-assertions">другим дополнительным утверждениям, основанным на вью</a>, предоставленными <a href="https://github.com/rails/rails-dom-testing">rails-dom-testing</a>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"renders a link to itself"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">create!</span> <span class="ss">title: </span><span class="s2">"Hello, world"</span>

  <span class="n">render</span> <span class="s2">"articles/article"</span><span class="p">,</span> <span class="ss">article: </span><span class="n">article</span>

  <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">article_url</span><span class="p">(</span><span class="n">article</span><span class="p">),</span> <span class="ss">text: </span><span class="n">article</span><span class="p">.</span><span class="nf">title</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Для интеграции с <a href="https://github.com/rails/rails-dom-testing">rails-dom-testing</a>, тесты, наследующиеся от <code>ActionView::TestCase</code> , объявляют метод <code>document_root_element</code>, который возвращает отрисованное содержимое в виде экземпляра <a href="https://www.rubydoc.info/github/sparklemotion/nokogiri/Nokogiri/XML/Node">Nokogiri::XML::Node</a>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"renders a link to itself"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">create!</span> <span class="ss">title: </span><span class="s2">"Hello, world"</span>

  <span class="n">render</span> <span class="s2">"articles/article"</span><span class="p">,</span> <span class="ss">article: </span><span class="n">article</span>
  <span class="n">anchor</span> <span class="o">=</span> <span class="n">document_root_element</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>

  <span class="n">assert_equal</span> <span class="n">article</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">anchor</span><span class="p">.</span><span class="nf">text</span>
  <span class="n">assert_equal</span> <span class="n">article_url</span><span class="p">(</span><span class="n">article</span><span class="p">),</span> <span class="n">anchor</span><span class="p">[</span><span class="s2">"href"</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Если ваше приложение использует Ruby &gt;= 3.0, зависит от <a href="https://github.com/sparklemotion/nokogiri/releases/tag/v1.14.0">Nokogiri &gt;= 1.14.0</a>, а также зависит от <a href="https://github.com/minitest/minitest/blob/v5.18.0/History.rdoc#5180--2023-03-04-">Minitest &gt;= &gt;5.18.0</a>, <code>document_root_element</code> поддерживает <a href="https://docs.ruby-lang.org/en/master/syntax/pattern_matching_rdoc.html">сопоставление с образцом в Ruby</a>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"renders a link to itself"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">create!</span> <span class="ss">title: </span><span class="s2">"Hello, world"</span>

  <span class="n">render</span> <span class="s2">"articles/article"</span><span class="p">,</span> <span class="ss">article: </span><span class="n">article</span>
  <span class="n">anchor</span> <span class="o">=</span> <span class="n">document_root_element</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
  <span class="n">url</span> <span class="o">=</span> <span class="n">article_url</span><span class="p">(</span><span class="n">article</span><span class="p">)</span>

  <span class="n">assert_pattern</span> <span class="k">do</span>
    <span class="n">anchor</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">content: </span><span class="s2">"Hello, world"</span><span class="p">,</span> <span class="ss">attributes: </span><span class="p">[{</span> <span class="ss">name: </span><span class="s2">"href"</span><span class="p">,</span> <span class="ss">value: </span><span class="n">url</span> <span class="p">}]</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Если вы хотите использовать те же <a href="https://rubydoc.info/github/teamcapybara/capybara/master/Capybara/Minitest/Assertions">утверждения на основе Capybara</a>, которые применяются в ваших <a href="#functional-and-system-testing">функциональных и системных тестах</a>, вы можете определить базовый класс, наследуемый от <code>ActionView::TestCase</code>, и преобразовать метод <code>document_root_element</code> в метод <code>page</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># test/view_partial_test_case.rb</span>

<span class="nb">require</span> <span class="s2">"test_helper"</span>
<span class="nb">require</span> <span class="s2">"capybara/minitest"</span>

<span class="k">class</span> <span class="nc">ViewPartialTestCase</span> <span class="o">&lt;</span> <span class="no">ActionView</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="kp">include</span> <span class="no">Capybara</span><span class="o">::</span><span class="no">Minitest</span><span class="o">::</span><span class="no">Assertions</span>

  <span class="k">def</span> <span class="nf">page</span>
    <span class="no">Capybara</span><span class="p">.</span><span class="nf">string</span><span class="p">(</span><span class="n">rendered</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># test/views/article_partial_test.rb</span>

<span class="nb">require</span> <span class="s2">"view_partial_test_case"</span>

<span class="k">class</span> <span class="nc">ArticlePartialTest</span> <span class="o">&lt;</span> <span class="no">ViewPartialTestCase</span>
  <span class="nb">test</span> <span class="s2">"renders a link to itself"</span> <span class="k">do</span>
    <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">create!</span> <span class="ss">title: </span><span class="s2">"Hello, world"</span>

    <span class="n">render</span> <span class="s2">"articles/article"</span><span class="p">,</span> <span class="ss">article: </span><span class="n">article</span>

    <span class="n">assert_link</span> <span class="n">article</span><span class="p">.</span><span class="nf">title</span><span class="p">,</span> <span class="ss">href: </span><span class="n">article_url</span><span class="p">(</span><span class="n">article</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Начиная с версии Action View 7.1, вспомогательный метод <code>#rendered</code> возвращает объект, способный анализировать отрендеренное содержимое партиала.</p><p>Чтобы преобразовать содержимое в <code>String</code>, возвращаемое методом <code>#rendered</code>, в объект, необходимо определить парсер с помощью вызова <code>.register_parser</code>. Вызов <code>.register_parser :rss</code> определяет вспомогательный метод <code>#rendered.rss</code>. Например, чтобы разобрать отрендеренный <a href="https://www.rssboard.org/rss-specification">RSS-контент</a> в объект с помощью <code>#rendered.rss</code>, зарегистрируйте вызов <code>RSS::Parser.parse</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">register_parser</span> <span class="ss">:rss</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="n">rendered</span> <span class="p">{</span> <span class="no">RSS</span><span class="o">::</span><span class="no">Parser</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">rendered</span><span class="p">)</span> <span class="p">}</span>

<span class="nb">test</span> <span class="s2">"renders RSS"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">title: </span><span class="s2">"Hello, world"</span><span class="p">)</span>

  <span class="n">render</span> <span class="ss">formats: :rss</span><span class="p">,</span> <span class="ss">partial: </span><span class="n">article</span>

  <span class="n">assert_equal</span> <span class="s2">"Hello, world"</span><span class="p">,</span> <span class="n">rendered</span><span class="p">.</span><span class="nf">rss</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">last</span><span class="p">.</span><span class="nf">title</span>
<span class="k">end</span>
</code></pre>
</div>
<p>По умолчанию <code>ActionView::TestCase</code> определяет парсер для:</p><ul><li><code>:html</code> - возвращает экземпляр <a href="https://nokogiri.org/rdoc/Nokogiri/XML/Node.html">Nokogiri::XML::Node</a>
</li><li><code>:json</code> - возвращает экземпляр <a href="https://api.rubyonrails.org/classes/ActiveSupport/HashWithIndifferentAccess.html">ActiveSupport::HashWithIndifferentAccess</a>
</li></ul><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"renders HTML"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">title: </span><span class="s2">"Hello, world"</span><span class="p">)</span>

  <span class="n">render</span> <span class="ss">partial: </span><span class="s2">"articles/article"</span><span class="p">,</span> <span class="ss">locals: </span><span class="p">{</span> <span class="ss">article: </span><span class="n">article</span> <span class="p">}</span>

  <span class="n">assert_pattern</span> <span class="p">{</span> <span class="n">rendered</span><span class="p">.</span><span class="nf">html</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="s2">"main h1"</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">content: </span><span class="s2">"Hello, world"</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>

<span class="nb">test</span> <span class="s2">"renders JSON"</span> <span class="k">do</span>
  <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">title: </span><span class="s2">"Hello, world"</span><span class="p">)</span>

  <span class="n">render</span> <span class="ss">formats: :json</span><span class="p">,</span> <span class="ss">partial: </span><span class="s2">"articles/article"</span><span class="p">,</span> <span class="ss">locals: </span><span class="p">{</span> <span class="ss">article: </span><span class="n">article</span> <span class="p">}</span>

  <span class="n">assert_pattern</span> <span class="p">{</span> <span class="n">rendered</span><span class="p">.</span><span class="nf">json</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">title: </span><span class="s2">"Hello, world"</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<h3 id='testirovanie-helperov' class='inside_page_header'><a href="#testirovanie-helperov">12.</a> Тестирование хелперов</h3><p>Хелпер — это всего лишь простой модуль, в котором можно определять методы, которые будут доступны во вью.</p><p>Чтобы протестировать хелперы, нужно проверить, что результат метода хелпера соответствует тому, что вы ожидаете. Тесты, относящиеся к хелперам, расположены в директории <code>test/helpers</code>.</p><p>Допустим, у нас имеется следующий хелпер:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">UsersHelper</span>
  <span class="k">def</span> <span class="nf">link_to_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">link_to</span> <span class="s2">"</span><span class="si">#{</span><span class="n">user</span><span class="p">.</span><span class="nf">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">user</span><span class="p">.</span><span class="nf">last_name</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">user</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Мы можем протестировать результат этого метода хелпера следующим образом:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">UsersHelperTest</span> <span class="o">&lt;</span> <span class="no">ActionView</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"should return the user's full name"</span> <span class="k">do</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">users</span><span class="p">(</span><span class="ss">:david</span><span class="p">)</span>

    <span class="n">assert_dom_equal</span> <span class="sx">%{&lt;a href="/user/#{user.id}"&gt;David Heinemeier Hansson&lt;/a&gt;}</span><span class="p">,</span> <span class="n">link_to_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Более того, так как этот класс теста расширяет <code>ActionView::TestCase</code>, у вас есть доступ к методам хелпера Rails, таким как <code>link_to</code> или <code>pluralize</code>.</p><h3 id='testing-your-mailers' class='inside_page_header'><a href="#testing-your-mailers">13.</a> Тестирование почтовых рассыльщиков</h3><p>Тестирование классов рассыльщика требует несколько специфичных инструментов для тщательного выполнения задания.</p><h4 id='derzhim-otpravku-pochty-pod-kontrolem' class='inside_page_header'><a href="#derzhim-otpravku-pochty-pod-kontrolem">13.1.</a> Держим отправку почты под контролем</h4><p>Ваши классы рассыльщика - как и любая другая часть вашего приложения на Rails - должны быть протестированы, что они работают так, как ожидается.</p><p>Тестировать классы рассыльщика нужно, чтобы быть уверенным в том, что:</p><ul><li>электронные письма обрабатываются (создаются и отсылаются)
</li><li>содержимое письма правильное (тема, получатель, тело и т.д.)
</li><li>правильные письма отправляются в нужный момент
</li></ul><h5 id='so-vseh-storon' class='inside_page_header'><a href="#so-vseh-storon">13.1.1.</a> Со всех сторон</h5><p>Есть два момента в тестировании рассыльщика, юнит-тесты и функциональные тесты. В юнит-тестах обособленно запускается рассыльщик с жестко заданными входящими значениями, и сравнивается результат с известным значением (фикстуры). В функциональных тестах не нужно тестировать мелкие детали, вместо этого мы тестируем, что наши контроллеры и модели правильно используют рассыльщик. Мы тестируем, чтобы подтвердить, что правильный email был послан в правильный момент.</p><h4 id='yunit-testirovanie' class='inside_page_header'><a href="#yunit-testirovanie">13.2.</a> Юнит-тестирование</h4><p>Для того, чтобы протестировать, что ваш рассыльщик работает как надо, можете использовать юнит-тесты для сравнения фактических результатов рассыльщика с предварительно написанными примерами того, что должно быть получено.</p><h5 id='revansh-fikstur' class='inside_page_header'><a href="#revansh-fikstur">13.2.1.</a> Реванш фикстур</h5><p>Для целей юнит-тестирования рассыльщика фикстуры используются для предоставления примера, как результат <em>должен</em> выглядеть. Так как это примеры электронных писем, а не данные Active Record, как в других фикстурах, они должны храниться в своей поддиректории отдельно от других фикстур. Имя директории в <code>test/fixtures</code> полностью соответствует имени рассыльщика. Таким образом, для рассыльщика с именем <code>UserMailer</code> фикстуры должны располагаться в директории <code>test/fixtures/user_mailer</code>.</p><p>Если вы генерируете свой рассыльщик, то генератор не создает незавершенные фикстуры для экшнов рассыльщиков. Вам следует создать эти файлы самостоятельно, как описано выше.</p><h5 id='bazovyy-testovyy-sluchay' class='inside_page_header'><a href="#bazovyy-testovyy-sluchay">13.2.2.</a> Базовый тестовый случай</h5><p>Вот юнит-тест для тестирования рассыльщика с именем <code>UserMailer</code>, экшн <code>invite</code> которого используется для рассылки приглашений друзьям. Это адаптированная версия исходного теста, созданного генератором для экшна <code>invite</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">UserMailerTest</span> <span class="o">&lt;</span> <span class="no">ActionMailer</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"invite"</span> <span class="k">do</span>
    <span class="c1"># Создайте email и сохраните его для будущих утверждений</span>
    <span class="n">email</span> <span class="o">=</span> <span class="no">UserMailer</span><span class="p">.</span><span class="nf">create_invite</span><span class="p">(</span><span class="s2">"me@example.com"</span><span class="p">,</span>
                                     <span class="s2">"friend@example.com"</span><span class="p">,</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">)</span>

    <span class="c1"># Отправить письмо, затем проверить, что оно попало в очередь</span>
    <span class="n">assert_emails</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">email</span><span class="p">.</span><span class="nf">deliver_now</span>
    <span class="k">end</span>

    <span class="c1"># Проверить тело отправленного письма, что оно содержит то, что мы ожидаем</span>
    <span class="n">assert_equal</span> <span class="p">[</span><span class="s2">"me@example.com"</span><span class="p">],</span> <span class="n">email</span><span class="p">.</span><span class="nf">from</span>
    <span class="n">assert_equal</span> <span class="p">[</span><span class="s2">"friend@example.com"</span><span class="p">],</span> <span class="n">email</span><span class="p">.</span><span class="nf">to</span>
    <span class="n">assert_equal</span> <span class="s2">"You have been invited by me@example.com"</span><span class="p">,</span> <span class="n">email</span><span class="p">.</span><span class="nf">subject</span>
    <span class="n">assert_equal</span> <span class="n">read_fixture</span><span class="p">(</span><span class="s2">"invite"</span><span class="p">).</span><span class="nf">join</span><span class="p">,</span> <span class="n">email</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>В тесте мы создаем письмо и сохраняем возвращенный объект в переменной <code>email</code>. Затем мы убеждаемся, что оно было послано (первое утверждение), затем, вот второй порции утверждений, мы убеждаемся, что <code>email</code> содержит в точности то, что мы ожидаем. Хелпер <code>read_fixture</code> используется для считывания содержимого из этого файла.</p><div class="note"><p><code>email.body.to_s</code> существует только когда присутствует одна часть (HTML или text). Если рассыльщик представляет обе, можно протестировать фикстуру для определенной части с помощью <code>email.text_part.body.to_s</code> или <code>email.html_part.body.to_s</code>.</p></div><p>Вот содержимое фикстуры <code>invite</code>:</p><div class="code_container">
  <pre><code class="highlight plaintext">Hi friend@example.com,

You have been invited.

Cheers!
</code></pre>
</div>
<p>Сейчас самое время понять немного больше о написании тестов для ваших рассыльщиков. Строчка <code>ActionMailer::Base.delivery_method = :test</code> в <code>config/environments/test.rb</code> устанавливает метод доставки в тестовом режиме, таким образом, письмо не будет фактически доставлено (полезно во избежание спама для ваших пользователей во время тестирования), но вместо этого оно будет присоединено к массиву (<code>ActionMailer::Base.deliveries</code>).</p><div class="note"><p>Массив <code>ActionMailer::Base.deliveries</code> перезагружается автоматически только в тестах <code>ActionMailer::TestCase</code> и <code>ActionDispatch::IntegrationTest</code>. Если необходим чистый массив вне этих тестовых случаев, его можно перезагрузить вручную с помощью <code>ActionMailer::Base.deliveries.clear</code></p></div><h5 id='testing-enqueued-emails' class='inside_page_header'><a href="#testing-enqueued-emails">13.2.3.</a> Тестирование электронных писем в очереди</h5><p>Можно использовать утверждение <code>assert_enqueued_email_with</code>, чтобы убедиться, что письмо было поставлено в очередь со всеми ожидаемыми аргументами метода рассыльщика и/или параметризованными параметрами рассыльщика. Это позволяет сопоставить любое письмо, помещенное в очередь с помощью метода <code>deliver_later</code>.</p><p>Как и в качестве базового тестового случая, мы создаем email и сохраняем возвращаемый объект в переменной <code>email</code>. Следующие примеры включают вариации передачи аргументов и/или параметров.</p><p>Этот пример убеждается, что email был помещен в очередь с правильными аргументами:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">UserMailerTest</span> <span class="o">&lt;</span> <span class="no">ActionMailer</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"invite"</span> <span class="k">do</span>
    <span class="c1"># Создаем email и сохраняем его для будущих утверждений</span>
    <span class="n">email</span> <span class="o">=</span> <span class="no">UserMailer</span><span class="p">.</span><span class="nf">create_invite</span><span class="p">(</span><span class="s2">"me@example.com"</span><span class="p">,</span> <span class="s2">"friend@example.com"</span><span class="p">)</span>

    <span class="c1"># Тестируем, что email помещен в очередь с правильными аргументами</span>
    <span class="n">assert_enqueued_email_with</span> <span class="no">UserMailer</span><span class="p">,</span> <span class="ss">:create_invite</span><span class="p">,</span> <span class="ss">args: </span><span class="p">[</span><span class="s2">"me@example.com"</span><span class="p">,</span> <span class="s2">"friend@example.com"</span><span class="p">]</span> <span class="k">do</span>
      <span class="n">email</span><span class="p">.</span><span class="nf">deliver_later</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Этот пример убеждается, что рассыльщик был помещен в очередь с правильно названными аргументами рассыльщика, передавая хэш аргументов как <code>args</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">UserMailerTest</span> <span class="o">&lt;</span> <span class="no">ActionMailer</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"invite"</span> <span class="k">do</span>
    <span class="c1"># Создаем email и сохраняем его для будущих утверждений</span>
    <span class="n">email</span> <span class="o">=</span> <span class="no">UserMailer</span><span class="p">.</span><span class="nf">create_invite</span><span class="p">(</span><span class="ss">from: </span><span class="s2">"me@example.com"</span><span class="p">,</span> <span class="ss">to: </span><span class="s2">"friend@example.com"</span><span class="p">)</span>

    <span class="c1"># Тестируем, что email помещен в очередь с правильными аргументами</span>
    <span class="n">assert_enqueued_email_with</span> <span class="no">UserMailer</span><span class="p">,</span> <span class="ss">:create_invite</span><span class="p">,</span> <span class="ss">args: </span><span class="p">[{</span> <span class="ss">from: </span><span class="s2">"me@example.com"</span><span class="p">,</span>
                                                                    <span class="ss">to: </span><span class="s2">"friend@example.com"</span> <span class="p">}]</span> <span class="k">do</span>
      <span class="n">email</span><span class="p">.</span><span class="nf">deliver_later</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Этот пример убеждается, что параметризованный рассыльщик был помещен в очередь с правильно названными параметрами и аргументами. Параметры рассыльщика передаются как <code>params</code>, а аргументы методы рассыльщика как <code>args</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">UserMailerTest</span> <span class="o">&lt;</span> <span class="no">ActionMailer</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"invite"</span> <span class="k">do</span>
    <span class="c1"># Создаем email и сохраняем его для будущих утверждений</span>
    <span class="n">email</span> <span class="o">=</span> <span class="no">UserMailer</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="ss">all: </span><span class="s2">"good"</span><span class="p">).</span><span class="nf">create_invite</span><span class="p">(</span><span class="s2">"me@example.com"</span><span class="p">,</span> <span class="s2">"friend@example.com"</span><span class="p">)</span>

    <span class="c1"># Тестируем, что email помещен в очередь с правильными параметрами и аргументами рассыльщика</span>
    <span class="n">assert_enqueued_email_with</span> <span class="no">UserMailer</span><span class="p">,</span> <span class="ss">:create_invite</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">all: </span><span class="s2">"good"</span> <span class="p">},</span>
                                                           <span class="ss">args: </span><span class="p">[</span><span class="s2">"me@example.com"</span><span class="p">,</span> <span class="s2">"friend@example.com"</span><span class="p">]</span> <span class="k">do</span>
      <span class="n">email</span><span class="p">.</span><span class="nf">deliver_later</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Этот пример показывает альтернативный способ тестирования, что параметризованный рассыльщик был помещен в очередь с правильными параметрами:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">UserMailerTest</span> <span class="o">&lt;</span> <span class="no">ActionMailer</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"invite"</span> <span class="k">do</span>
    <span class="c1"># Создаем email и сохраняем его для будущих утверждений</span>
    <span class="n">email</span> <span class="o">=</span> <span class="no">UserMailer</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="ss">to: </span><span class="s2">"friend@example.com"</span><span class="p">).</span><span class="nf">create_invite</span>

    <span class="c1"># Тестируем, что email помещен в очередь с правильными параметрами рассыльщика</span>
    <span class="n">assert_enqueued_email_with</span> <span class="no">UserMailer</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="ss">to: </span><span class="s2">"friend@example.com"</span><span class="p">),</span> <span class="ss">:create_invite</span> <span class="k">do</span>
      <span class="n">email</span><span class="p">.</span><span class="nf">deliver_later</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='functional-and-system-testing' class='inside_page_header'><a href="#functional-and-system-testing">13.3.</a> Функциональное и системное тестирование</h4><p>Юнит тестирование позволяет протестировать атрибуты письмо, в то время как функциональное и системное тестирование позволяет протестировать, инициируют ли пользовательские взаимодействия доставку письма подходящим образом. Например, можно проверить, что операция по приглашению друзей надлежаще рассылает письма:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Интеграционный тест</span>
<span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">UsersControllerTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="nb">test</span> <span class="s2">"invite friend"</span> <span class="k">do</span>
    <span class="c1"># Убеждаемся в различии в ActionMailer::Base.deliveries</span>
    <span class="n">assert_emails</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">post</span> <span class="n">invite_friend_url</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">email: </span><span class="s2">"friend@example.com"</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Системный тест</span>
<span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">UsersTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">SystemTestCase</span>
  <span class="n">driven_by</span> <span class="ss">:selenium</span><span class="p">,</span> <span class="ss">using: :headless_chrome</span>

  <span class="nb">test</span> <span class="s2">"inviting a friend"</span> <span class="k">do</span>
    <span class="n">visit</span> <span class="n">invite_users_url</span>
    <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span> <span class="ss">with: </span><span class="s2">"friend@example.com"</span>
    <span class="n">assert_emails</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">click_on</span> <span class="s2">"Invite"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="note"><p>Метод <code>assert_emails</code> не связан с определенным методом доставки и будет работать с письмами, доставленными либо методом <code>deliver_now</code>. либо <code>deliver_later</code>. Если мы хотим явно убедиться, что письмо было помещено в очередь, можно использовать методы <code>assert_enqueued_email_with</code> (<a href="#testing-enqueued-emails">примеры выше</a>) или <code>assert_enqueued_emails</code>. Подробности можно узнать в <a href="https://api.rubyonrails.org/classes/ActionMailer/TestHelper.html">документации</a>.</p></div><h3 id='jobs-testing' class='inside_page_header'><a href="#jobs-testing">14.</a> Тестирование заданий</h3><p>Задания могут тестироваться в изоляции (фокусируясь на поведении задания) и в контексте (фокусируясь на поведении вызывающего кода).</p><h4 id='testirovanie-zadaniy-v-izolyatsii' class='inside_page_header'><a href="#testirovanie-zadaniy-v-izolyatsii">14.1.</a> Тестирование заданий в изоляции</h4><p>При генерации задания, также будет сгенерирован связанный файл теста в директории <code>test/jobs</code>.</p><p>Вот пример теста с заданием по выставлению счета:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">BillingJobTest</span> <span class="o">&lt;</span> <span class="no">ActiveJob</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"account is charged"</span> <span class="k">do</span>
    <span class="n">perform_enqueued_jobs</span> <span class="k">do</span>
      <span class="no">BillingJob</span><span class="p">.</span><span class="nf">perform_later</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">product</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>В среде тестирования задания по умолчанию не выполняются, пока не будет вызван метод <a href="https://api.rubyonrails.org/classes/ActiveJob/TestHelper.html#method-i-perform_enqueued_jobs"><code>perform_enqueued_jobs</code></a>. Кроме того, перед каждым тестом все задания в очереди будут очищены, чтобы исключить их взаимовлияние.</p><p>Тест использует <code>perform_enqueued_jobs</code> и <a href="https://api.rubyonrails.org/classes/ActiveJob/Enqueuing/ClassMethods.html#method-i-perform_later"><code>perform_later</code></a> вместо <a href="https://api.rubyonrails.org/classes/ActiveJob/Execution/ClassMethods.html#method-i-perform_now"><code>perform_now</code></a>, чтобы в случае, если настроены повторные попытки, ошибки при повторных попытках были перехвачены тестом, а не повторно поставлены в очередь и проигнорированы.</p><h4 id='testirovanie-zadaniy-v-kontekste' class='inside_page_header'><a href="#testirovanie-zadaniy-v-kontekste">14.2.</a> Тестирование заданий в контексте</h4><p>Хорошей практикой бывает убедиться, что задания были поставлены в очередь, например, в экшне контроллера. Модуль <a href="https://api.rubyonrails.org/classes/ActiveJob/TestHelper.html"><code>ActiveJob::TestHelper</code></a> предоставляет несколько методов, которые могут помочь с этим, таких как <a href="https://api.rubyonrails.org/classes/ActiveJob/TestHelper.html#method-i-assert_enqueued_with"><code>assert_enqueued_with</code></a>.</p><p>Вот пример, тестирующий метод модели счета:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">AccountTest</span> <span class="o">&lt;</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="kp">include</span> <span class="no">ActiveJob</span><span class="o">::</span><span class="no">TestHelper</span>

  <span class="nb">test</span> <span class="s2">"#charge_for enqueues billing job"</span> <span class="k">do</span>
    <span class="n">assert_enqueued_with</span><span class="p">(</span><span class="ss">job: </span><span class="no">BillingJob</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">account</span><span class="p">.</span><span class="nf">charge_for</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">assert_not</span> <span class="n">account</span><span class="p">.</span><span class="nf">reload</span><span class="p">.</span><span class="nf">charged_for?</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>

    <span class="n">perform_enqueued_jobs</span>

    <span class="n">assert</span> <span class="n">account</span><span class="p">.</span><span class="nf">reload</span><span class="p">.</span><span class="nf">charged_for?</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='testirovanie-vozniknoveniya-isklyucheniy' class='inside_page_header'><a href="#testirovanie-vozniknoveniya-isklyucheniy">14.3.</a> Тестирование возникновения исключений</h4><p>Тестирование ситуаций, когда задание должно вызывать исключение, может быть сопряжено с трудностями, особенно при использовании повторных попыток. Вспомогательный метод <code>perform_enqueued_jobs</code> помечает тест как неудачный, если задание вызывает исключение, поэтому, чтобы тест завершился успешно, когда возникает исключение, необходимо напрямую вызвать метод <code>perform</code> задания.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">BillingJobTest</span> <span class="o">&lt;</span> <span class="no">ActiveJob</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"does not charge accounts with insufficient funds"</span> <span class="k">do</span>
    <span class="n">assert_raises</span><span class="p">(</span><span class="no">InsufficientFundsError</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">BillingJob</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">empty_account</span><span class="p">,</span> <span class="n">product</span><span class="p">).</span><span class="nf">perform</span>
    <span class="k">end</span>
    <span class="n">refute</span> <span class="n">account</span><span class="p">.</span><span class="nf">reload</span><span class="p">.</span><span class="nf">charged_for?</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Однако, не рекомендуется использовать такой подход повсеместно, поскольку он обходит некоторые части фреймворка, например, сериализацию аргументов.</p><h3 id='testing-action-cable' class='inside_page_header'><a href="#testing-action-cable">15.</a> Тестирование Action Cable</h3><p>Поскольку Action Cable используется на различных уровнях вашего приложения, необходимо протестировать как каналы, сами классы соединений, так и другие сущности, транслирующие правильные сообщения.</p><h4 id='testovyy-sluchay-dlya-soedineniya' class='inside_page_header'><a href="#testovyy-sluchay-dlya-soedineniya">15.1.</a> Тестовый случай для соединения</h4><p>По умолчанию, при генерации нового приложения Rails с Action Cable, также генерируется тест для базового класса соединения (<code>ApplicationCable::Connection</code>) в директории <code>test/channels/application_cable</code>.</p><p>Тесты соединения нацелены на проверку, правильно ли назначаются идентификаторы соединения, или что любые неподходящие соединения отвергаются. Вот пример:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ApplicationCable::ConnectionTest</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">Connection</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"connects with params"</span> <span class="k">do</span>
    <span class="c1"># Симулируем открытие соединения, вызывая метод `connect`</span>
    <span class="n">connect</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">user_id: </span><span class="mi">42</span> <span class="p">}</span>

    <span class="c1"># В тестах можно получить объект Connection с помощью `connection`</span>
    <span class="n">assert_equal</span> <span class="n">connection</span><span class="p">.</span><span class="nf">user_id</span><span class="p">,</span> <span class="s2">"42"</span>
  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"rejects connection without params"</span> <span class="k">do</span>
    <span class="c1"># Используйте метод соответствия `assert_reject_connection` для проверки,</span>
    <span class="c1"># что соединение отвергнуто</span>
    <span class="n">assert_reject_connection</span> <span class="p">{</span> <span class="n">connect</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Также можно указать куки запроса, тем же способом, что и в интеграционных тестах:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">test</span> <span class="s2">"connects with cookies"</span> <span class="k">do</span>
  <span class="n">cookies</span><span class="p">.</span><span class="nf">signed</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"42"</span>

  <span class="n">connect</span>

  <span class="n">assert_equal</span> <span class="n">connection</span><span class="p">.</span><span class="nf">user_id</span><span class="p">,</span> <span class="s2">"42"</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Подробности смотрите в документации API по <a href="https://api.rubyonrails.org/classes/ActionCable/Connection/TestCase.html"><code>ActionCable::Connection::TestCase</code></a>.</p><h4 id='testovyy-sluchay-dlya-kanala' class='inside_page_header'><a href="#testovyy-sluchay-dlya-kanala">15.2.</a> Тестовый случай для канала</h4><p>По умолчанию, при генерации канала также будет сгенерирован связанный тест в директории <code>test/channels</code>. Вот пример теста для канала чата:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ChatChannelTest</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">Channel</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"subscribes and stream for room"</span> <span class="k">do</span>
    <span class="c1"># Симулируется подписка, вызывая `subscribe`</span>
    <span class="n">subscribe</span> <span class="ss">room: </span><span class="s2">"15"</span>

    <span class="c1"># В тестах можно получить объект Channel с помощью `subscription`</span>
    <span class="n">assert</span> <span class="n">subscription</span><span class="p">.</span><span class="nf">confirmed?</span>
    <span class="n">assert_has_stream</span> <span class="s2">"chat_15"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Этот тест очень простой и только убеждается, что канал подписывает соединение на определенный поток.</p><p>Также можно указать идентификаторы лежащего в основе соединения. Вот пример теста канала веб уведомлений:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">WebNotificationsChannelTest</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">Channel</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"subscribes and stream for user"</span> <span class="k">do</span>
    <span class="n">stub_connection</span> <span class="ss">current_user: </span><span class="n">users</span><span class="p">(</span><span class="ss">:john</span><span class="p">)</span>

    <span class="n">subscribe</span>

    <span class="n">assert_has_stream_for</span> <span class="n">users</span><span class="p">(</span><span class="ss">:john</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Подробности смотрите в документации API по <a href="https://api.rubyonrails.org/classes/ActionCable/Channel/TestCase.html"><code>ActionCable::Channel::TestCase</code></a>.</p><h4 id='polzovatelskie-utverzhdeniya-i-testirovanie-translyatsiy-vnutri-drugih-komponent' class='inside_page_header'><a href="#polzovatelskie-utverzhdeniya-i-testirovanie-translyatsiy-vnutri-drugih-komponent">15.3.</a> Пользовательские утверждения и тестирование трансляций внутри других компонент</h4><p>Action Cable поставляется с рядом пользовательских утверждений, которые можно использовать для уменьшения кода тестов. Полный список доступных утверждений смотрите в документации API для <a href="https://api.rubyonrails.org/classes/ActionCable/TestHelper.html"><code>ActionCable::TestHelper</code></a>.</p><p>Хорошей практикой является убедиться, что внутри других компонент (например, внутри контроллеров) было транслировано правильное сообщение. Именно тут очень полезны пользовательские утверждения, предоставленные Action Cable. К примеру, в модели:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ProductTest</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"broadcast status after charge"</span> <span class="k">do</span>
    <span class="n">assert_broadcast_on</span><span class="p">(</span><span class="s2">"products:</span><span class="si">#{</span><span class="n">product</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="ss">type: </span><span class="s2">"charged"</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">product</span><span class="p">.</span><span class="nf">charge</span><span class="p">(</span><span class="n">account</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Если хотите протестировать трансляции, выполненные с помощью <code>Channel.broadcast_to</code>, следует использовать <code>Channel.broadcasting_for</code> для генерации имени потока, лежащего в основе:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># app/jobs/chat_relay_job.rb</span>
<span class="k">class</span> <span class="nc">ChatRelayJob</span> <span class="o">&lt;</span> <span class="no">ApplicationJob</span>
  <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="n">room</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
    <span class="no">ChatChannel</span><span class="p">.</span><span class="nf">broadcast_to</span> <span class="n">room</span><span class="p">,</span> <span class="ss">text: </span><span class="n">message</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># test/jobs/chat_relay_job_test.rb</span>
<span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ChatRelayJobTest</span> <span class="o">&lt;</span> <span class="no">ActiveJob</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="kp">include</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">TestHelper</span>

  <span class="nb">test</span> <span class="s2">"broadcast message to room"</span> <span class="k">do</span>
    <span class="n">room</span> <span class="o">=</span> <span class="n">rooms</span><span class="p">(</span><span class="ss">:all</span><span class="p">)</span>

    <span class="n">assert_broadcast_on</span><span class="p">(</span><span class="no">ChatChannel</span><span class="p">.</span><span class="nf">broadcasting_for</span><span class="p">(</span><span class="n">room</span><span class="p">),</span> <span class="ss">text: </span><span class="s2">"Hi!"</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">ChatRelayJob</span><span class="p">.</span><span class="nf">perform_now</span><span class="p">(</span><span class="n">room</span><span class="p">,</span> <span class="s2">"Hi!"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h3 id='testing-eager-loading' class='inside_page_header'><a href="#testing-eager-loading">16.</a> Тестирование нетерпеливой загрузки</h3><p>Обычно приложения не загружают нетерпеливо в средах <code>development</code> или <code>test</code>, чтобы ускорить процесс. Но они так делают в среде <code>production</code>.</p><p>Если некоторый файл в проекте не может быть загружен по какой-либо причине, это лучше обнаружить до развертывания на production, так?</p><h4 id='nepreryvnaya-integratsiya' class='inside_page_header'><a href="#nepreryvnaya-integratsiya">16.1.</a> Непрерывная интеграция</h4><p>Если у вашего проекта настроен CI, нетерпеливая загрузка в CI является простым способом убедиться, что приложение загружается нетерпеливо.</p><p>CI обычно устанавливает некоторую переменную окружения, для обозначения, что тестовый случай запущен там. Например, это может быть <code>CI</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># config/environments/test.rb</span>
<span class="n">config</span><span class="p">.</span><span class="nf">eager_load</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"CI"</span><span class="p">].</span><span class="nf">present?</span>
</code></pre>
</div>
<p>Начиная с Rails 7, новые сгенерированные приложения конфигурируются таким способом по умолчанию.</p><h4 id='chistye-testovye-sluchai' class='inside_page_header'><a href="#chistye-testovye-sluchai">16.2.</a> Чистые тестовые случаи</h4><p>Если в вашем проекте нет непрерывной интеграции, все еще можно нетерпеливо загрузить в тестовом случае, вызвав <code>Rails.application.eager_load!</code>:</p><h5 id='minitest' class='inside_page_header'><a href="#minitest">16.2.1.</a> Minitest</h5><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"test_helper"</span>

<span class="k">class</span> <span class="nc">ZeitwerkComplianceTest</span> <span class="o">&lt;</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"eager loads all files without errors"</span> <span class="k">do</span>
    <span class="n">assert_nothing_raised</span> <span class="p">{</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h5 id='rspec' class='inside_page_header'><a href="#rspec">16.2.2.</a> RSpec</h5><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"rails_helper"</span>

<span class="no">RSpec</span><span class="p">.</span><span class="nf">describe</span> <span class="s2">"Zeitwerk compliance"</span> <span class="k">do</span>
  <span class="n">it</span> <span class="s2">"eager loads all files without errors"</span> <span class="k">do</span>
    <span class="n">expect</span> <span class="p">{</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span> <span class="p">}.</span><span class="nf">not_to</span> <span class="n">raise_error</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h3 id='dopolnitelnye-resursy-po-testirovaniyu' class='inside_page_header'><a href="#dopolnitelnye-resursy-po-testirovaniyu">17.</a> Дополнительные ресурсы по тестированию</h3><h4 id='testirovanie-koda-zavisimogo-ot-vremeni' class='inside_page_header'><a href="#testirovanie-koda-zavisimogo-ot-vremeni">17.1.</a> Тестирование кода, зависимого от времени</h4><p>Rails предоставляет встроенные вспомогательные методы, позволяющие убеждаться, что ваш зависимый от времени код работает, как ожидается.</p><p>Следующий пример использует хелпер <a href="https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-travel_to"><code>travel_to</code></a>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Допустим, что пользователю можно сделать подарок через месяц после регистрации.</span>
<span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Gaurish"</span><span class="p">,</span> <span class="ss">activation_date: </span><span class="no">Date</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2004</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">24</span><span class="p">))</span>
<span class="n">assert_not</span> <span class="n">user</span><span class="p">.</span><span class="nf">applicable_for_gifting?</span>
<span class="n">travel_to</span> <span class="no">Date</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2004</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># Внутри блока `travel_to` `Date.current` зафиксирована</span>
  <span class="n">assert_equal</span> <span class="no">Date</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2004</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">24</span><span class="p">),</span> <span class="n">user</span><span class="p">.</span><span class="nf">activation_date</span>
  <span class="n">assert</span> <span class="n">user</span><span class="p">.</span><span class="nf">applicable_for_gifting?</span>
<span class="k">end</span>
<span class="c1"># Изменение было видно только внутри блока `travel_to`.</span>
<span class="n">assert_equal</span> <span class="no">Date</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2004</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">24</span><span class="p">),</span> <span class="n">user</span><span class="p">.</span><span class="nf">activation_date</span>
</code></pre>
</div>
<p>Обратитесь к документации API <a href="https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html"><code>ActiveSupport::Testing::TimeHelpers</code></a> за подробностями о доступных хелперах времени.</p>

            <div class="banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

   <!-- bottom rusrails -->
   <ins class="adsbygoogle"
        style="display:inline-block;width:580px;height:400px"
        data-ad-client="ca-pub-7764391801669990"
        data-ad-slot="7566253867"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
          </div>
        </div>
        <div class="row-fluid">
          <div class="span12" id="footer">
            <p>
              <a target="blank" href="https://github.com/rusrails/rusrails"><img src="/assets/github-7cc23602a5ac2465f14c19492358a5a67dc24636761cc723e4d621cea0c09225.png" /></a>
              <a target="blank" href="http://twitter.com/rusrails"><img src="/assets/twitter-50e0e767c8793dec313a7dc5cfbcfe2067e3e89ea6ec64784eb7c6640f578758.png" /></a>
            </p>
            <p>
              <a href="https://creativecommons.org/licenses/by-sa/4.0/">Лицензия CC BY-SA 4.0</a>
              "Rails", "Ruby on Rails" и логотип Rails - торговые марки DHH
              <!-- Yandex.Metrika counter -->
<script>
  (function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter1006929 = new Ya.Metrika({id:1006929,
                    webvisor:true,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>

<noscript>
  <div>
    <img style="position:absolute; left:-9999px;" alt="" src="//mc.yandex.ru/watch/1006929" />
  </div>
</noscript>
<!-- /Yandex.Metrika counter -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-64955373-1', 'auto');
  ga('send', 'pageview');

  var trackOutboundLink = function(url) {
    ga('send', 'event', 'outbound', 'click', url, {
      'transport': 'beacon',
      'hitCallback': function(){ }
    });
  }
</script>

            </p>
          </div>
        </div>
      </div>
    </div>
    <div class="to_top" style="display: block">
      <div class="to_top_panel"></div>
    </div>
    <script src="/assets/application-8ee447905888b153d8458707061a14b1f15f69b6733e871a3ad91d80ae89e87b.js"></script>
  </body>
</html>
