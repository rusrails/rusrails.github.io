<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8">
<meta content="Ruby on Rails, Ruby, Rails, Rails 3, Rails 4, Rails 5, Rails 6, Rails 6.0, Rails 6.1, Rails 7.0, Rails 7.1 руководство, начинающим, самоучитель, manual, мануал, справочник, учебник, примеры, Руби, рельсы" name="keywords"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" name="description"/>
<meta content="product" property="twitter:card"/>
<meta content="@rusrails" property="twitter:site"/>
<meta content="Rusrails: Колбэки Active Record" property="twitter:title"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" property="twitter:description"/>
<meta content="@rusrails" property="twitter:creator"/>
<meta content="http://rusrails.ru/assets/rusrails.png" property="twitter:image"/>
<meta content="website" property="og:type"/>
<meta content="Rusrails: Колбэки Active Record" property="og:title"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" property="og:description"/>
<meta content="http://localhost:3000/active-record-callbacks" property="og:url"/>
<meta content="http://rusrails.ru/assets/rusrails.png" property="og:image"/>
    <title>
      Rusrails: Колбэки Active Record
    </title>
    <link rel="stylesheet" href="/assets/application-f9dfa6ce7fa871006d478e422639671663284ddaa3126cf81ddfe371ac3533c4.css" />
  </head>
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="brand" href="/"></a>
          <ul class="nav pull-right top-menu">
            <li>
              <a href="/">Главная</a>
            </li>
            <li class="dropdown">
              <a class="index-popover" href="#">
                Содержание
                <b class="caret"></b>
</a>              <div class="index-popover-content hide">
                  <ul><li><p><strong>С чего начать?</strong></p><ul><li><a href="/getting-started">Rails для начинающих</a>
</li></ul></li><li><p><strong>Модели</strong></p><ul><li><a href="/active-record-basics">Основы Active Record</a>
</li><li><a href="/active-record-migrations">Миграции Active Record</a>
</li><li><a href="/active-record-validations">Валидации Active Record</a>
</li><li><a href="/active-record-callbacks">Колбэки Active Record</a>
</li><li><a href="/active-record-associations">Связи (ассоциации) Active Record</a>
</li><li><a href="/active-record-querying">Интерфейс запросов Active Record</a>
</li><li><a href="/active-model-basics">Основы Active Model</a>
</li></ul></li><li><p><strong>Вью</strong></p><ul><li><a href="/action-view-overview">Обзор Action View</a>
</li><li><a href="/layouts-and-rendering">Макеты и рендеринг в Rails</a>
</li><li><a href="/action-view-helpers">Хелперы Action View</a>
</li><li><a href="/form-helpers">Хелперы форм в Action View</a>
</li></ul></li><li><p><strong>Контроллеры</strong></p><ul><li><a href="/action-controller-overview">Обзор Action Controller</a>
</li><li><a href="/routing">Роутинг в Rails</a>
</li></ul></li><li><p><strong>Другие компоненты</strong></p><ul><li><a href="/active-support-core-extensions">Расширения ядра Active Support</a>
</li><li><a href="/action-mailer-basics">Основы Action Mailer</a>
</li><li><a href="/action-mailbox-basics">Основы Action Mailbox</a>
</li><li><a href="/action-text-overview">Обзор Action Text</a>
</li><li><a href="/active_job_basics">Основы Active Job</a>
</li><li><a href="/active_storage_overview">Обзор Active Storage</a>
</li><li><a href="/action-cable-overview">Обзор Action Cable</a>
</li></ul></li><li><p><strong>Копаем глубже</strong></p><ul><li><a href="/i18n">API интернационализации Rails (I18n)</a>
</li><li><a href="/testing">Тестирование приложений на Rails</a>
</li><li><a href="/security">Безопасность приложений на Rails</a>
</li><li><a href="/error-reporting">Отчет об ошибках в приложениях Rails</a>
</li></ul></li></ul><p>next_column</p><ul><li><p><strong>Копаем глубже</strong></p><ul><li><a href="/debugging-rails-applications">Отладка приложений на Rails</a>
</li><li><a href="/configuring">Конфигурирование приложений на Rails</a>
</li><li><a href="/command-line">Командная строка Rails</a>
</li><li><a href="/asset-pipeline">Asset Pipeline</a>
</li><li><a href="/working-with-javascript-in-rails">Работа с JavaScript в Rails</a>
</li><li><a href="/initialization">Процесс инициализации в Rails</a>
</li><li><a href="/autoloading-and-reloading-constants">Автозагрузка и перезагрузка констант</a>
</li><li><a href="/classic-to-zeitwerk-howto">Как перейти с Classic на Zeitwerk</a>
</li><li><a href="/caching-with-rails">Кэширование с Rails: Обзор</a>
</li><li><a href="/active-support-instrumentation">Инструментарий Active Support</a>
</li><li><a href="/api-app">Использование Rails для API-приложений</a>
</li><li><a href="/active-record-postgresql">Active Record для PostgreSQL</a>
</li><li><a href="/active-record-multiple-databases">Несколько баз данных с Active Record</a>
</li><li><a href="/active-record-encryption">Шифрование Active Record</a>
</li></ul></li><li><p><strong>Расширяем Rails</strong></p><ul><li><a href="/plugins">Основы создания плагинов Rails</a>
</li><li><a href="/rails-on-rack">Rails on Rack</a>
</li><li><a href="/generators">Создание и настройка генераторов и шаблонов Rails</a>
</li><li><a href="/engines">Engine для начинающих</a>
</li><li><a href="/threading_and_code_execution">Треды и выполнение кода в Rails</a>
</li><li><a href="/rails-application-templates">Шаблоны приложения Rails</a>
</li></ul></li><li><p><strong>Вносим вклад в Ruby on Rails</strong></p><ul><li><a href="/contributing_to_ruby_on_rails">Вносим вклад в Ruby on Rails</a>
</li><li><a href="/api_documentation_guidelines">Рекомендации по документированию API</a>
</li><li><a href="/ruby_on_rails_guides_guidelines">Рекомендации для руководств по Ruby on Rails</a>
</li><li><a href="/development_dependencies_install">Установка зависимостей для разработки</a>
</li><li><a href="/maintenance-policy">Политика поддержки (версий)</a>
</li></ul></li><li><p><strong>Заметки о релизах</strong></p><ul><li><a href="/upgrading-ruby-on-rails">Апгрейд Ruby on Rails</a>
</li><li><a href="/7_1_release_notes">Версия 7.1 - ?</a>
</li><li><a href="/7_0_release_notes">Версия 7.0 - Декабрь 2021</a>
</li><li><a href="/6_1_release_notes">Версия 6.1 - Декабрь 2020</a>
</li><li><a href="/6_0_release_notes">Версия 6.0 - Август 2019</a>
</li></ul></li></ul>
              </div>
            </li>
            <li>
              <a href="/search">Поиск</a>
            </li>
            <li>
              <a target="blank" href="http://api.rusrails.ru">Ruby &amp; Rails API</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content-wrapper">
      <div class="container-fluid">
        <div class="row-fluid">
          <div class="span3 pull-right">
            <div class="well social">
              <h4>Принимаем пожелания и пул-реквесты!</h4>
              <iframe allowtransparency="true" frameborder="0" height="30" src="http://ghbtns.com/github-btn.html?user=rusrails&repo=rusrails&type=watch&count=true&size=large" width="180"></iframe>
              <p></p>
              <a class="twitter-follow-button" data-lang="ru" href="https://twitter.com/rusrails"></a>
            </div>
              <div class="well menu">
                    <ul class="nav nav-list">
      <li>
        <h4>
          <a href="#zhiznennyy-tsikl-ob-ekta">1. Жизненный цикл объекта</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#obzor-kolbekov">2. Обзор колбэков</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#registratsiya-kolbekov">2.1. Регистрация колбэков</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#dostupnye-kolbeki">3. Доступные колбэки</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#sozdanie-ob-ekta">3.1. Создание объекта</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#obnovlenie-ob-ekta">3.2. Обновление объекта</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#unichtozhenie-ob-ekta">3.3. Уничтожение объекта</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#after_initialize-i-after_find">3.4. <code>after_initialize</code> и <code>after_find</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#after_touch">3.5. <code>after_touch</code></a>
</h5>      </li>
      <li>
        <h4>
          <a href="#zapusk-kolbekov">4. Запуск колбэков</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#propusk-kolbekov">5. Пропуск колбэков</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#preryvanie-vypolneniya">6. Прерывание выполнения</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#kolbeki-dlya-otnosheniy">7. Колбэки для отношений</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#uslovnye-kolbeki">8. Условные колбэки</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#ispolzovanie-if-i-unless-s-symbol">8.1. Использование <code>:if</code> и <code>:unless</code> с <code>Symbol</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#ispolzovanie-if-i-unless-s-proc">8.2. Использование <code>:if</code> и <code>:unless</code> с <code>Proc</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#multiple-callback-conditions">8.3.  Составные условия колбэков</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#odnovremennoe-ispolzovanie-if-i-unless">8.4. Одновременное использование :if и :unless</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#callback-classes">9.  Классы колбэков</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#transaction-callbacks">10.  Транзакционные колбэки</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#razbiraemsya-s-soglasovannostyu">10.1. Разбираемся с согласованностью</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#kontekst-imeet-znachenie">10.2. Контекст имеет значение</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#after_save_commit">10.3. <code>after_save_commit</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#uporyadochivanie-tranzaktsionnyh-kolbekov">10.4. Упорядочивание транзакционных колбэков</a>
</h5>      </li>
</ul>

              </div>
            <div class="well banner300 banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<!-- sidebar rusrails -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-7764391801669990"
     data-ad-slot="6089520660"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
          </div>
          <div class="span9 content pull-left">
            <div class="banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <!-- top rusrails -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:980px;height:120px"
       data-ad-client="ca-pub-7764391801669990"
       data-ad-slot="4891989065"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
              <h2 id='kolbeki-active-record' class='inside_page_header'> Колбэки Active Record</h2><p>Это руководство научит вас вмешиваться в жизненный цикл ваших объектов Active Record.</p><p>После прочтения этого руководства вы узнаете:</p><ul><li>Когда определенные события случаются в течение жизни объекта Active Record
</li><li>Как создавать методы колбэков, отвечающих на события в жизненном цикле объекта
</li><li>Как создавать специальные классы, инкапсулирующих обычное поведение для ваших колбэков
</li></ul><h3 id='zhiznennyy-tsikl-ob-ekta' class='inside_page_header'><a href="#zhiznennyy-tsikl-ob-ekta">1.</a> Жизненный цикл объекта</h3><p>В результате обычных операций приложения на Rails, объекты могут быть созданы, обновлены и уничтожены. Active Record дает возможность вмешаться в этот жизненный цикл объекта, таким образом, вы можете контролировать свое приложение и его данные.</p><p>Валидации позволяют вам быть уверенными, что только валидные данные хранятся в вашей базе данных. Колбэки позволяют вам переключать логику до или после изменения состояния объекта.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Baby</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">after_create</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"Congratulations!"</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="vi">@baby</span> <span class="o">=</span> <span class="no">Baby</span><span class="p">.</span><span class="nf">create</span>
<span class="go">Congratulations!
</span></code></pre>
</div>
<p>Вы увидите, что есть множество событий жизненного цикла, и вы сможете вклиниться в любое из них, до, после или даже вокруг них.</p><h3 id='obzor-kolbekov' class='inside_page_header'><a href="#obzor-kolbekov">2.</a> Обзор колбэков</h3><p>Колбэки это методы, которые вызываются в определенные моменты жизненного цикла объекта. С колбэками возможно написать код, который будет запущен, когда объект Active Record создается, сохраняется, обновляется, удаляется, проходит валидацию или загружается из базы данных.</p><h4 id='registratsiya-kolbekov' class='inside_page_header'><a href="#registratsiya-kolbekov">2.1.</a> Регистрация колбэков</h4><p>Для того, чтобы использовать доступные колбэки, их нужно зарегистрировать. Можно реализовать колбэки как обычные методы, а затем использовать макро-методы класса для их регистрации в качестве колбэков.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">validates</span> <span class="ss">:login</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>

  <span class="n">before_validation</span> <span class="ss">:ensure_login_has_a_value</span>

  <span class="kp">private</span>
    <span class="k">def</span> <span class="nf">ensure_login_has_a_value</span>
      <span class="k">if</span> <span class="n">login</span><span class="p">.</span><span class="nf">blank?</span>
        <span class="nb">self</span><span class="p">.</span><span class="nf">login</span> <span class="o">=</span> <span class="n">email</span> <span class="k">unless</span> <span class="n">email</span><span class="p">.</span><span class="nf">blank?</span>
      <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Макро-методы класса также могут получать блок. Их следует использовать, если код внутри блока такой короткий, что помещается в одну строчку.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">validates</span> <span class="ss">:login</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>

  <span class="n">before_create</span> <span class="k">do</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="n">login</span><span class="p">.</span><span class="nf">capitalize</span> <span class="k">if</span> <span class="nb">name</span><span class="p">.</span><span class="nf">blank?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Альтернативно можно передать в колбэк proc, который будут выполнен.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">before_create</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="nf">login</span><span class="p">.</span><span class="nf">capitalize</span> <span class="k">if</span> <span class="n">user</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">blank?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Наконец, можно определить собственный объект колбэка, который мы раскроем подробнее <a href="#callback-classes">ниже</a>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">before_create</span> <span class="no">MaybeAddName</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MaybeAddName</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">before_create</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">record</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">blank?</span>
      <span class="n">record</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="n">record</span><span class="p">.</span><span class="nf">login</span><span class="p">.</span><span class="nf">capitalize</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Колбэки также могут быть зарегистрированы на выполнение только при определенных событиях жизненного цикла, что позволяет полностью контролировать в каком контексте ваши колбэки выполняются.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">before_validation</span> <span class="ss">:normalize_name</span><span class="p">,</span> <span class="ss">on: :create</span>

  <span class="c1"># :on также принимает массив</span>
  <span class="n">after_validation</span> <span class="ss">:set_location</span><span class="p">,</span> <span class="ss">on: </span><span class="p">[</span> <span class="ss">:create</span><span class="p">,</span> <span class="ss">:update</span> <span class="p">]</span>

  <span class="kp">private</span>
    <span class="k">def</span> <span class="nf">normalize_name</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">downcase</span><span class="p">.</span><span class="nf">titleize</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">set_location</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">location</span> <span class="o">=</span> <span class="no">LocationService</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Считается хорошей практикой объявлять методы колбэков как private. Если их оставить public, они могут быть вызваны извне модели и нарушить принципы инкапсуляции объекта.</p><div class="warning"><p>Избегайте вызовов <code>update</code>, <code>save</code> или других методов, которые создают побочные эффекты для объекта, внутри вашего колбэка. Например, не вызывайте <code>update(attribute: &quot;value&quot;)</code> внутри колбэка. Это может изменить состояние модели и может привести к неожиданным побочным эффектам при завершении транзакции. Вместо этого можно безопасно присваивать значения напрямую (например, <code>self.attribute = &quot;value&quot;</code>) в <code>before_create</code> / <code>before_update</code> или более ранних колбэках.</p></div><h3 id='dostupnye-kolbeki' class='inside_page_header'><a href="#dostupnye-kolbeki">3.</a> Доступные колбэки</h3><p>Вот список всех доступных колбэков Active Record, перечисленных в том порядке, в котором они вызываются в течение соответствующих операций:</p><h4 id='sozdanie-ob-ekta' class='inside_page_header'><a href="#sozdanie-ob-ekta">3.1.</a> Создание объекта</h4><ul><li><a href="https://api.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-before_validation"><code>before_validation</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-after_validation"><code>after_validation</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_save"><code>before_save</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_save"><code>around_save</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_create"><code>before_create</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_create"><code>around_create</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_create"><code>after_create</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_save"><code>after_save</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> / <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a>
</li></ul><h4 id='obnovlenie-ob-ekta' class='inside_page_header'><a href="#obnovlenie-ob-ekta">3.2.</a> Обновление объекта</h4><ul><li><a href="https://api.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-before_validation"><code>before_validation</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-after_validation"><code>after_validation</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_save"><code>before_save</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_save"><code>around_save</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_update"><code>before_update</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_update"><code>around_update</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_update"><code>after_update</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_save"><code>after_save</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> / <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a>
</li></ul><div class="warning"><p><code>after_save</code> запускается и при создании, и при обновлении, но всегда <em>после</em> более специфичных колбэков <code>after_create</code> и <code>after_update</code>, независимо от порядка, в котором выполняются макро-вызовы.</p></div><h4 id='unichtozhenie-ob-ekta' class='inside_page_header'><a href="#unichtozhenie-ob-ekta">3.3.</a> Уничтожение объекта</h4><ul><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_destroy"><code>before_destroy</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_destroy"><code>around_destroy</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_destroy"><code>after_destroy</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> / <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a>
</li></ul><div class="note"><p>Колбэк <code>before_destroy</code> должен быть размещен перед связями <code>dependent: :destroy</code> (или использовать опцию <code>prepend: true</code>), чтобы убедиться, что они выполняются до того, как записи будут удалены с помощью <code>dependent: :destroy</code>.</p></div><div class="warning"><p><code>after_commit</code> создает гарантии, сильно отличающиеся от <code>after_save</code>, <code>after_update</code> и <code>after_destroy</code>. Например, если случается исключение в <code>after_save</code>, транзакция будет отменена, и данные не сохранятся. Не важно, что произойдет, <code>after_commit</code> может гарантировать, что транзакция уже произошла, и данные были сохранены в базу данных. Подробнее о <a href="#transaction-callbacks">транзакционных колбэках</a> ниже.</p></div><h4 id='after_initialize-i-after_find' class='inside_page_header'><a href="#after_initialize-i-after_find">3.4.</a> <code>after_initialize</code> и <code>after_find</code></h4><p>Всякий раз, когда возникает объект Active Record, будет вызван колбэк <a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_initialize"><code>after_initialize</code></a>, или непосредственно при использовании <code>new</code>, или когда запись загружается из базы данных. Он может быть полезен, чтобы избежать необходимости напрямую переопределять метод Active Record <code>initialize</code>.</p><p>При загрузке записи из базы данных, будет вызван колбэк <a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_find"><code>after_find</code></a>. <code>after_find</code> вызывается перед <code>after_initialize</code>, если они оба определены.</p><div class="note"><p>У колбэков <code>after_initialize</code> и <code>after_find</code> нет пары <code>before_*</code>.</p></div><p>Они могут быть зарегистрированы подобно другим колбэкам Active Record.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">after_initialize</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"You have initialized an object!"</span>
  <span class="k">end</span>

  <span class="n">after_find</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"You have found an object!"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">User</span><span class="p">.</span><span class="nf">new</span>
<span class="go">You have initialized an object!
</span><span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">User</span> <span class="ss">id: </span><span class="kp">nil</span><span class="kt">&gt;</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">User</span><span class="p">.</span><span class="nf">first</span>
<span class="go">You have found an object!
You have initialized an object!
</span><span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">User</span> <span class="ss">id: </span><span class="mi">1</span><span class="kt">&gt;</span>
</code></pre>
</div>
<h4 id='after_touch' class='inside_page_header'><a href="#after_touch">3.5.</a> <code>after_touch</code></h4><p>Колбэк <a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_touch"><code>after_touch</code></a> будет вызван, когда на объекте Active Record вызван <code>touch</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">after_touch</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"You have touched an object"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">u</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'Kuldeep'</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">User</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">name: </span><span class="s2">"Kuldeep"</span><span class="p">,</span> <span class="ss">created_at: </span><span class="s2">"2013-11-25 12:17:49"</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="s2">"2013-11-25 12:17:49"</span><span class="kt">&gt;</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="nf">touch</span>
<span class="go">You have touched an object
</span><span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre>
</div>
<p>Он может быть использован совместно с <code>belongs_to</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:library</span><span class="p">,</span> <span class="ss">touch: </span><span class="kp">true</span>
  <span class="n">after_touch</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s1">'A Book was touched'</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Library</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span>
  <span class="n">after_touch</span> <span class="ss">:log_when_books_or_library_touched</span>

  <span class="kp">private</span>
    <span class="k">def</span> <span class="nf">log_when_books_or_library_touched</span>
      <span class="nb">puts</span> <span class="s1">'Book/Library was touched'</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="vi">@book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">last</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">library_id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">created_at: </span><span class="s2">"2013-11-25 17:04:22"</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="s2">"2013-11-25 17:05:05"</span><span class="kt">&gt;</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="vi">@book</span><span class="p">.</span><span class="nf">touch</span> <span class="c1"># triggers @book.library.touch</span>
<span class="go">A Book was touched
Book/Library was touched
</span><span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre>
</div>
<h3 id='zapusk-kolbekov' class='inside_page_header'><a href="#zapusk-kolbekov">4.</a> Запуск колбэков</h3><p>Следующие методы запускают колбэки:</p><ul><li><code>create</code>
</li><li><code>create!</code>
</li><li><code>destroy</code>
</li><li><code>destroy!</code>
</li><li><code>destroy_all</code>
</li><li><code>destroy_by</code>
</li><li><code>save</code>
</li><li><code>save!</code>
</li><li><code>save(validate: false)</code>
</li><li><code>toggle!</code>
</li><li><code>touch</code>
</li><li><code>update_attribute</code>
</li><li><code>update</code>
</li><li><code>update!</code>
</li><li><code>valid?</code>
</li></ul><p>Дополнительно, колбэк <code>after_find</code> запускается следующими поисковыми методами:</p><ul><li><code>all</code>
</li><li><code>first</code>
</li><li><code>find</code>
</li><li><code>find_by</code>
</li><li><code>find_by_*</code>
</li><li><code>find_by_*!</code>
</li><li><code>find_by_sql</code>
</li><li><code>last</code>
</li></ul><p>Колбэк <code>after_initialize</code> запускается всякий раз, когда инициализируется новый объект класса.</p><div class="note"><p>Методы <code>find_by_*</code> и <code>find_by_*!</code> это динамические методы поиска, генерируемые автоматически для каждого атрибута. Изучите подробнее их в <a href="/active-record-querying#dynamic-finders">разделе Динамический поиск</a></p></div><h3 id='propusk-kolbekov' class='inside_page_header'><a href="#propusk-kolbekov">5.</a> Пропуск колбэков</h3><p>Подобно валидациям, также возможно пропустить колбэки, используя следующие методы.</p><ul><li><code>decrement</code>
</li><li><code>decrement!</code>
</li><li><code>decrement_counter</code>
</li><li><code>delete</code>
</li><li><code>delete_all</code>
</li><li><code>delete_by</code>
</li><li><code>increment</code>
</li><li><code>increment!</code>
</li><li><code>increment_counter</code>
</li><li><code>insert</code>
</li><li><code>insert!</code>
</li><li><code>insert_all</code>
</li><li><code>insert_all!</code>
</li><li><code>touch_all</code>
</li><li><code>update_column</code>
</li><li><code>update_columns</code>
</li><li><code>update_all</code>
</li><li><code>update_counters</code>
</li><li><code>upsert</code>
</li><li><code>upsert_all</code>
</li></ul><p>Однако, эти методы нужно использовать осторожно, поскольку важные бизнес-правила и логика приложения могут содержаться в колбэках. Пропуск их без понимания возможных последствий может привести к невалидным данным.</p><h3 id='preryvanie-vypolneniya' class='inside_page_header'><a href="#preryvanie-vypolneniya">6.</a> Прерывание выполнения</h3><p>Как только вы зарегистрировали новые колбэки в своих моделях, они будут поставлены в очередь на выполнение. Эта очередь включает все валидации вашей модели, зарегистрированные колбэки и операции с базой данных для выполнения.</p><p>Вся цепочка колбэков упаковывается в операцию. Если любой колбэк вызывает исключение, выполняемая цепочка прерывается и запускается ROLLBACK. Чтобы преднамеренно остановить цепочку, используйте:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="kp">throw</span> <span class="ss">:abort</span>
</code></pre>
</div>
<div class="warning"><p>Вызов произвольного исключения может прервать код, который предполагает, что <code>save</code> и тому подобное не будут провалены подобным образом. Исключение <code>ActiveRecord::Rollback</code> чуть точнее сообщает Active Record, что происходит откат. Он подхватывается изнутри, но не перевызывает исключение.</p></div><div class="warning"><p>Любое исключение, кроме <code>ActiveRecord::Rollback</code> или <code>ActiveRecord::RecordInvalid</code>, будет перевызвано Rails после того, как прервется цепочка колбэков. Помимо этого, они могут сломать код, который не ожидает, что методы, такие как <code>save</code> и <code>update</code> (которые обычно пытаются вернуть <code>true</code> или <code>false</code>) вызовут исключение.</p></div><h3 id='kolbeki-dlya-otnosheniy' class='inside_page_header'><a href="#kolbeki-dlya-otnosheniy">7.</a> Колбэки для отношений</h3><p>Колбэки работают с отношениями между моделями, и даже могут быть определены ими. Представим пример, где пользователь имеет много статей. Статьи пользователя должны быть уничтожены, если уничтожается пользователь. Давайте добавим колбэк <code>after_destroy</code> в модель <code>User</code> через ее отношения с моделью <code>Article</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:articles</span><span class="p">,</span> <span class="ss">dependent: :destroy</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">after_destroy</span> <span class="ss">:log_destroy_action</span>

  <span class="k">def</span> <span class="nf">log_destroy_action</span>
    <span class="nb">puts</span> <span class="s1">'Article destroyed'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">first</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">User</span> <span class="ss">id: </span><span class="mi">1</span><span class="kt">&gt;</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="nf">articles</span><span class="p">.</span><span class="nf">create!</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Article</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">user_id: </span><span class="mi">1</span><span class="kt">&gt;</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="nf">destroy</span>
<span class="go">Article destroyed
</span><span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">User</span> <span class="ss">id: </span><span class="mi">1</span><span class="kt">&gt;</span>
</code></pre>
</div>
<h3 id='uslovnye-kolbeki' class='inside_page_header'><a href="#uslovnye-kolbeki">8.</a> Условные колбэки</h3><p>Как и в валидациях, возможно сделать вызов метода колбэка условным в зависимости от заданного предиката. Это осуществляется при использовании опций <code>:if</code> и <code>:unless</code>, которые могут принимать символ, <code>Proc</code> или массив.</p><p>Опцию <code>:if</code> следует использовать для определения, при каких условиях колбэк <em>должен</em> быть вызван. Если вы хотите определить условия, при которых колбэк <em>не должен</em> быть вызван, используйте опцию <code>:unless</code>.</p><h4 id='ispolzovanie-if-i-unless-s-symbol' class='inside_page_header'><a href="#ispolzovanie-if-i-unless-s-symbol">8.1.</a> Использование <code>:if</code> и <code>:unless</code> с <code>Symbol</code></h4><p>Опции <code>:if</code> и <code>:unless</code> можно связать с символом, соответствующим имени метода предиката, который будет вызван непосредственно перед вызовом колбэка.</p><p>При использовании опции <code>:if</code>, колбэк <strong>не будет</strong> выполнен, если метод предиката возвратит <strong>false</strong>; при использовании опции <code>:unless</code>, колбэк <strong>не будет</strong> выполнен, если метод предиката возвратит <strong>true</strong>. Это самый распространенный вариант.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">before_save</span> <span class="ss">:normalize_card_number</span><span class="p">,</span> <span class="ss">if: :paid_with_card?</span>
<span class="k">end</span>
</code></pre>
</div>
<p>При использовании такой формы регистрации, также возможно зарегистрировать несколько различных предикатов, которые будут вызваны, чтобы проверить, должен ли выполняться колбэк. Мы раскроем это <a href="#multiple-callback-conditions">ниже</a>.</p><h4 id='ispolzovanie-if-i-unless-s-proc' class='inside_page_header'><a href="#ispolzovanie-if-i-unless-s-proc">8.2.</a> Использование <code>:if</code> и <code>:unless</code> с <code>Proc</code></h4><p>Можно связать <code>:if</code> и <code>:unless</code> с объектом <code>Proc</code>. Этот вариант больше всего подходит при написании коротких методов, обычно однострочных.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">before_save</span> <span class="ss">:normalize_card_number</span><span class="p">,</span>
    <span class="ss">if: </span><span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">order</span><span class="o">|</span> <span class="n">order</span><span class="p">.</span><span class="nf">paid_with_card?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Так как proc вычисляется в контексте объекта, также возможно написать так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">before_save</span> <span class="ss">:normalize_card_number</span><span class="p">,</span> <span class="ss">if: </span><span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="n">paid_with_card?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='multiple-callback-conditions' class='inside_page_header'><a href="#multiple-callback-conditions">8.3.</a>  Составные условия колбэков</h4><p>Опции <code>:if</code> и <code>:unless</code> также принимают массив из proc или имен методов в виде символов:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">before_save</span> <span class="ss">:filter_content</span><span class="p">,</span>
    <span class="ss">if: </span><span class="p">[</span><span class="ss">:subject_to_parental_control?</span><span class="p">,</span> <span class="ss">:untrusted_author?</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>
<p>В список условий также можно запросто включить proc:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">before_save</span> <span class="ss">:filter_content</span><span class="p">,</span>
    <span class="ss">if: </span><span class="p">[</span><span class="ss">:subject_to_parental_control?</span><span class="p">,</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="n">untrusted_author?</span> <span class="p">}]</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='odnovremennoe-ispolzovanie-if-i-unless' class='inside_page_header'><a href="#odnovremennoe-ispolzovanie-if-i-unless">8.4.</a> Одновременное использование :if и :unless</h4><p>В колбэках можно смешивать <code>:if</code> и <code>:unless</code> в одном выражении:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">before_save</span> <span class="ss">:filter_content</span><span class="p">,</span>
    <span class="ss">if: </span><span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="n">forum</span><span class="p">.</span><span class="nf">parental_control?</span> <span class="p">},</span>
    <span class="ss">unless: </span><span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="n">author</span><span class="p">.</span><span class="nf">trusted?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Колбэк запустится только когда все условия <code>:if</code> и не один из условий <code>:unless</code> будут истинны.</p><h3 id='callback-classes' class='inside_page_header'><a href="#callback-classes">9.</a>  Классы колбэков</h3><p>Иногда написанные вами методы колбэков достаточно полезны для повторного использования в других моделях. Active Record делает возможным создавать классы, включающие методы колбэка, так, что их можно использовать повторно.</p><p>Вот пример, где создается класс с колбэком <code>after_destroy</code>, чтобы разобраться с очисткой отвергнутых файлов в файловой системе. Это поведение может быть неуникальным для нашей модели <code>PictureFile</code>, и мы хотим поделиться им, таким образом хорошей идеей будет инкапсуляция его в отдельный класс. Это сделает более простым тестирование и изменение этого поведения.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">FileDestroyerCallback</span>
  <span class="k">def</span> <span class="nf">after_destroy</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">if</span> <span class="no">File</span><span class="p">.</span><span class="nf">exist?</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="nf">filepath</span><span class="p">)</span>
      <span class="no">File</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="nf">filepath</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>При объявлении внутри класса, как выше, методы колбэка получают объект модели как параметр. Это будет работать с любой моделью, которая использует класс подобным образом:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">PictureFile</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">after_destroy</span> <span class="no">FileDestroyerCallback</span><span class="p">.</span><span class="nf">new</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Заметьте, что нам нужно создать экземпляр нового объекта <code>FileDestroyerCallback</code>, после того, как объявили наш колбэк как отдельный метод. Это особенно полезно, если колбэки используют состояние экземпляра объекта. Часто, однако, более подходящим является объявление его в качестве метода класса.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">FileDestroyerCallback</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">after_destroy</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">if</span> <span class="no">File</span><span class="p">.</span><span class="nf">exist?</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="nf">filepath</span><span class="p">)</span>
      <span class="no">File</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="nf">filepath</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Когда метод колбэка объявляется таким образом, нет необходимости создавать экземпляр объекта <code>FileDestroyerCallback</code> в нашей модели.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">PictureFile</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">after_destroy</span> <span class="no">FileDestroyerCallback</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Внутри своего колбэк-класса можно создать сколько угодно колбэков.</p><h3 id='transaction-callbacks' class='inside_page_header'><a href="#transaction-callbacks">10.</a>  Транзакционные колбэки</h3><h4 id='razbiraemsya-s-soglasovannostyu' class='inside_page_header'><a href="#razbiraemsya-s-soglasovannostyu">10.1.</a> Разбираемся с согласованностью</h4><p>Имеются два дополнительных колбэка, которые включаются по завершению транзакции базы данных: <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> и <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a>. Эти колбэки очень похожи на колбэк <code>after_save</code>, за исключением того, что они не выполняются пока изменения в базе данных не будут подтверждены или обращены. Они наиболее полезны, когда вашим моделям Active Record необходимо взаимодействовать с внешними системами, не являющимися частью транзакции базы данных.</p><p>Рассмотрим, допустим, предыдущий пример, где модели <code>PictureFile</code> необходимо удалить файл после того, как запись уничтожена. Если что-либо вызовет исключение после того, как был вызван колбэк <code>after_destroy</code>, и транзакция откатывается, файл будет удален и модель останется в противоречивом состоянии. Например, предположим, что <code>picture_file_2</code> в следующем коде не валидна, и метод <code>save!</code> вызовет ошибку.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">PictureFile</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">picture_file_1</span><span class="p">.</span><span class="nf">destroy</span>
  <span class="n">picture_file_2</span><span class="p">.</span><span class="nf">save!</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Используя колбэк <code>after_commit</code>, можно учесть этот случай.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">PictureFile</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">after_commit</span> <span class="ss">:delete_picture_file_from_disk</span><span class="p">,</span> <span class="ss">on: :destroy</span>

  <span class="k">def</span> <span class="nf">delete_picture_file_from_disk</span>
    <span class="k">if</span> <span class="no">File</span><span class="p">.</span><span class="nf">exist?</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
      <span class="no">File</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="note"><p>Опция <code>:on</code> определяет, когда будет запущен колбэк. Если не предоставить опцию <code>:on</code>, колбэк будет запущен для каждого экшна.</p></div><h4 id='kontekst-imeet-znachenie' class='inside_page_header'><a href="#kontekst-imeet-znachenie">10.2.</a> Контекст имеет значение</h4><p>Так как принято использовать колбэк <code>after_commit</code> только при создании, обновлении или удалении, есть псевдонимы для этих операций:</p><ul><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_create_commit"><code>after_create_commit</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_update_commit"><code>after_update_commit</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_destroy_commit"><code>after_destroy_commit</code></a>
</li></ul><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">PictureFile</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">after_destroy_commit</span> <span class="ss">:delete_picture_file_from_disk</span>

  <span class="k">def</span> <span class="nf">delete_picture_file_from_disk</span>
    <span class="k">if</span> <span class="no">File</span><span class="p">.</span><span class="nf">exist?</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
      <span class="no">File</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="warning"><p>Когда завершается транзакция, колбэки <code>after_commit</code> и <code>after_rollback</code> вызываются для всех созданных, обновленных или удаленных моделей внутри транзакции. Однако, если какое-либо исключение вызовется в одном из этих колбэков, это исключение всплывет, и любые оставшиеся методы <code>after_commit</code> или <code>after_rollback</code> <em>не</em> будут выполнены. По сути, если код вашего колбэка может вызвать исключение, нужно для него вызвать rescue, и обработать его в колбэке, чтобы позволить запуститься другим колбэкам.</p></div><div class="warning"><p>Сам код, выполняемый в колбэках <code>after_commit</code> или <code>after_rollback</code>, не замкнут в транзакцию.</p></div><div class="warning"><p>При одновременном использовании <code>after_create_commit</code> и <code>after_update_commit</code> с тем же именем метода, сработает только колбэк, определенный последним, так как они оба являются псевдонимами к <code>after_commit</code>, который переопределяет ранее определенные колбэки с тем же именем метода.</p></div><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">after_create_commit</span> <span class="ss">:log_user_saved_to_db</span>
  <span class="n">after_update_commit</span> <span class="ss">:log_user_saved_to_db</span>

  <span class="kp">private</span>
    <span class="k">def</span> <span class="nf">log_user_saved_to_db</span>
      <span class="nb">puts</span> <span class="s1">'User was saved to database'</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span> <span class="c1"># ничего не выводит</span>
<span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="vi">@user</span><span class="p">.</span><span class="nf">save</span> <span class="c1"># обновление @user</span>
<span class="go">User was saved to database
</span></code></pre>
</div>
<h4 id='after_save_commit' class='inside_page_header'><a href="#after_save_commit">10.3.</a> <code>after_save_commit</code></h4><p>Также имеется <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_save_commit"><code>after_save_commit</code></a>, являющийся псевдонимом для использования колбэком <code>after_commit</code> вместе для создания и обновления:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">after_save_commit</span> <span class="ss">:log_user_saved_to_db</span>

  <span class="kp">private</span>
    <span class="k">def</span> <span class="nf">log_user_saved_to_db</span>
      <span class="nb">puts</span> <span class="s1">'User was saved to database'</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span> <span class="c1"># создание a User</span>
<span class="go">User was saved to database
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="vi">@user</span><span class="p">.</span><span class="nf">save</span> <span class="c1"># обновление @user</span>
<span class="go">User was saved to database
</span></code></pre>
</div>
<h4 id='uporyadochivanie-tranzaktsionnyh-kolbekov' class='inside_page_header'><a href="#uporyadochivanie-tranzaktsionnyh-kolbekov">10.4.</a> Упорядочивание транзакционных колбэков</h4><p>При определении нескольких транзакционных колбэков <code>after_</code> (<code>after_commit</code>, <code>after_rollback</code> и т.д.), порядок будет обратным к тому, как они определены.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">after_commit</span> <span class="p">{</span> <span class="nb">puts</span><span class="p">(</span><span class="s2">"это будет фактически вызвано вторым"</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">after_commit</span> <span class="p">{</span> <span class="nb">puts</span><span class="p">(</span><span class="s2">"это будет фактически вызвано первым"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="note"><p>Это также применяется ко всем вариациям <code>after_*_commit</code>, таким как <code>after_destroy_commit</code>.</p></div>

            <div class="banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

   <!-- bottom rusrails -->
   <ins class="adsbygoogle"
        style="display:inline-block;width:580px;height:400px"
        data-ad-client="ca-pub-7764391801669990"
        data-ad-slot="7566253867"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
          </div>
        </div>
        <div class="row-fluid">
          <div class="span12" id="footer">
            <p>
              <a target="blank" href="https://github.com/rusrails/rusrails"><img src="/assets/github-7cc23602a5ac2465f14c19492358a5a67dc24636761cc723e4d621cea0c09225.png" /></a>
              <a target="blank" href="http://twitter.com/rusrails"><img src="/assets/twitter-50e0e767c8793dec313a7dc5cfbcfe2067e3e89ea6ec64784eb7c6640f578758.png" /></a>
            </p>
            <p>
              <a href="https://creativecommons.org/licenses/by-sa/4.0/">Лицензия CC BY-SA 4.0</a>
              "Rails", "Ruby on Rails" и логотип Rails - торговые марки DHH
              <!-- Yandex.Metrika counter -->
<script>
  (function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter1006929 = new Ya.Metrika({id:1006929,
                    webvisor:true,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>

<noscript>
  <div>
    <img style="position:absolute; left:-9999px;" alt="" src="//mc.yandex.ru/watch/1006929" />
  </div>
</noscript>
<!-- /Yandex.Metrika counter -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-64955373-1', 'auto');
  ga('send', 'pageview');

  var trackOutboundLink = function(url) {
    ga('send', 'event', 'outbound', 'click', url, {
      'transport': 'beacon',
      'hitCallback': function(){ }
    });
  }
</script>

            </p>
          </div>
        </div>
      </div>
    </div>
    <div class="to_top" style="display: block">
      <div class="to_top_panel"></div>
    </div>
    <script src="/assets/application-8ee447905888b153d8458707061a14b1f15f69b6733e871a3ad91d80ae89e87b.js"></script>
  </body>
</html>
