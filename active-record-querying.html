<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8">
<meta content="Ruby on Rails, Ruby, Rails, Rails 3, Rails 4, Rails 5, Rails 6, Rails 6.0, Rails 6.1, Rails 7.0, Rails 7.1 руководство, начинающим, самоучитель, manual, мануал, справочник, учебник, примеры, Руби, рельсы" name="keywords"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" name="description"/>
<meta content="product" property="twitter:card"/>
<meta content="@rusrails" property="twitter:site"/>
<meta content="Rusrails: Интерфейс запросов Active Record" property="twitter:title"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" property="twitter:description"/>
<meta content="@rusrails" property="twitter:creator"/>
<meta content="http://rusrails.ru/assets/rusrails.png" property="twitter:image"/>
<meta content="website" property="og:type"/>
<meta content="Rusrails: Интерфейс запросов Active Record" property="og:title"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" property="og:description"/>
<meta content="http://localhost:3000/active-record-querying" property="og:url"/>
<meta content="http://rusrails.ru/assets/rusrails.png" property="og:image"/>
    <title>
      Rusrails: Интерфейс запросов Active Record
    </title>
    <link rel="stylesheet" media="screen" href="/assets/application-4f65588939909a694017a295c9ca934821f6a6358454c26c5360579d7ee0054d.css" />
    <meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="GMEYEmktdEjes0vl7nAfxNpbBkE45rTSrScr7p0rIy5H16f9KonsNSYLjWe2rCjbUBbi8a3fR+m6qW01+Owsdw==" />
  </head>
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="brand" href="/"></a>
          <script async src="https://cse.google.com/cse.js?cx=4152266ab1c5e41d8"></script>
          <div class="gcse-search navbar-search pull-right"></div>
          <ul class="nav pull-right top-menu">
            <li>
              <a href="/">Главная</a>
            </li>
            <li class="dropdown">
              <a class="index-popover" href="#">
                Содержание
                <b class="caret"></b>
</a>              <div class="index-popover-content hide">
                  <ul><li><p><strong>С чего начать?</strong></p><ul><li><a href="/getting-started">Rails для начинающих</a>
</li></ul></li><li><p><strong>Модели</strong></p><ul><li><a href="/active-record-basics">Основы Active Record</a>
</li><li><a href="/active-record-migrations">Миграции Active Record</a>
</li><li><a href="/active-record-validations">Валидации Active Record</a>
</li><li><a href="/active-record-callbacks">Колбэки Active Record</a>
</li><li><a href="/active-record-associations">Связи (ассоциации) Active Record</a>
</li><li><a href="/active-record-querying">Интерфейс запросов Active Record</a>
</li><li><a href="/active-model-basics">Основы Active Model</a>
</li></ul></li><li><p><strong>Вью</strong></p><ul><li><a href="/action-view-overview">Обзор Action View</a>
</li><li><a href="/layouts-and-rendering">Макеты и рендеринг в Rails</a>
</li><li><a href="/action-view-helpers">Хелперы Action View</a>
</li><li><a href="/form-helpers">Хелперы форм в Action View</a>
</li></ul></li><li><p><strong>Контроллеры</strong></p><ul><li><a href="/action-controller-overview">Обзор Action Controller</a>
</li><li><a href="/routing">Роутинг в Rails</a>
</li></ul></li><li><p><strong>Другие компоненты</strong></p><ul><li><a href="/active-support-core-extensions">Расширения ядра Active Support</a>
</li><li><a href="/action-mailer-basics">Основы Action Mailer</a>
</li><li><a href="/action-mailbox-basics">Основы Action Mailbox</a>
</li><li><a href="/action-text-overview">Обзор Action Text</a>
</li><li><a href="/active_job_basics">Основы Active Job</a>
</li><li><a href="/active_storage_overview">Обзор Active Storage</a>
</li><li><a href="/action-cable-overview">Обзор Action Cable</a>
</li></ul></li><li><p><strong>Копаем глубже</strong></p><ul><li><a href="/i18n">API интернационализации Rails (I18n)</a>
</li><li><a href="/testing">Тестирование приложений на Rails</a>
</li><li><a href="/security">Безопасность приложений на Rails</a>
</li><li><a href="/error-reporting">Отчет об ошибках в приложениях Rails</a>
</li></ul></li></ul><p>next_column</p><ul><li><p><strong>Копаем глубже</strong></p><ul><li><a href="/debugging-rails-applications">Отладка приложений на Rails</a>
</li><li><a href="/configuring">Конфигурирование приложений на Rails</a>
</li><li><a href="/command-line">Командная строка Rails</a>
</li><li><a href="/asset-pipeline">Asset Pipeline</a>
</li><li><a href="/working-with-javascript-in-rails">Работа с JavaScript в Rails</a>
</li><li><a href="/initialization">Процесс инициализации в Rails</a>
</li><li><a href="/autoloading-and-reloading-constants">Автозагрузка и перезагрузка констант</a>
</li><li><a href="/classic-to-zeitwerk-howto">Как перейти с Classic на Zeitwerk</a>
</li><li><a href="/caching-with-rails">Кэширование с Rails: Обзор</a>
</li><li><a href="/active-support-instrumentation">Инструментарий Active Support</a>
</li><li><a href="/api-app">Использование Rails для API-приложений</a>
</li><li><a href="/active-record-postgresql">Active Record для PostgreSQL</a>
</li><li><a href="/active-record-multiple-databases">Несколько баз данных с Active Record</a>
</li><li><a href="/active-record-encryption">Шифрование Active Record</a>
</li></ul></li><li><p><strong>Расширяем Rails</strong></p><ul><li><a href="/plugins">Основы создания плагинов Rails</a>
</li><li><a href="/rails-on-rack">Rails on Rack</a>
</li><li><a href="/generators">Создание и настройка генераторов и шаблонов Rails</a>
</li><li><a href="/engines">Engine для начинающих</a>
</li><li><a href="/threading_and_code_execution">Треды и выполнение кода в Rails</a>
</li><li><a href="/rails-application-templates">Шаблоны приложения Rails</a>
</li></ul></li><li><p><strong>Вносим вклад в Ruby on Rails</strong></p><ul><li><a href="/contributing_to_ruby_on_rails">Вносим вклад в Ruby on Rails</a>
</li><li><a href="/api_documentation_guidelines">Рекомендации по документированию API</a>
</li><li><a href="/ruby_on_rails_guides_guidelines">Рекомендации для руководств по Ruby on Rails</a>
</li><li><a href="/development_dependencies_install">Установка зависимостей для разработки</a>
</li><li><a href="/maintenance-policy">Политика поддержки (версий)</a>
</li></ul></li><li><p><strong>Заметки о релизах</strong></p><ul><li><a href="/upgrading-ruby-on-rails">Апгрейд Ruby on Rails</a>
</li><li><a href="/7_1_release_notes">Версия 7.1 - ?</a>
</li><li><a href="/7_0_release_notes">Версия 7.0 - Декабрь 2021</a>
</li><li><a href="/6_1_release_notes">Версия 6.1 - Декабрь 2020</a>
</li><li><a href="/6_0_release_notes">Версия 6.0 - Август 2019</a>
</li></ul></li></ul>
              </div>
            </li>
            <li>
              <a target="blank" href="http://api.rusrails.ru">Ruby &amp; Rails API</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content-wrapper">
      <div class="container-fluid">
        <div class="row-fluid">
          <div class="span3 pull-right">
            <div class="well social">
              <h4>Принимаем пожелания и пул-реквесты!</h4>
              <iframe allowtransparency="true" frameborder="0" height="30" src="http://ghbtns.com/github-btn.html?user=rusrails&repo=rusrails&type=watch&count=true&size=large" width="180"></iframe>
              <p></p>
              <a class="twitter-follow-button" data-lang="ru" href="https://twitter.com/rusrails"></a>
            </div>
              <div class="well menu">
                    <ul class="nav nav-list">
      <li>
        <h4>
          <a href="#chto-takoe-interfeys-zaprosov-active-record">1. Что такое интерфейс запросов Active Record?</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#poluchenie-ob-ektov-iz-bazy-dannyh">2. Получение объектов из базы данных</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#poluchenie-odinochnogo-ob-ekta">2.1. Получение одиночного объекта</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#find">2.1.1. <code>find</code></a>
</h6>      </li>
      <li>
        <h6>
          <a href="#take">2.1.2. <code>take</code></a>
</h6>      </li>
      <li>
        <h6>
          <a href="#first">2.1.3. <code>first</code></a>
</h6>      </li>
      <li>
        <h6>
          <a href="#last">2.1.4. <code>last</code></a>
</h6>      </li>
      <li>
        <h6>
          <a href="#find_by">2.1.5. <code>find_by</code></a>
</h6>      </li>
      <li>
        <h5>
          <a href="#poluchenie-neskolkih-ob-ektov-paketami">2.2. Получение нескольких объектов пакетами</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#find_each">2.2.1. <code>find_each</code></a>
</h6>      </li>
      <li>
        <h7>
          <a href="#optsii-dlya-find_each">2.2.1.1. Опции для <code>find_each</code></a>
</h7>      </li>
      <li>
        <h6>
          <a href="#find_in_batches">2.2.2. <code>find_in_batches</code></a>
</h6>      </li>
      <li>
        <h7>
          <a href="#optsii-dlya-find_in_batches">2.2.2.1. Опции для <code>find_in_batches</code></a>
</h7>      </li>
      <li>
        <h4>
          <a href="#usloviya">3. Условия</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#pure-string-conditions">3.1.  Чисто строковые условия</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#array-conditions">3.2.  Условия с использованием массива</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#mestozapolniteli-v-usloviyah">3.2.1. Местозаполнители в условиях</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#usloviya-s-ispolzovaniem-like">3.2.2. Условия с использованием <code>LIKE</code></a>
</h6>      </li>
      <li>
        <h5>
          <a href="#hash-conditions">3.3.  Условия с использованием хэша</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#usloviya-ravenstva">3.3.1. Условия равенства</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#intervalnye-usloviya">3.3.2. Интервальные условия</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#usloviya-podmnozhestva">3.3.3. Условия подмножества</a>
</h6>      </li>
      <li>
        <h5>
          <a href="#usloviya-not">3.4. Условия NOT</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#usloviya-or">3.5. Условия OR</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#usloviya-and">3.6. Условия AND</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#ordering">4.  Упорядочивание</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#vybor-opredelennyh-poley">5. Выбор определенных полей</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#ogranichenie-i-smeschenie">6. Ограничение и смещение</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#gruppirovka">7. Группировка</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#obschee-kolichestvo-sgruppirovannyh-elementov">7.1. Общее количество сгруппированных элементов</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#usloviya-having">8. Условия HAVING</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#pereopredelyayuschie-usloviya">9. Переопределяющие условия</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#unscope">9.1. <code>unscope</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#only">9.2. <code>only</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#reselect">9.3. <code>reselect</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#reorder">9.4. <code>reorder</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#reverse_order">9.5. <code>reverse_order</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#rewhere">9.6. <code>rewhere</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#regroup">9.7. <code>regroup</code></a>
</h5>      </li>
      <li>
        <h4>
          <a href="#nulevoy-relation">10. Нулевой Relation</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#ob-ekty-tolko-dlya-chteniya">11. Объекты только для чтения</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#blokirovka-zapisey-dlya-obnovleniya">12. Блокировка записей для обновления</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#optimisticheskaya-blokirovka">12.1. Оптимистическая блокировка</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#pessimisticheskaya-blokirovka">12.2. Пессимистическая блокировка</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#joining-tables">13.  Соединительные таблицы</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#joins">13.1. <code>joins</code></a>
</h5>      </li>
      <li>
        <h6>
          <a href="#ispolzovanie-strokovogo-fragmenta-sql">13.1.1. Использование строкового фрагмента SQL</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#ispolzovanie-massiva-hesha-imenovannyh-svyazey">13.1.2. Использование массива/хэша именованных связей</a>
</h6>      </li>
      <li>
        <h7>
          <a href="#soedinenie-odinochnoy-svyazi">13.1.2.1. Соединение одиночной связи</a>
</h7>      </li>
      <li>
        <h6>
          <a href="#soedinenie-neskolkih-svyazey">13.1.3. Соединение нескольких связей</a>
</h6>      </li>
      <li>
        <h7>
          <a href="#soedinenie-vlozhennyh-svyazey-odnogo-urovnya">13.1.3.1. Соединение вложенных связей (одного уровня)</a>
</h7>      </li>
      <li>
        <h7>
          <a href="#soedinenie-vlozhennyh-svyazey-raznyh-urovney">13.1.3.2. Соединение вложенных связей (разных уровней)</a>
</h7>      </li>
      <li>
        <h6>
          <a href="#opredelenie-usloviy-v-soedinitelnyh-tablitsah">13.1.4. Определение условий в соединительных таблицах</a>
</h6>      </li>
      <li>
        <h5>
          <a href="#left_outer_joins">13.2. <code>left_outer_joins</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#where-associated-i-where-missing">13.3. <code>where.associated</code> и <code>where.missing</code></a>
</h5>      </li>
      <li>
        <h4>
          <a href="#neterpelivaya-zagruzka-svyazey">14. Нетерпеливая загрузка связей</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#problema-n-1-zaprosa">14.1. Проблема N + 1 запроса</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#reshenie-problemy-n-1-zaprosa">14.1.1. Решение проблемы N + 1 запроса</a>
</h6>      </li>
      <li>
        <h5>
          <a href="#includes">14.2. <code>includes</code></a>
</h5>      </li>
      <li>
        <h6>
          <a href="#neterpelivaya-zagruzka-neskolkih-svyazey">14.2.1. Нетерпеливая загрузка нескольких связей</a>
</h6>      </li>
      <li>
        <h7>
          <a href="#massiv-neskolkih-svyazey">14.2.1.1. Массив нескольких связей</a>
</h7>      </li>
      <li>
        <h7>
          <a href="#vlozhennyy-hesh-svyazey">14.2.1.2. Вложенный хэш связей</a>
</h7>      </li>
      <li>
        <h6>
          <a href="#opredelenie-usloviy-dlya-neterpelivoy-zagruzki-svyazey">14.2.2. Определение условий для нетерпеливой загрузки связей</a>
</h6>      </li>
      <li>
        <h5>
          <a href="#preload">14.3. <code>preload</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#eager_load">14.4. <code>eager_load</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#strict_loading">14.5. <code>strict_loading</code></a>
</h5>      </li>
      <li>
        <h4>
          <a href="#scopes">15.  Скоупы</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#peredacha-argumenta">15.1. Передача аргумента</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#ispolzovanie-usloviy">15.2. Использование условий</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#applying-a-default-scope">15.3.  Применение скоупа по умолчанию</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#ob-edinenie-skoupov">15.4. Объединение скоупов</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#udalenie-vseh-skoupov">15.5. Удаление всех скоупов</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#dynamic-finders">16.  Динамический поиск</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#perechislenie">17. Перечисление</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#method-chaining">18.  Понимание цепочек методов</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#poluchenie-otfiltrovannyh-dannyh-iz-neskolkih-tablits">18.1. Получение отфильтрованных данных из нескольких таблиц</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#poluchenie-opredelyonnyh-dannyh-iz-neskolkih-tablits">18.2. Получение определённых данных из нескольких таблиц</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#poisk-ili-sozdanie-novogo-ob-ekta">19. Поиск или создание нового объекта</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#find_or_create_by">19.1. <code>find_or_create_by</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#find_or_create_by2">19.2. <code>find_or_create_by!</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#find_or_initialize_by">19.3. <code>find_or_initialize_by</code></a>
</h5>      </li>
      <li>
        <h4>
          <a href="#poisk-s-pomoschyu-sql">20. Поиск с помощью SQL</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#select_all">20.1. <code>select_all</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#pluck">20.2. <code>pluck</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#pick">20.3. <code>pick</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#ids">20.4. <code>ids</code></a>
</h5>      </li>
      <li>
        <h4>
          <a href="#suschestvovanie-ob-ektov">21. Существование объектов</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#calculations">22.  Вычисления</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#count">22.1. <code>count</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#average">22.2. <code>average</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#minimum">22.3. <code>minimum</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#maximum">22.4. <code>maximum</code></a>
</h5>      </li>
      <li>
        <h5>
          <a href="#sum">22.5. <code>sum</code></a>
</h5>      </li>
      <li>
        <h4>
          <a href="#zapusk-explain">23. Запуск EXPLAIN</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#optsii-explain">23.1. Опции Explain</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#interpretatsiya-explain">23.2. Интерпретация EXPLAIN</a>
</h5>      </li>
</ul>

              </div>
            <div class="well banner300 banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<!-- sidebar rusrails -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-7764391801669990"
     data-ad-slot="6089520660"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
          </div>
          <div class="span9 content pull-left">
            <div class="banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <!-- top rusrails -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:980px;height:120px"
       data-ad-client="ca-pub-7764391801669990"
       data-ad-slot="4891989065"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
              <h2 id='interfeys-zaprosov-active-record' class='inside_page_header'> Интерфейс запросов Active Record</h2><p>Это руководство раскрывает различные способы получения данных из базы данных, используя Active Record.</p><p>После его прочтения, вы узнаете:</p><ul><li>Как искать записи, используя различные методы и условия.
</li><li>Как определять порядок, получаемые атрибуты, группировку и другие свойства поиска записей.
</li><li>Как использовать нетерпеливую загрузку (eager loading) для уменьшения числа запросов к базе данных, необходимых для получения данных.
</li><li>Как использовать методы динамического поиска.
</li><li>Как использовать цепочки методов (method chaining), для использования нескольких методов Active Record одновременно.
</li><li>Как проверять существование отдельных записей.
</li><li>Как выполнять различные вычисления в моделях Active Record.
</li><li>Как запускать EXPLAIN на relations.
</li></ul><h3 id='chto-takoe-interfeys-zaprosov-active-record' class='inside_page_header'><a href="#chto-takoe-interfeys-zaprosov-active-record">1.</a> Что такое интерфейс запросов Active Record?</h3><p>Если вы использовали чистый SQL для поиска записей в базе данных, то скорее всего обнаружите, что в Rails есть лучшие способы выполнения тех же операций. Active Record ограждает вас от необходимости использования SQL во многих случаях.</p><p>Active Record выполнит запросы в базу данных за вас, он совместим с большинством СУБД, включая MySQL, MariaDB, PostgreSQL и SQLite. Независимо от того, какая используется СУБД, формат методов Active Record будет всегда одинаковый.</p><p>Примеры кода далее в этом руководстве будут относиться к некоторым из этих моделей:</p><div class="info"><p>Все модели используют <code>id</code> как первичный ключ, если не указано иное.</p></div><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Author</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="ss">year_published: :desc</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:supplier</span>
  <span class="n">belongs_to</span> <span class="ss">:author</span>
  <span class="n">has_many</span> <span class="ss">:reviews</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">join_table: </span><span class="s1">'books_orders'</span>

  <span class="n">scope</span> <span class="ss">:in_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:old</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="o">...</span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print_and_expensive</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">out_of_print</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'price &gt; 500'</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:costs_more_than</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s1">'price &gt; ?'</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
  <span class="n">has_many</span> <span class="ss">:reviews</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="ss">join_table: </span><span class="s1">'books_orders'</span>

  <span class="n">enum</span> <span class="ss">:status</span><span class="p">,</span> <span class="p">[</span><span class="ss">:shipped</span><span class="p">,</span> <span class="ss">:being_packed</span><span class="p">,</span> <span class="ss">:complete</span><span class="p">,</span> <span class="ss">:cancelled</span><span class="p">]</span>

  <span class="n">scope</span> <span class="ss">:created_before</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="o">...</span><span class="n">time</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Review</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">belongs_to</span> <span class="ss">:book</span>

  <span class="n">enum</span> <span class="ss">:state</span><span class="p">,</span> <span class="p">[</span><span class="ss">:not_reviewed</span><span class="p">,</span> <span class="ss">:published</span><span class="p">,</span> <span class="ss">:hidden</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span>
  <span class="n">has_many</span> <span class="ss">:authors</span><span class="p">,</span> <span class="ss">through: :books</span>
<span class="k">end</span>
</code></pre>
</div>
<p><img src='/assets/active_record_querying/bookstore_models-88aeeaf2f9f4a1f5d8b9bd26825102b7749b7691c73761814b04c93963037f4d.png' title='' alt='Диаграмма всех моделей книжного магазина' class='img-polaroid' /></p><h3 id='poluchenie-ob-ektov-iz-bazy-dannyh' class='inside_page_header'><a href="#poluchenie-ob-ektov-iz-bazy-dannyh">2.</a> Получение объектов из базы данных</h3><p>Для получения объектов из базы данных Active Record предоставляет несколько методов поиска. В каждый метод поиска можно передавать аргументы для выполнения определенных запросов в базу данных без необходимости писать на чистом SQL.</p><p>Методы следующие:</p><ul><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-annotate"><code>annotate</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find"><code>find</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-create_with"><code>create_with</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-distinct"><code>distinct</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-eager_load"><code>eager_load</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-extending"><code>extending</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-extract_associated"><code>extract_associated</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-from"><code>from</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-group"><code>group</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-having"><code>having</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-includes"><code>includes</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-joins"><code>joins</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins"><code>left_outer_joins</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-limit"><code>limit</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-lock"><code>lock</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-none"><code>none</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-offset"><code>offset</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-optimizer_hints"><code>optimizer_hints</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-order"><code>order</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-preload"><code>preload</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-readonly"><code>readonly</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-references"><code>references</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reorder"><code>reorder</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reselect"><code>reselect</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-regroup"><code>regroup</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reverse_order"><code>reverse_order</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-select"><code>select</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-where"><code>where</code></a>
</li></ul><p>Методы поиска, возвращающие коллекцию, такие как <code>where</code> и <code>group</code>, возвращают экземпляр <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html"><code>ActiveRecord::Relation</code></a>. Методы, ищущие отдельную сущность, такие как <code>find</code> и <code>first</code>, возвращают отдельный экземпляр модели.</p><p>Вкратце основные операции <code>Model.find(options)</code> таковы:</p><ul><li>Преобразовать предоставленные опции в эквивалентный запрос SQL.
</li><li>Выполнить запрос SQL и получить соответствующие результаты из базы данных.
</li><li>Создать экземпляр эквивалентного объекта Ruby подходящей модели для каждой строки результата запроса.
</li><li>Запустить колбэки <code>after_find</code> и далее <code>after_initialize</code>, если таковые имеются.
</li></ul><h4 id='poluchenie-odinochnogo-ob-ekta' class='inside_page_header'><a href="#poluchenie-odinochnogo-ob-ekta">2.1.</a> Получение одиночного объекта</h4><p>Active Record предоставляет несколько различных способов получения одиночного объекта.</p><h5 id='find' class='inside_page_header'><a href="#find">2.1.1.</a> <code>find</code></h5><p>Используя метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find"><code>find</code></a>, можно получить объект, соответствующий определенному первичному ключу (<em>primary key</em>) и предоставленным опциям. Например:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="c"># Найдем покупателя с первичным ключом (id) 10.
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">10</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Ryan"</span><span class="kt">&gt;</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
</div>
<p>Метод <code>find</code> вызывает исключение <code>ActiveRecord::RecordNotFound</code>, если соответствующей записи не было найдено.</p><p>Этот метод также можно использовать для получения нескольких объектов. Вызовите метод <code>find</code> и передайте в него массив первичных ключей. Возвращенным результатом будет массив, содержащий все записи, соответствующие представленным <em>первичным ключам</em>. Например:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="c"># Найдем покупателей с первичными ключами 1 и 10.
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span> <span class="c1"># OR Customer.find(1, 10)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Lifo"</span><span class="kt">&gt;</span><span class="p">,</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">10</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Ryan"</span><span class="kt">&gt;</span><span class="p">]</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
</code></pre>
</div>
<h5 id='take' class='inside_page_header'><a href="#take">2.1.2.</a> <code>take</code></h5><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-take"><code>take</code></a> извлекает запись без какого-либо явного упорядочивания. Например:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">take</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Lifo"</span><span class="kt">&gt;</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
</div>
<p>Метод <code>take</code> возвращает <code>nil</code>, если ни одной записи не найдено, и исключение не будет вызвано.</p><p>В метод <code>take</code> можно передать числовой аргумент, чтобы вернуть это количество результатов. Например</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Lifo"</span><span class="kt">&gt;</span><span class="p">,</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">220</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Sara"</span><span class="kt">&gt;</span><span class="p">]</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">2</span>
</code></pre>
</div>
<p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-take-21"><code>take!</code></a> ведет себя подобно <code>take</code>, за исключением того, что он вызовет <code>ActiveRecord::RecordNotFound</code>, если не найдено ни одной соответствующей записи.</p><div class="info"><p>Получаемая запись может отличаться в зависимости от подсистемы хранения СУБД.</p></div><h5 id='first' class='inside_page_header'><a href="#first">2.1.3.</a> <code>first</code></h5><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-first"><code>first</code></a> находит первую запись, упорядоченную по первичному ключу (по умолчанию). Например:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">first</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Lifo"</span><span class="kt">&gt;</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
</div>
<p>Метод <code>first</code> возвращает <code>nil</code>, если не найдено соответствующей записи, и исключение не вызывается.</p><p>Если <a href="#applying-a-default-scope">скоуп по умолчанию</a> содержит метод order, <code>first</code> возвратит первую запись в соответствии с этим упорядочиванием.</p><p>В метод <code>first</code> можно передать числовой аргумент, чтобы вернуть это количество результатов. Например</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Lifo"</span><span class="kt">&gt;</span><span class="p">,</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Fifo"</span><span class="kt">&gt;</span><span class="p">,</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">3</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Filo"</span><span class="kt">&gt;</span><span class="p">]</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">3</span>
</code></pre>
</div>
<p>На коллекции, упорядоченной с помощью <code>order</code>, <code>first</code> вернет первую запись, упорядоченную по указанному в <code>order</code> атрибуту.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">first</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Fifo"</span><span class="kt">&gt;</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
</div>
<p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-first-21"><code>first!</code></a> ведет себя подобно <code>first</code>, за исключением того, что он вызовет <code>ActiveRecord::RecordNotFound</code>, если не найдено ни одной соответствующей записи.</p><h5 id='last' class='inside_page_header'><a href="#last">2.1.4.</a> <code>last</code></h5><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-last"><code>last</code></a> находит последнюю запись, упорядоченную по первичному ключу (по умолчанию). Например:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">last</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">221</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Russel"</span><span class="kt">&gt;</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
</div>
<p>Метод <code>last</code> возвращает <code>nil</code>, если не найдено соответствующей записи, и исключение не вызывается.</p><p>Если <a href="#applying-a-default-scope">скоуп по умолчанию</a> содержит метод order, <code>last</code> возвратит последнюю запись в соответствии с этим упорядочиванием.</p><p>В метод <code>last</code> можно передать числовой аргумент, чтобы вернуть это количество результатов. Например</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">last</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">219</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"James"</span><span class="kt">&gt;</span><span class="p">,</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">220</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Sara"</span><span class="kt">&gt;</span><span class="p">,</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">221</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Russel"</span><span class="kt">&gt;</span><span class="p">]</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">3</span>
</code></pre>
</div>
<p>На коллекции, упорядоченной с помощью <code>order</code>, <code>last</code> вернет последнюю запись, упорядоченную по указанному в <code>order</code> атрибуту.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">last</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">220</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Sara"</span><span class="kt">&gt;</span>
</code></pre>
</div>
<p>SQL эквивалент этого такой:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
</div>
<p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-last-21"><code>last!</code></a> ведет себя подобно <code>last</code>, за исключением того, что он вызовет <code>ActiveRecord::RecordNotFound</code>, если не найдено ни одной соответствующей записи.</p><h5 id='find_by' class='inside_page_header'><a href="#find_by">2.1.5.</a> <code>find_by</code></h5><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find_by"><code>find_by</code></a> ищет первую запись, соответствующую некоторым условиям. Например:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by</span> <span class="ss">first_name: </span><span class="s1">'Lifo'</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Lifo"</span><span class="kt">&gt;</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by</span> <span class="ss">first_name: </span><span class="s1">'Jon'</span>
<span class="p">=&gt;</span> <span class="kp">nil</span>
</code></pre>
</div>
<p>Это эквивалент записи:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Lifo'</span><span class="p">).</span><span class="nf">take</span>
</code></pre>
</div>
<p>SQL эквивалент выражения выше, следующий:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Lifo'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
</div>
<p>Отметьте, что в вышеприведенном SQL нет <code>ORDER BY</code>. Если вашим условиям <code>find_by</code> могут соответствовать несколько записей, следует <a href="#ordering">применить упорядочивание</a>, чтобы гарантировать детерминированный результат.</p><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find_by-21"><code>find_by!</code></a> ведет себя подобно <code>find_by</code>, за исключением того, что он вызовет <code>ActiveRecord::RecordNotFound</code>, если не найдено ни одной соответствующей записи. Например:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by!</span> <span class="ss">first_name: </span><span class="s1">'does not exist'</span>
<span class="go">ActiveRecord::RecordNotFound
</span></code></pre>
</div>
<p>Это эквивалент записи:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'does not exist'</span><span class="p">).</span><span class="nf">take!</span>
</code></pre>
</div>
<h4 id='poluchenie-neskolkih-ob-ektov-paketami' class='inside_page_header'><a href="#poluchenie-neskolkih-ob-ektov-paketami">2.2.</a> Получение нескольких объектов пакетами</h4><p>Часто необходимо перебрать огромный набор записей, например, когда рассылаем письма всем покупателям или импортируем некоторые данные.</p><p>Это может показаться простым:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Это может потребить слишком много памяти, если таблица большая.</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Но этот подход становится очень непрактичным с увеличением размера таблицы, поскольку <code>Customer.all.each</code> говорит Active Record извлечь <em>таблицу полностью</em> за один проход, создать объект модели для каждой строки и держать этот массив в памяти. В реальности, если имеется огромное количество записей, полная коллекция может превысить количество доступной памяти.</p><p>Rails предоставляет два метода, которые решают эту проблему путем разделения записей на дружелюбные к памяти пакеты для обработки. Первый метод, <code>find_each</code>, получает пакет записей и затем вкладывает <em>каждую</em> запись в блок отдельно как модель. Второй метод, <code>find_in_batches</code>, получает пакет записей и затем вкладывает <em>весь пакет</em> в блок как массив моделей.</p><div class="info"><p>Методы <code>find_each</code> и <code>find_in_batches</code> предназначены для пакетной обработки большого числа записей, которые не поместятся в памяти за раз. Если нужно просто перебрать тысячу записей, более предпочтителен вариант обычных методов поиска.</p></div><h5 id='find_each' class='inside_page_header'><a href="#find_each">2.2.1.</a> <code>find_each</code></h5><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Batches.html#method-i-find_each"><code>find_each</code></a> получает пакет записей и затем передает <em>каждую</em> запись в блок. В следующем примере <code>find_each</code> получает покупателей пакетами по 1000 записей, а затем передает их в блок один за другим:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Этот процесс повторяется, извлекая больше пакетов при необходимости, пока не будут обработаны все записи.</p><p><code>find_each</code> работает на классах модели, как показано выше, а также на relation:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">weekly_subscriber: </span><span class="kp">true</span><span class="p">).</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
</div>
<p>только у них нет упорядочивания, так как методу необходимо собственное упорядочивание для работы.</p><p>Если у получателя есть упорядочивание, то поведение зависит от флажка <a href="/configuring#config-active-record-error-on-ignored-order"><code>config.active_record.error_on_ignored_order</code></a>. Если true, вызывается <code>ArgumentError</code>, в противном случае упорядочивание игнорируется, что является поведением по умолчанию. Это можно переопределить с помощью опции <code>:error_on_ignore</code>, описанной ниже.</p><h6 id='optsii-dlya-find_each' class='inside_page_header'><a href="#optsii-dlya-find_each">2.2.1.1.</a> Опции для <code>find_each</code></h6><p><strong><code>:batch_size</code></strong></p><p>Опция <code>:batch_size</code> позволяет определить число записей, подлежащих получению в одном пакете, до передачи отдельной записи в блок. Например, для получения 5000 записей в пакете:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">5000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
</div>
<p><strong><code>:start</code></strong></p><p>По умолчанию записи извлекаются в порядке увеличения первичного ключа. Опция <code>:start</code> позволяет вам настроить первый ID последовательности, когда наименьший ID не тот, что вам нужен. Это может быть полезно, например, если хотите возобновить прерванный процесс пакетирования, предоставив последний обработанный ID как контрольную точку.</p><p>Например, чтобы выслать письма только покупателям с первичным ключом, начинающимся от 2000:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">start: </span><span class="mi">2000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
</div>
<p><strong><code>:finish</code></strong></p><p>Подобно опции <code>:start</code>, <code>:finish</code> позволяет указать последний ID последовательности, когда наибольший ID не тот, что вам нужен.
Это может быть полезно, например, если хотите запустить процесс пакетирования, используя подмножество записей на основании <code>:start</code> и <code>:finish</code></p><p>Например, чтобы выслать письма только покупателям с первичным ключом от 2000 до 10000:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">start: </span><span class="mi">2000</span><span class="p">,</span> <span class="ss">finish: </span><span class="mi">10000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Другим примером является наличие нескольких воркеров, работающих с одной и той же очередью обработки. Можно было бы обрабатывать каждым воркером 10000 записей, установив подходящие опции <code>:start</code> и <code>:finish</code> в каждом воркере.</p><p><strong><code>:error_on_ignore</code></strong></p><p>Переопределяет настройку приложения, указывающую, должна ли быть вызвана ошибка, если в relation присутствует упорядочивание.</p><p><strong><code>:order</code></strong></p><p>Указывает порядок следования первичных ключей (может быть <code>:asc</code> или <code>:desc</code>). По умолчанию <code>:asc</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">order: :desc</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
</div>
<h5 id='find_in_batches' class='inside_page_header'><a href="#find_in_batches">2.2.2.</a> <code>find_in_batches</code></h5><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Batches.html#method-i-find_in_batches"><code>find_in_batches</code></a> похож на <code>find_each</code> тем, что они оба получают пакеты записей. Различие в том, что <code>find_in_batches</code> передает в блок <em>пакеты</em> как массив моделей, вместо отдельной модели. Следующий пример передаст в представленный блок массив из 1000 счетов за раз, а в последний блок содержащий всех оставшихся покупателей:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Передает в add_customers массив из 1000 покупателей за раз.</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p><code>find_in_batches</code> работает на классах модели, как показано выше, а также на relation:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Передает в add_customers массив из 1000 недавно активных покупателей за раз.</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">recently_active</span><span class="p">.</span><span class="nf">find_in_batches</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p>только у них нет упорядочивания, так как методу необходимо собственное упорядочивание для работы.</p><h6 id='optsii-dlya-find_in_batches' class='inside_page_header'><a href="#optsii-dlya-find_in_batches">2.2.2.1.</a> Опции для <code>find_in_batches</code></h6><p>Метод <code>find_in_batches</code> принимает те же опции, что и <code>find_each</code>:</p><p><strong><code>:batch_size</code></strong></p><p>Как и для <code>find_each</code>, <code>batch_size</code> устанавливает, сколько записей будет извлечено в каждой группе. Например, получение пакетов по 2500 записей может быть определено как:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">2500</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p><strong><code>:start</code></strong></p><p>Опция <code>:start</code> позволяет вам указать начальный ID, начиная с которого будут выбраны записи. Как уже упоминалось, по умолчанию записи извлекаются по возрастанию первичного ключа. Например, чтобы получить покупателей начиная с ID: 5000 пакетами по 2500 записей, можно использовать следующий код:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">2500</span><span class="p">,</span> <span class="ss">start: </span><span class="mi">5000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p><strong><code>:finish</code></strong></p><p>Опция <code>finish</code> позволяет указать последний ID записей для извлечения. Нижеследующий код показывает случай извлечения покупателей пакетами до покупателя с ID: 7000:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span><span class="p">(</span><span class="ss">finish: </span><span class="mi">7000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p><strong><code>:error_on_ignore</code></strong></p><p>Опция <code>error_on_ignore</code> переопределяет настройку приложения, указывающую, должна ли быть вызвана ошибка, если в relation присутствует упорядочивание.</p><h3 id='usloviya' class='inside_page_header'><a href="#usloviya">3.</a> Условия</h3><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-where"><code>where</code></a> позволяет определить условия для ограничения возвращаемых записей, которые представляют <code>WHERE</code>-часть выражения SQL. Условия могут быть заданы как строка, массив или хэш.</p><h4 id='pure-string-conditions' class='inside_page_header'><a href="#pure-string-conditions">3.1.</a>  Чисто строковые условия</h4><p>Если вы хотите добавить условия в свой поиск, можете просто определить их там, подобно <code>Book.where(&quot;title = &#39;Introduction to Algorithms&#39;&quot;)</code>. Это найдет все книги, где значение поля <code>title</code> равно &#39;Introduction to Algorithms&#39;.</p><div class="warning"><p>Создание условий в чистой строке подвергает вас риску SQL-инъекций. Например, <code>Book.where(&quot;title LIKE &#39;%#{params[:title]}%&#39;&quot;)</code> не безопасно. Смотрите следующий раздел для более предпочтительного способа обработки условий с использованием массива.</p></div><h4 id='array-conditions' class='inside_page_header'><a href="#array-conditions">3.2.</a>  Условия с использованием массива</h4><p>Что если заголовок может быть задан, скажем, как аргумент откуда-то извне? Поиск тогда принимает такую форму:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">])</span>
</code></pre>
</div>
<p>Active Record примет первый аргумент в качестве строки условия, а все остальные элементы подставит вместо знаков вопроса <code>(?)</code> в ней.</p><p>Если хотите определить несколько условий:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = ? AND out_of_print = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">],</span> <span class="kp">false</span><span class="p">)</span>
</code></pre>
</div>
<p>В этом примере первый знак вопроса будет заменен на значение в <code>params[:title]</code> и второй будет заменен SQL аналогом <code>false</code>, который зависит от адаптера.</p><p>Этот код значительно предпочтительнее:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">])</span>
</code></pre>
</div>
<p>чем такой код:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
</div>
<p>по причине безопасности аргумента. Помещение переменной прямо в строку условий передает переменную в базу данных <em>как есть</em>. Это означает, что неэкранированная переменная, переданная пользователем, может иметь злой умысел. Если так сделать, вы подвергаете базу данных риску, так как если пользователь обнаружит, что он может использовать вашу базу данных, то он сможет сделать с ней что угодно. Никогда не помещайте аргументы прямо в строку условий!</p><div class="info"><p>Подробнее об опасности SQL-инъекций можно узнать из руководства <a href="/security">Безопасность приложений на Rails</a>.</p></div><h5 id='mestozapolniteli-v-usloviyah' class='inside_page_header'><a href="#mestozapolniteli-v-usloviyah">3.2.1.</a> Местозаполнители в условиях</h5><p>Подобно тому, как <code>(?)</code> заменяют параметры, можно использовать ключи в условиях совместно с соответствующим хэшем ключей/значений:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &gt;= :start_date AND created_at &lt;= :end_date"</span><span class="p">,</span>
  <span class="p">{</span> <span class="ss">start_date: </span><span class="n">params</span><span class="p">[</span><span class="ss">:start_date</span><span class="p">],</span> <span class="ss">end_date: </span><span class="n">params</span><span class="p">[</span><span class="ss">:end_date</span><span class="p">]</span> <span class="p">})</span>
</code></pre>
</div>
<p>Читаемость улучшится, в случае если вы используете большое количество переменных в условиях.</p><h5 id='usloviya-s-ispolzovaniem-like' class='inside_page_header'><a href="#usloviya-s-ispolzovaniem-like">3.2.2.</a> Условия с использованием <code>LIKE</code></h5><p>Хотя аргументы условия автоматически экранируются, чтобы предотвратить инъекцию SQL, подстановки SQL <code>LIKE</code> (т.е. <code>%</code> и <code>_</code>) <strong>не</strong> экранируются. Это может вызвать неожидаемое поведение, если неочищенное значение используется в качестве аргумента. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title LIKE ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">]</span> <span class="o">+</span> <span class="s2">"%"</span><span class="p">)</span>
</code></pre>
</div>
<p>В вышеприведенном коде намерением является соответствие заголовков, начинающихся с указанной пользователем строки. Однако, любое включение <code>%</code> или <code>_</code> в <code>params[:title]</code> будет трактоваться как подстановки, что приведет к неожиданным результатам запроса. В некоторых обстоятельствах, это может также предотвратить использование базой данных предназначенного индекса, что приведет к гораздо медленному запросу.</p><p>Чтобы избежать этих проблемы, используйте <a href="https://api.rubyonrails.org/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql_like"><code>sanitize_sql_like</code></a> для экранирования символов подстановки в соответствующей части аргумента:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title LIKE ?"</span><span class="p">,</span>
  <span class="no">Book</span><span class="p">.</span><span class="nf">sanitize_sql_like</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">])</span> <span class="o">+</span> <span class="s2">"%"</span><span class="p">)</span>
</code></pre>
</div>
<h4 id='hash-conditions' class='inside_page_header'><a href="#hash-conditions">3.3.</a>  Условия с использованием хэша</h4><p>Active Record также позволяет передавать условия в хэше, что улучшает читаемость синтаксиса условий. В этом случае передается хэш с ключами, соответствующими полям, которые хотите уточнить, и с значениями, которые вы хотите к ним применить:</p><div class="note"><p>Хэшем можно передать условия проверки только равенства, интервала и подмножества.</p></div><h5 id='usloviya-ravenstva' class='inside_page_header'><a href="#usloviya-ravenstva">3.3.1.</a> Условия равенства</h5><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span>
</code></pre>
</div>
<p>Это сгенерирует такой SQL:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">books</span><span class="p">.</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
</div>
<p>Имя поля также может быть строкой, а не символом:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'out_of_print'</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
</code></pre>
</div>
<p>В случае отношений belongs_to, может быть использован ключ связи для указания модели, если как значение используется объект Active Record. Этот метод также работает с полиморфными отношениями.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">author</span> <span class="o">=</span> <span class="no">Author</span><span class="p">.</span><span class="nf">first</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">author: </span><span class="n">author</span><span class="p">)</span>
<span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:books</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">books: </span><span class="p">{</span> <span class="ss">author: </span><span class="n">author</span> <span class="p">})</span>
</code></pre>
</div>
<h5 id='intervalnye-usloviya' class='inside_page_header'><a href="#intervalnye-usloviya">3.3.2.</a> Интервальные условия</h5><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span><span class="p">)</span>
</code></pre>
</div>
<p>Это найдет все книги, созданные вчера, с использованием SQL выражения <code>BETWEEN</code>:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="k">BETWEEN</span> <span class="s1">'2008-12-21 00:00:00'</span> <span class="k">AND</span> <span class="s1">'2008-12-22 00:00:00'</span><span class="p">)</span>
</code></pre>
</div>
<p>Это была демонстрация более короткого синтаксиса для примеров в <a href="#array-conditions">Условия с использованием массива</a></p><p>Можно использовать интервалы без начала и без конца, чтобы создавать условия больше/меньше.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="p">)</span>
</code></pre>
</div>
<p>Это сгенерирует подобный SQL:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="o">&gt;=</span> <span class="s1">'2008-12-21 00:00:00'</span>
</code></pre>
</div>
<h5 id='usloviya-podmnozhestva' class='inside_page_header'><a href="#usloviya-podmnozhestva">3.3.3.</a> Условия подмножества</h5><p>Если хотите найти записи, используя выражение <code>IN</code>, можете передать массив в хэш условий:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre>
</div>
<p>Этот код сгенерирует подобный SQL:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre>
</div>
<h4 id='usloviya-not' class='inside_page_header'><a href="#usloviya-not">3.4.</a> Условия NOT</h4><p>Запросы <code>NOT</code> в SQL могут быть созданы с помощью <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods/WhereChain.html#method-i-not"><code>where.not</code></a>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre>
</div>
<p>Другими словами, этот запрос может быть сгенерирован с помощью вызова <code>where</code> без аргументов и далее присоединенным <code>not</code> с переданными условиями для <code>where</code>. Это сгенерирует такой SQL:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre>
</div>
<p>Если в запросе есть условие с использованием хэша с не-nil значениями на null столбце, записи со значениями <code>nil</code> на null столбце не будут возвращены. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="kp">nil</span><span class="p">)</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="s2">"UK"</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="p">[]</span>
<span class="c1"># Но</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="s2">"UK"</span><span class="p">)</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="kp">nil</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="c1">#&lt;Customer id: 2, nullable_country: "UK"&gt;]</span>
</code></pre>
</div>
<h4 id='usloviya-or' class='inside_page_header'><a href="#usloviya-or">3.5.</a> Условия OR</h4><p>Условия <code>OR</code> между двумя отношениями могут быть построены путем вызова <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-or"><code>or</code></a> на первом отношении и передачи второго в качестве аргумента.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">last_name: </span><span class="s1">'Smith'</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="s1">'Smith'</span> <span class="k">OR</span> <span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre>
</div>
<h4 id='usloviya-and' class='inside_page_header'><a href="#usloviya-and">3.6.</a> Условия AND</h4><p>Условия <code>AND</code> могут быть построены с помощью присоединения условий <code>where</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">last_name: </span><span class="s1">'Smith'</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="s1">'Smith'</span> <span class="k">AND</span> <span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
</code></pre>
</div>
<p>Условия <code>AND</code> для логического пересечения между relation могут быть построены путем вызова <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-and"><code>and</code></a> на первом relation и передачей второго в качестве аргумента.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]).</span><span class="nf">and</span><span class="p">(</span><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">AND</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
</div>
<h3 id='ordering' class='inside_page_header'><a href="#ordering">4.</a>  Упорядочивание</h3><p>Чтобы получить записи из базы данных в определенном порядке, можете использовать метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-order"><code>order</code></a>.</p><p>Например, если вы получаете ряд записей и хотите упорядочить их в порядке возрастания поля <code>created_at</code> в таблице:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
<span class="c1"># ИЛИ</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
</code></pre>
</div>
<p>Также можете определить <code>ASC</code> или <code>DESC</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># ИЛИ</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">created_at: :asc</span><span class="p">)</span>
<span class="c1"># ИЛИ</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
<span class="c1"># ИЛИ</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at ASC"</span><span class="p">)</span>
</code></pre>
</div>
<p>Или сортировку по нескольким полям:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">title: :asc</span><span class="p">,</span> <span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># ИЛИ</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># ИЛИ</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title ASC, created_at DESC"</span><span class="p">)</span>
<span class="c1"># ИЛИ</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title ASC"</span><span class="p">,</span> <span class="s2">"created_at DESC"</span><span class="p">)</span>
</code></pre>
</div>
<p>Если хотите вызвать <code>order</code> несколько раз, последующие сортировки будут добавлены к первой:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title ASC"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
<span class="go">SELECT * FROM books ORDER BY title ASC, created_at DESC
</span></code></pre>
</div>
<div class="warning"><p>В большинстве СУБД при выборе полей с помощью <code>distinct</code> из результирующей выборки используя методы, такие как <code>select</code>, <code>pluck</code> и <code>ids</code>; метод <code>order</code> вызовет исключение <code>ActiveRecord::StatementInvalid</code>, если поля, используемые в выражении <code>order</code>, не включены в список выбора. Смотрите следующий раздел по выбору полей из результирующей выборки.</p></div><h3 id='vybor-opredelennyh-poley' class='inside_page_header'><a href="#vybor-opredelennyh-poley">5.</a> Выбор определенных полей</h3><p>По умолчанию <code>Model.find</code> выбирает все множество полей результата, используя <code>select *</code>.</p><p>Чтобы выбрать подмножество полей из всего множества, можете определить его, используя метод<a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-select"><code>select</code></a>.</p><p>Например, чтобы выбрать только столбцы <code>isbn</code> и <code>out_of_print</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:isbn</span><span class="p">,</span> <span class="ss">:out_of_print</span><span class="p">)</span>
<span class="c1"># ИЛИ</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"isbn, out_of_print"</span><span class="p">)</span>
</code></pre>
</div>
<p>Используемый для этого запрос SQL будет иметь подобный вид:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">isbn</span><span class="p">,</span> <span class="n">out_of_print</span> <span class="k">FROM</span> <span class="n">books</span>
</code></pre>
</div>
<p>Будьте осторожны, поскольку это также означает, что будет инициализирован объект модели только с теми полями, которые вы выбрали. Если вы попытаетесь обратиться к полям, которых нет в инициализированной записи, то получите:</p><div class="code_container">
  <pre><code class="highlight plaintext">ActiveModel::MissingAttributeError: missing attribute '&lt;attribute&gt;' for Book
</code></pre>
</div>
<p>Где <code>&lt;attribute&gt;</code> это атрибут, который был запрошен. Метод <code>id</code> не вызывает <code>ActiveRecord::MissingAttributeError</code>, поэтому будьте аккуратны при работе со связями, так как они нуждаются в методе <code>id</code> для правильной работы.</p><p>Если хотите вытащить только по одной записи для каждого уникального значения в определенном поле, можно использовать <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-distinct"><code>distinct</code></a>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:last_name</span><span class="p">).</span><span class="nf">distinct</span>
</code></pre>
</div>
<p>Это сгенерирует такой SQL:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">last_name</span> <span class="k">FROM</span> <span class="n">customers</span>
</code></pre>
</div>
<p>Также можно убрать ограничение уникальности:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Возвратит уникальные last_name</span>
<span class="n">query</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:last_name</span><span class="p">).</span><span class="nf">distinct</span>

<span class="c1"># Возвратит все last_name, даже если есть дубликаты</span>
<span class="n">query</span><span class="p">.</span><span class="nf">distinct</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
</code></pre>
</div>
<h3 id='ogranichenie-i-smeschenie' class='inside_page_header'><a href="#ogranichenie-i-smeschenie">6.</a> Ограничение и смещение</h3><p>Чтобы применить <code>LIMIT</code> к SQL, запущенному с помощью <code>Model.find</code>, нужно определить <code>LIMIT</code>, используя методы <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-limit"><code>limit</code></a> и <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-offset"><code>offset</code></a> на relation.</p><p>Используйте <code>limit</code> для определения количества записей, которые будут получены, и <code>offset</code> - для числа записей, которые будут пропущены до начала возврата записей. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre>
</div>
<p>возвратит максимум 5 покупателей, и, поскольку не определено смещение, будут возвращены первые 5 в таблице. Выполняемый SQL будет выглядеть подобным образом:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">5</span>
</code></pre>
</div>
<p>Добавление <code>offset</code> к этому</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nf">offset</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
</code></pre>
</div>
<p>Возвратит максимум 5 покупателей, начиная с 31-го. SQL выглядит так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">5</span> <span class="k">OFFSET</span> <span class="mi">30</span>
</code></pre>
</div>
<h3 id='gruppirovka' class='inside_page_header'><a href="#gruppirovka">7.</a> Группировка</h3><p>Чтобы применить условие <code>GROUP BY</code> к <code>SQL</code>, можно использовать метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-group"><code>group</code></a>.</p><p>Например, если хотите найти коллекцию дат, в которые были созданы заказы:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
</code></pre>
</div>
<p>Это выдаст вам отдельный объект <code>Order</code> на каждую дату, для которой были заказы в базе данных.</p><p>SQL, который будет выполнен, будет выглядеть так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">created_at</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">created_at</span>
</code></pre>
</div>
<h4 id='obschee-kolichestvo-sgruppirovannyh-elementov' class='inside_page_header'><a href="#obschee-kolichestvo-sgruppirovannyh-elementov">7.1.</a> Общее количество сгруппированных элементов</h4><p>Чтобы получить общее количество сгруппированных элементов одним запросом, вызовите <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-count"><code>count</code></a> после <code>group</code>.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:status</span><span class="p">).</span><span class="nf">count</span>
<span class="p">=&gt;</span> <span class="p">{</span><span class="s2">"being_packed"</span><span class="o">=&gt;</span><span class="mi">7</span><span class="p">,</span> <span class="s2">"shipped"</span><span class="o">=&gt;</span><span class="mi">12</span><span class="p">}</span>
</code></pre>
</div>
<p>SQL, который будет выполнен, будет выглядеть так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">COUNT</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">count_all</span><span class="p">,</span> <span class="n">status</span> <span class="k">AS</span> <span class="n">status</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">status</span>
</code></pre>
</div>
<h3 id='usloviya-having' class='inside_page_header'><a href="#usloviya-having">8.</a> Условия HAVING</h3><p>SQL использует условие <code>HAVING</code> для определения условий для полей, указанных в <code>GROUP BY</code>. Условие <code>HAVING</code>, определенное в SQL, запускается в <code>Model.find</code> с использованием метода <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-having"><code>having</code></a> для поиска.</p><p>Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"created_at, sum(total) as total_price"</span><span class="p">).</span>
  <span class="nf">group</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"sum(total) &gt; ?"</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</code></pre>
</div>
<p>SQL, который будет выполнен, выглядит так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">created_at</span> <span class="k">as</span> <span class="n">ordered_date</span><span class="p">,</span> <span class="k">sum</span><span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="k">as</span> <span class="n">total_price</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">created_at</span>
<span class="k">HAVING</span> <span class="k">sum</span><span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">200</span>
</code></pre>
</div>
<p>Это возвращает дату и итоговую цену для каждого объекта заказа, сгруппированные по дню, когда они были заказаны, и где цена больше $200.</p><p>Получить <code>total_price</code> каждого возвращенного объекта заказа можно так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">big_orders</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"created_at, sum(total) as total_price"</span><span class="p">)</span>
                  <span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
                  <span class="p">.</span><span class="nf">having</span><span class="p">(</span><span class="s2">"sum(total) &gt; ?"</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="n">big_orders</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">total_price</span>
<span class="c1"># Возвращает итоговую цену первого объекта Order</span>
</code></pre>
</div>
<h3 id='pereopredelyayuschie-usloviya' class='inside_page_header'><a href="#pereopredelyayuschie-usloviya">9.</a> Переопределяющие условия</h3><h4 id='unscope' class='inside_page_header'><a href="#unscope">9.1.</a> <code>unscope</code></h4><p>Можете указать определенные условия, которые будут убраны, используя метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-unscope"><code>unscope</code></a>. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'id &gt; 100'</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">20</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s1">'id desc'</span><span class="p">).</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:order</span><span class="p">)</span>
</code></pre>
</div>
<p>SQL, который будет выполнен, будет выглядеть так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="k">LIMIT</span> <span class="mi">20</span>

<span class="c1">-- Оригинальный запрос без `unscope`</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">desc</span> <span class="k">LIMIT</span> <span class="mi">20</span>
</code></pre>
</div>
<p>Также можно убрать определенные условия <code>where</code>. Например, это уберет условие для <code>id</code> из условия where:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">10</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">).</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">where: :id</span><span class="p">)</span>
<span class="c1"># SELECT books.* FROM books WHERE out_of_print = 0</span>
</code></pre>
</div>
<p>Relation, использующий <code>unscope</code> повлияет на любой relation, в который он слит:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s1">'id desc'</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="no">Book</span><span class="p">.</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:order</span><span class="p">))</span>
<span class="c1"># SELECT books.* FROM books</span>
</code></pre>
</div>
<h4 id='only' class='inside_page_header'><a href="#only">9.2.</a> <code>only</code></h4><p>Также можно переопределить условия, используя метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-only"><code>only</code></a>. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'id &gt; 10'</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">20</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s1">'id desc'</span><span class="p">).</span><span class="nf">only</span><span class="p">(</span><span class="ss">:order</span><span class="p">,</span> <span class="ss">:where</span><span class="p">)</span>
</code></pre>
</div>
<p>SQL, который будет выполнен, будет выглядеть так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span>

<span class="c1">-- Оригинальный запрос без `only`</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">20</span>
</code></pre>
</div>
<h4 id='reselect' class='inside_page_header'><a href="#reselect">9.3.</a> <code>reselect</code></h4><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reselect"><code>reselect</code></a> переопределяет существующее выражение select. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:isbn</span><span class="p">).</span><span class="nf">reselect</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
</code></pre>
</div>
<p>SQL, который будет выполнен:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="k">FROM</span> <span class="n">books</span>
</code></pre>
</div>
<p>Сравните это со случаем, когда не было использовано выражение <code>reselect</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:isbn</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
</code></pre>
</div>
<p>SQL, который будет выполнен:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">isbn</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="k">FROM</span> <span class="n">books</span>
</code></pre>
</div>
<h4 id='reorder' class='inside_page_header'><a href="#reorder">9.4.</a> <code>reorder</code></h4><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reorder"><code>reorder</code></a> переопределяет сортировку скоупа по умолчанию. Например, если определение класса включает это:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Author</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="ss">year_published: :desc</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<p>И вы выполняете это:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">books</span>
</code></pre>
</div>
<p>SQL, который будет выполнен, будет выглядеть так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">year_published</span> <span class="k">DESC</span>
</code></pre>
</div>
<p>Можно использовать выражение <code>reorder</code> для указания иного способа упорядочивания книг:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">books</span><span class="p">.</span><span class="nf">reorder</span><span class="p">(</span><span class="s1">'year_published ASC'</span><span class="p">)</span>
</code></pre>
</div>
<p>SQL, который будет выполнен:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">year_published</span> <span class="k">ASC</span>
</code></pre>
</div>
<h4 id='reverse_order' class='inside_page_header'><a href="#reverse_order">9.5.</a> <code>reverse_order</code></h4><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reverse_order"><code>reverse_order</code></a> меняет направление условия сортировки, если оно определено:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"author_id &gt; 10"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">:year_published</span><span class="p">).</span><span class="nf">reverse_order</span>
</code></pre>
</div>
<p>SQL, который будет выполнен, будет выглядеть так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">year_published</span> <span class="k">DESC</span>
</code></pre>
</div>
<p>Если условие сортировки не было определено в запросе, <code>reverse_order</code> сортирует по первичному ключу в обратном порядке:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"author_id &gt; 10"</span><span class="p">).</span><span class="nf">reverse_order</span>
</code></pre>
</div>
<p>SQL, который будет выполнен, будет выглядеть так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span>
</code></pre>
</div>
<p>Метод <code>reverse_order</code> не принимает аргументы.</p><h4 id='rewhere' class='inside_page_header'><a href="#rewhere">9.6.</a> <code>rewhere</code></h4><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-rewhere"><code>rewhere</code></a> переопределяет существующее именованное условие <code>where</code>. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">rewhere</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span>
</code></pre>
</div>
<p>SQL, который будет выполнен, будет выглядеть так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
</div>
<p>В случае, когда не используется условие <code>rewhere</code>, условия where соединяются с помощью AND</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span>
</code></pre>
</div>
<p>выполненный SQL будет следующий:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
</div>
<h4 id='regroup' class='inside_page_header'><a href="#regroup">9.7.</a> <code>regroup</code></h4><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-regroup"><code>regroup</code></a> переопределяет существующее именованное условие <code>group</code>. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">regroup</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre>
</div>
<p>SQL, который будет выполнен:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">id</span>
</code></pre>
</div>
<p>Если не было бы использовано выражение <code>regroup</code>, выражения группировки объединились:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre>
</div>
<p>SQL, который был бы выполнен:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">author</span><span class="p">,</span> <span class="n">id</span>
</code></pre>
</div>
<h3 id='nulevoy-relation' class='inside_page_header'><a href="#nulevoy-relation">10.</a> Нулевой Relation</h3><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-none"><code>none</code></a> возвращает сцепляемый relation без записей. Любые последующие условия, сцепленные с возвращенным relation, продолжат генерировать пустые relation. Это полезно в случаях, когда необходим сцепляемый отклик на метод или скоуп, который может вернуть пустые результаты.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">none</span> <span class="c1"># возвращает пустой Relation и не вызывает запросов.</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># От метода highlighted_reviews ожидается, что он вернет Relation.</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">highlighted_reviews</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="ss">:rating</span><span class="p">)</span>
<span class="c1"># =&gt; Возвращает средний рейтинг книги</span>

<span class="k">class</span> <span class="nc">Book</span>
  <span class="c1"># Возвращает рецензии, когда их как минимум 5,</span>
  <span class="c1"># иначе рассматривает эту книгу как не рецензированную</span>
  <span class="k">def</span> <span class="nf">highlighted_reviews</span>
    <span class="k">if</span> <span class="n">reviews</span><span class="p">.</span><span class="nf">count</span> <span class="o">&gt;</span> <span class="mi">5</span>
      <span class="n">reviews</span>
    <span class="k">else</span>
      <span class="no">Review</span><span class="p">.</span><span class="nf">none</span> <span class="c1"># Пока не удовлетворяет минимальному порогу</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h3 id='ob-ekty-tolko-dlya-chteniya' class='inside_page_header'><a href="#ob-ekty-tolko-dlya-chteniya">11.</a> Объекты только для чтения</h3><p>Active Record предоставляет relation метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-readonly"><code>readonly</code></a> для явного запрета на модификацию любого из возвращаемых объектов. Любая попытка изменить запись, доступную только для чтения, не удастся, вызвав исключение <code>ActiveRecord::ReadOnlyRecord</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">readonly</span><span class="p">.</span><span class="nf">first</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">visits</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">save</span>
</code></pre>
</div>
<p>Так как <code>customer</code> явно указан как объект доступный только для чтения, выполнение вышеуказанного кода выдаст исключение <code>ActiveRecord::ReadOnlyRecord</code> при вызове <code>customer.save</code> с обновленным значением <code>visits</code>.</p><h3 id='blokirovka-zapisey-dlya-obnovleniya' class='inside_page_header'><a href="#blokirovka-zapisey-dlya-obnovleniya">12.</a> Блокировка записей для обновления</h3><p>Блокировка полезна для предотвращения состояния гонки при обновлении записей в базе данных и обеспечения атомарного обновления.</p><p>Active Record предоставляет два механизма блокировки:</p><ul><li>Оптимистическая блокировка
</li><li>Пессимистическая блокировка
</li></ul><h4 id='optimisticheskaya-blokirovka' class='inside_page_header'><a href="#optimisticheskaya-blokirovka">12.1.</a> Оптимистическая блокировка</h4><p>Оптимистическая блокировка позволяет нескольким пользователям обращаться к одной и той же записи для редактирования и предполагает минимум конфликтов с данными. Она осуществляет это с помощью проверки, внес ли другой процесс изменения в записи, с тех пор как она была открыта. Если это происходит, вызывается исключение <code>ActiveRecord::StaleObjectError</code>, и обновление игнорируется.</p><p><strong>Столбец оптимистической блокировки</strong></p><p>Чтобы начать использовать оптимистическую блокировку, таблица должна иметь столбец, называющийся <code>lock_version</code>, с типом integer. Каждый раз, когда запись обновляется, Active Record увеличивает значение <code>lock_version</code>, и средства блокирования обеспечивают, что для записи, вызванной дважды, та, которая первая успеет, будет сохранена, а для второй будет вызвано исключение <code>ActiveRecord::StaleObjectError</code>.</p><p>Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">c1</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">c1</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">=</span> <span class="s2">"Sandra"</span>
<span class="n">c1</span><span class="p">.</span><span class="nf">save</span>

<span class="n">c2</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">=</span> <span class="s2">"Michael"</span>
<span class="n">c2</span><span class="p">.</span><span class="nf">save</span> <span class="c1"># вызывает исключение ActiveRecord::StaleObjectError</span>
</code></pre>
</div>
<p>Вы ответственны за разрешение конфликта с помощью обработки исключения и либо отката, либо объединения, либо применения бизнес-логики, необходимой для разрешения конфликта.</p><p>Это поведение может быть отключено, если установить <code>ActiveRecord::Base.lock_optimistically = false</code>.</p><p>Для переопределения имени столбца <code>lock_version</code>, <code>ActiveRecord::Base</code> предоставляет атрибут класса <code>locking_column</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">locking_column</span> <span class="o">=</span> <span class="ss">:lock_customer_column</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='pessimisticheskaya-blokirovka' class='inside_page_header'><a href="#pessimisticheskaya-blokirovka">12.2.</a> Пессимистическая блокировка</h4><p>Пессимистическая блокировка использует механизм блокировки, предоставленный лежащей в основе базой данных. Использование <code>lock</code> при построении relation применяет эксклюзивную блокировку для выбранных строк. Relations, которые используют <code>lock</code>, обычно упакованы внутри transaction для предотвращения условий взаимной блокировки (дедлока).</p><p>Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s1">'Algorithms, second edition'</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">save!</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Вышеописанная сессия осуществляет следующие SQL для бэкенда MySQL:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SQL</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="n">ms</span><span class="p">)</span>   <span class="k">BEGIN</span>
<span class="n">Book</span> <span class="k">Load</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="n">ms</span><span class="p">)</span>   <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LIMIT</span> <span class="mi">1</span> <span class="k">FOR</span> <span class="k">UPDATE</span>
<span class="n">Book</span> <span class="k">Update</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="n">ms</span><span class="p">)</span>   <span class="k">UPDATE</span> <span class="n">books</span> <span class="k">SET</span> <span class="n">updated_at</span> <span class="o">=</span> <span class="s1">'2009-02-07 18:05:56'</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">'Algorithms, second edition'</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">SQL</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="n">ms</span><span class="p">)</span>   <span class="k">COMMIT</span>
</code></pre>
</div>
<p>Также можно передать чистый SQL в опцию <code>lock</code> для разрешения различных типов блокировок. Например, в MySQL есть выражение, называющееся <code>LOCK IN SHARE MODE</code>, которым можно заблокировать запись, но все же разрешить другим запросам читать ее. Чтобы указать это выражения, просто передайте его как опцию блокировки:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">lock</span><span class="p">(</span><span class="s2">"LOCK IN SHARE MODE"</span><span class="p">).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">increment!</span><span class="p">(</span><span class="ss">:views</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="note"><p>Отметьте, что ваша база данных должна поддерживать SQL, который вы передаете в метод <code>lock</code>.</p></div><p>Если у вас уже имеется экземпляр модели, можно одновременно начать транзакцию и затребовать блокировку, используя следующий код:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">first</span>
<span class="n">book</span><span class="p">.</span><span class="nf">with_lock</span> <span class="k">do</span>
  <span class="c1"># Этот блок вызывается в транзакции,</span>
  <span class="c1"># книга уже заблокирован.</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">increment!</span><span class="p">(</span><span class="ss">:views</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<h3 id='joining-tables' class='inside_page_header'><a href="#joining-tables">13.</a>  Соединительные таблицы</h3><p>Active Record предоставляет два метода поиска для определения условия <code>JOIN</code> в результирующем SQL: <code>joins</code> и <code>left_outer_joins</code>. В то время, как <code>joins</code> следует использовать для <code>INNER JOIN</code> или пользовательских запросов, <code>left_outer_joins</code> используется для запросов с помощью <code>LEFT OUTER JOIN</code>.</p><h4 id='joins' class='inside_page_header'><a href="#joins">13.1.</a> <code>joins</code></h4><p>Существует несколько способов использования метода <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-joins"><code>joins</code></a>.</p><h5 id='ispolzovanie-strokovogo-fragmenta-sql' class='inside_page_header'><a href="#ispolzovanie-strokovogo-fragmenta-sql">13.1.1.</a> Использование строкового фрагмента SQL</h5><p>Можно просто передать чистый SQL, определяющий условие <code>JOIN</code> в <code>joins</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="s2">"INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE"</span><span class="p">)</span>
</code></pre>
</div>
<p>Это приведет к следующему SQL:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">books</span> <span class="k">ON</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">books</span><span class="p">.</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="k">FALSE</span>
</code></pre>
</div>
<h5 id='ispolzovanie-massiva-hesha-imenovannyh-svyazey' class='inside_page_header'><a href="#ispolzovanie-massiva-hesha-imenovannyh-svyazey">13.1.2.</a> Использование массива/хэша именованных связей</h5><p>Active Record позволяет использовать имена <a href="/active-record-associations">связей</a>, определенных в модели, как ярлыки для определения условия <code>JOIN</code> этих связей при использовании метода <code>joins</code>.</p><p>Все нижеследующее создаст ожидаемые соединительные запросы с использованием <code>INNER JOIN</code>:</p><h6 id='soedinenie-odinochnoy-svyazi' class='inside_page_header'><a href="#soedinenie-odinochnoy-svyazi">13.1.2.1.</a> Соединение одиночной связи</h6><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
</code></pre>
</div>
<p>Это создаст:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
</code></pre>
</div>
<p>Или, по-русски, &quot;возвратить объект Book для всех книг с рецензиями&quot;. Обратите внимание, что будут дублирующиеся книги, если у книги больше одной рецензии. Если нужны уникальные книги, можно использовать <code>Book.joins(:reviews).distinct</code>.</p><h5 id='soedinenie-neskolkih-svyazey' class='inside_page_header'><a href="#soedinenie-neskolkih-svyazey">13.1.3.</a> Соединение нескольких связей</h5><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:author</span><span class="p">,</span> <span class="ss">:reviews</span><span class="p">)</span>
</code></pre>
</div>
<p>Это создаст:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">authors</span> <span class="k">ON</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
</code></pre>
</div>
<p>Или, по-русски, &quot;возвратить все книги, у которых есть автор и как минимум одна рецензия&quot;. Снова отметьте, что книги с несколькими рецензиями будут показаны несколько раз.</p><h6 id='soedinenie-vlozhennyh-svyazey-odnogo-urovnya' class='inside_page_header'><a href="#soedinenie-vlozhennyh-svyazey-odnogo-urovnya">13.1.3.1.</a> Соединение вложенных связей (одного уровня)</h6><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">reviews: :customer</span><span class="p">)</span>
</code></pre>
</div>
<p>Это создаст:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">customers</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span>
</code></pre>
</div>
<p>Или, по-русски, &quot;возвратить все книги, у которых есть рецензия покупателя&quot;.</p><h6 id='soedinenie-vlozhennyh-svyazey-raznyh-urovney' class='inside_page_header'><a href="#soedinenie-vlozhennyh-svyazey-raznyh-urovney">13.1.3.2.</a> Соединение вложенных связей (разных уровней)</h6><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">books: </span><span class="p">[{</span> <span class="ss">reviews: </span><span class="p">{</span> <span class="ss">customer: :orders</span> <span class="p">}</span> <span class="p">},</span> <span class="ss">:supplier</span><span class="p">])</span>
</code></pre>
</div>
<p>Это создаст:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">books</span> <span class="k">ON</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">customers</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">suppliers</span> <span class="k">ON</span> <span class="n">suppliers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">supplier_id</span>
</code></pre>
</div>
<p>Или, по-русски: &quot;возвратить всех авторов, у которых есть книги с рецензиями покупателей, делавших заказы, а также поставщики для этих книг&quot;.</p><h5 id='opredelenie-usloviy-v-soedinitelnyh-tablitsah' class='inside_page_header'><a href="#opredelenie-usloviy-v-soedinitelnyh-tablitsah">13.1.4.</a> Определение условий в соединительных таблицах</h5><p>В соединительных таблицах можно определить условия, используя обычные <a href="/active-record-querying#array-conditions">массивные</a> и <a href="/active-record-querying#pure-string-conditions">строковые</a> условия. <a href="/active-record-querying#hash-conditions">Условия с использованием хэша</a> предоставляют специальный синтаксис для определения условий в соединительных таблицах:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'orders.created_at'</span> <span class="o">=&gt;</span> <span class="n">time_range</span><span class="p">).</span><span class="nf">distinct</span>
</code></pre>
</div>
<p>Это найдет всех покупателей, сделавших вчера заказы, используя выражение SQL <code>BETWEEN</code> для сравнения <code>created_at</code>.</p><p>Альтернативный и более чистый синтаксис для этого - вложенные хэш-условия:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders: </span><span class="p">{</span> <span class="ss">created_at: </span><span class="n">time_range</span> <span class="p">}).</span><span class="nf">distinct</span>
</code></pre>
</div>
<p>Для более сложных условий или повторного использования существующих именованных скоупов можно использовать <a href="https://api.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-merge"><code>merge</code></a>. Сперва давайте добавим новый именованный скоуп в модель Order:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>

  <span class="n">scope</span> <span class="ss">:created_in_time_range</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="n">time_range</span><span class="p">)</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Теперь можно использовать <code>merge</code> для слияния со скоупом <code>created_in_time_range</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="no">Order</span><span class="p">.</span><span class="nf">created_in_time_range</span><span class="p">(</span><span class="n">time_range</span><span class="p">)).</span><span class="nf">distinct</span>
</code></pre>
</div>
<p>Это найдет всех покупателей, сделавших вчера заказы, снова используя выражение SQL <code>BETWEEN</code>.</p><h4 id='left_outer_joins' class='inside_page_header'><a href="#left_outer_joins">13.2.</a> <code>left_outer_joins</code></h4><p>Если хотите выбрать ряд записей, независимо от того, имеют ли они связанные записи, можно использовать метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins"><code>left_outer_joins</code></a>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">left_outer_joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">).</span><span class="nf">distinct</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s1">'customers.*, COUNT(reviews.*) AS reviews_count'</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="s1">'customers.id'</span><span class="p">)</span>
</code></pre>
</div>
<p>Который создаст:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">customers</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">reviews</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">reviews_count</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
</code></pre>
</div>
<p>Что означает: &quot;возвратить всех покупателей и количество их рецензий, независимо от того, имеются ли у них вообще рецензии&quot;.</p><h4 id='where-associated-i-where-missing' class='inside_page_header'><a href="#where-associated-i-where-missing">13.3.</a> <code>where.associated</code> и <code>where.missing</code></h4><p>Методы запроса <code>associated</code> и <code>missing</code> позволяет выбрать набор записей, основываясь на существовании или отсутствии связи.</p><p>Используя <code>where.associated</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">associated</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
</code></pre>
</div>
<p>Создаст:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">reviews</span><span class="p">.</span><span class="n">id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span>
</code></pre>
</div>
<p>Что означает &quot;вернуть всех покупателей, сделавших хотя бы один обзор&quot;.</p><p>Используя <code>where.missing</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">missing</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
</code></pre>
</div>
<p>Создаст:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">reviews</span><span class="p">.</span><span class="n">id</span> <span class="k">IS</span> <span class="k">NULL</span>
</code></pre>
</div>
<p>Что означает &quot;вернуть всех покупателей, не сделавших ни один обзор&quot;.</p><h3 id='neterpelivaya-zagruzka-svyazey' class='inside_page_header'><a href="#neterpelivaya-zagruzka-svyazey">14.</a> Нетерпеливая загрузка связей</h3><p>Нетерпеливая загрузка - это механизм загрузки связанных записей объекта, возвращаемых <code>Model.find</code>, с использованием как можно меньшего количества запросов.</p><h4 id='problema-n-1-zaprosa' class='inside_page_header'><a href="#problema-n-1-zaprosa">14.1.</a> Проблема N + 1 запроса</h4><p>Рассмотрим следующий код, который находит 10 книг и выводит фамилии их авторов:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre>
</div>
<p>На первый взгляд выглядит хорошо. Но проблема лежит в общем количестве выполненных запросов. Вышеупомянутый код выполняет 1 (чтобы найти 10 книг) + 10 (каждый на одну книгу для загрузки автора) = итого <strong>11</strong> запросов.</p><h5 id='reshenie-problemy-n-1-zaprosa' class='inside_page_header'><a href="#reshenie-problemy-n-1-zaprosa">14.1.1.</a> Решение проблемы N + 1 запроса</h5><p>Active Record позволяет заранее указать все связи, которые должны быть загружены.</p><p>Методы следующие:</p><ul><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-includes"><code>includes</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-preload"><code>preload</code></a>
</li><li><a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-eager_load"><code>eager_load</code></a>
</li></ul><h4 id='includes' class='inside_page_header'><a href="#includes">14.2.</a> <code>includes</code></h4><p>С помощью <code>includes</code> Active Record убеждается, что все указанные связи загружаются с помощью минимально возможного количества запросов.</p><p>Пересмотрев вышеупомянутую задачу, можно переписать <code>Book.limit(10)</code>, чтобы нетерпеливо загрузить авторов с помощью метода <code>includes</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Этот код выполнит всего <strong>2</strong> запроса, вместо <strong>11</strong> запросов из прошлого примера:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span>
  <span class="k">WHERE</span> <span class="n">authors</span><span class="p">.</span><span class="n">book_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre>
</div>
<h5 id='neterpelivaya-zagruzka-neskolkih-svyazey' class='inside_page_header'><a href="#neterpelivaya-zagruzka-neskolkih-svyazey">14.2.1.</a> Нетерпеливая загрузка нескольких связей</h5><p>Active Record позволяет нетерпеливо загружать любое количество связей в одном вызове <code>Model.find</code> с использованием массива, хэша или вложенного хэша массивов/хэшей с помощью метода <code>includes</code>.</p><h6 id='massiv-neskolkih-svyazey' class='inside_page_header'><a href="#massiv-neskolkih-svyazey">14.2.1.1.</a> Массив нескольких связей</h6><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:orders</span><span class="p">,</span> <span class="ss">:reviews</span><span class="p">)</span>
</code></pre>
</div>
<p>Это загрузит всех покупателей и связанные заказы и рецензии для каждого.</p><h6 id='vlozhennyy-hesh-svyazey' class='inside_page_header'><a href="#vlozhennyy-hesh-svyazey">14.2.1.2.</a> Вложенный хэш связей</h6><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">orders: </span><span class="p">{</span> <span class="ss">books: </span><span class="p">[</span><span class="ss">:supplier</span><span class="p">,</span> <span class="ss">:author</span><span class="p">]</span> <span class="p">}).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre>
</div>
<p>Вышеприведенный код находит покупателя с id 1 и нетерпеливо загружает все связанные заказы для него, книги для всех заказов, и автора и поставщика каждой книги.</p><h5 id='opredelenie-usloviy-dlya-neterpelivoy-zagruzki-svyazey' class='inside_page_header'><a href="#opredelenie-usloviy-dlya-neterpelivoy-zagruzki-svyazey">14.2.2.</a> Определение условий для нетерпеливой загрузки связей</h5><p>Хотя Active Record и позволяет определить условия для нетерпеливой загрузки связей точно так же, как и в <code>joins</code>, рекомендуем использовать вместо этого <a href="#joining-tables">joins</a>.</p><p>Однако, если сделать так, то можно использовать <code>where</code> как обычно.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:books</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">books: </span><span class="p">{</span> <span class="ss">out_of_print: </span><span class="kp">true</span> <span class="p">})</span>
</code></pre>
</div>
<p>Это сгенерирует запрос с ограничением <code>LEFT OUTER JOIN</code>, в то время как метод <code>joins</code> сгенерировал бы его с использованием функции <code>INNER JOIN</code>.</p><div class="code_container">
  <pre><code class="highlight ruby">  <span class="no">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="nf">id</span> <span class="no">AS</span> <span class="n">t0_r0</span><span class="p">,</span> <span class="o">...</span> <span class="n">books</span><span class="p">.</span><span class="nf">updated_at</span> <span class="no">AS</span> <span class="n">t1_r5</span> <span class="no">FROM</span> <span class="n">authors</span> <span class="no">LEFT</span> <span class="no">OUTER</span> <span class="no">JOIN</span> <span class="n">books</span> <span class="no">ON</span> <span class="n">books</span><span class="p">.</span><span class="nf">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="nf">id</span> <span class="no">WHERE</span> <span class="p">(</span><span class="n">books</span><span class="p">.</span><span class="nf">out_of_print</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
</div>
<p>Если бы не было условия <code>where</code>, то сгенерировался бы обычный набор из двух запросов.</p><div class="note"><p>Использование <code>where</code> подобным образом будет работать только, если передавать в него хэш. Для фрагментов SQL необходимо использовать <code>references</code> для принуждения соединения таблиц:</p></div><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:books</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s2">"books.out_of_print = true"</span><span class="p">).</span><span class="nf">references</span><span class="p">(</span><span class="ss">:books</span><span class="p">)</span>
</code></pre>
</div>
<p>Если, в случае с этим запросом <code>includes</code>, не будет ни одной книги ни для одного автора, все авторы все равно будут загружены. При использовании <code>joins</code> (INNER JOIN), соединительные условия <strong>должны</strong> соответствовать, иначе ни одной записи не будет возвращено.</p><div class="note"><p>Если связь нетерпеливо загружена как часть join, любые поля из произвольного выражения select не будут присутствовать в загруженных моделях. Это так, потому что это избыточность, которая должна появиться или в родительской модели, или в дочерней.</p></div><h4 id='preload' class='inside_page_header'><a href="#preload">14.3.</a> <code>preload</code></h4><p>С помощью <code>preload</code> Active Record загружает каждую указанную связь с помощью одного запроса на каждую связь.</p><p>Пересмотрим проблему N + 1 запроса, можно переписать <code>Book.limit(10)</code>, предварительно загружая авторов:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">preload</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Вышеуказанный код выполнит всего лишь <strong>2</strong> запроса, против <strong>11</strong> запросов в прошлом случае:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span>
  <span class="k">WHERE</span> <span class="n">authors</span><span class="p">.</span><span class="n">book_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre>
</div>
<div class="note"><p>Метод <code>preload</code> использует массив, хэш, или вложенный хэш массивов/хэшей тем же самым образом, как метод <code>includes</code>, чтобы загрузить любое количество связей, с помощь единого вызова <code>Model.find</code>. Однако, в отличие от метода <code>includes</code>, невозможно указать условия для предварительной загрузки связей.</p></div><h4 id='eager_load' class='inside_page_header'><a href="#eager_load">14.4.</a> <code>eager_load</code></h4><p>С помощью <code>eager_load</code> Active Record загружает все указанные связи с помощью <code>LEFT OUTER JOIN</code>.</p><p>Пересмотрим случай, когда произошел N + 1, с помощью метода <code>eager_load</code> можно переписать связь <code>Book.limit(10)</code> с авторами:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">eager_load</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Вышеуказанный код выполнит всего лишь <strong>2</strong> запросов, против <strong>11</strong> запросов в прошлом случае:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">authors</span> <span class="k">ON</span> <span class="n">authors</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">t0_r0</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">last_name</span> <span class="k">AS</span> <span class="n">t0_r1</span><span class="p">,</span> <span class="p">...</span>
  <span class="k">FROM</span> <span class="n">books</span> <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">authors</span> <span class="k">ON</span> <span class="n">authors</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
  <span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre>
</div>
<div class="note"><p>Метод <code>eager_load</code> использует массив, хэш, или вложенный хэш массивов/хэшей тем же самым образом, как метод <code>includes</code>, чтобы загрузить любое количество связей, с помощь единого вызова <code>Model.find</code>. Однако, в отличие от метода <code>includes</code>, невозможно указать условия для нетерпеливой загрузки связей.</p></div><h4 id='strict_loading' class='inside_page_header'><a href="#strict_loading">14.5.</a> <code>strict_loading</code></h4><p>Нетерпеливая загрузка может предотвратить N + 1 запрос, но вы все еще можете лениво загружать некоторые связи. Чтобы убедиться, что нет лениво загружаемых связей, можно включить <a href="https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-strict_loading"><code>strict_loading</code></a>.</p><p>Включив режим строгой загрузки на relation, будет вызвана <code>ActiveRecord::StrictLoadingViolationError</code>, если запись пытается лениво загрузить связь:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">strict_loading</span><span class="p">.</span><span class="nf">first</span>
<span class="n">user</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">to_a</span> <span class="c1"># вызовет ActiveRecord::StrictLoadingViolationError</span>
</code></pre>
</div>
<h3 id='scopes' class='inside_page_header'><a href="#scopes">15.</a>  Скоупы</h3><p>Скоупы позволяют задавать часто используемые запросы, к которым можно обращаться как к вызовам метода в связанных объектах или моделях. С помощью этих скоупов можно использовать каждый ранее раскрытый метод, такой как <code>where</code>, <code>joins</code> и <code>includes</code>. Все методы скоупов возвращают объект <code>ActiveRecord::Relation</code> или <code>nil</code>, что позволяет вызывать на них дополнительные методы (такие как другие скоупы).</p><p>Для определения простого скоупа мы используем метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Scoping/Named/ClassMethods.html#method-i-scope"><code>scope</code></a> внутри класса, передав запрос, который хотим запустить при вызове этого скоупа:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Для вызова скоупа <code>out_of_print</code>, можно вызвать его либо на классе:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># все распроданные книги</span>
</code></pre>
</div>
<p>Либо на связи, состоящей из объектов <code>Book</code>:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">author</span> <span class="o">=</span> <span class="no">Author</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">author</span><span class="p">.</span><span class="nf">books</span><span class="p">.</span><span class="nf">out_of_print</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># все распроданные книги этого `author`</span>
</code></pre>
</div>
<p>Скоупы также сцепляются с другими скоупами:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print_and_expensive</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">out_of_print</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"price &gt; 500"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='peredacha-argumenta' class='inside_page_header'><a href="#peredacha-argumenta">15.1.</a> Передача аргумента</h4><p>Скоуп может принимать аргументы:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:costs_more_than</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"price &gt; ?"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Вызывайте скоуп, как будто это метод класса:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">costs_more_than</span><span class="p">(</span><span class="mf">100.10</span><span class="p">)</span>
</code></pre>
</div>
<p>Однако, это всего лишь дублирование функциональности, которая должна быть предоставлена методом класса.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">costs_more_than</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
    <span class="n">where</span><span class="p">(</span><span class="s2">"price &gt; ?"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Эти методы также будут доступны на связанных объектах:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">author</span><span class="p">.</span><span class="nf">books</span><span class="p">.</span><span class="nf">costs_more_than</span><span class="p">(</span><span class="mf">100.10</span><span class="p">)</span>
</code></pre>
</div>
<h4 id='ispolzovanie-usloviy' class='inside_page_header'><a href="#ispolzovanie-usloviy">15.2.</a> Использование условий</h4><p>Ваши скоупы могут использовать условия:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:created_before</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="o">...</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">present?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Подобно остальным примерам, это ведет себя подобно методу класса.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">created_before</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="o">...</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">present?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Однако, имеется одно важное предостережение: скоуп всегда должен возвращать объект <code>ActiveRecord::Relation</code>, даже если условие вычисляется <code>false</code>, в отличие от метода класса, возвращающего <code>nil</code>. Это может вызвать <code>NoMethodError</code> при сцеплении методов класса с условиями, если одно из условий вернет <code>false</code>.</p><h4 id='applying-a-default-scope' class='inside_page_header'><a href="#applying-a-default-scope">15.3.</a>  Применение скоупа по умолчанию</h4><p>Если хотите, чтобы скоуп был применен ко всем запросам модели, можно использовать метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-default_scope"><code>default_scope</code></a> в самой модели.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Когда запросы для этой модели будут выполняться, запрос SQL теперь будет выглядеть примерно так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="k">false</span><span class="p">)</span>
</code></pre>
</div>
<p>Если необходимо сделать более сложные вещи со скоупом по умолчанию, альтернативно его можно определить как метод класса:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">default_scope</span>
    <span class="c1"># Должен возвращать ActiveRecord::Relation.</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="note"><p><code>default_scope</code> также применяется при создании записи, когда аргументы скоупа передаются как <code>Hash</code>. Он не применяется при обновлении записи. То есть:</p></div><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">new</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">false</span><span class="kt">&gt;</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">new</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">nil</span><span class="kt">&gt;</span>
</code></pre>
</div>
<p>Имейте в виду, что когда передаются в формате <code>Array</code>, аргументы запроса <code>default_scope</code> не могут быть преобразованы в <code>Hash</code> для назначения атрибутов по умолчанию. То есть:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"out_of_print = ?"</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">new</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">nil</span><span class="kt">&gt;</span>
</code></pre>
</div>
<h4 id='ob-edinenie-skoupov' class='inside_page_header'><a href="#ob-edinenie-skoupov">15.4.</a> Объединение скоупов</h4><p>Подобно условиям <code>where</code>, скоупы объединяются с использованием <code>AND</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:in_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">scope</span> <span class="ss">:recent</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="o">..</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:old</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="o">...</span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span><span class="p">.</span><span class="nf">old</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = 'true' AND books.year_published &lt; 1969
</span></code></pre>
</div>
<p>Можно комбинировать условия <code>scope</code> и <code>where</code>, и результирующий SQL будет содержать все условия, соединенные с помощью <code>AND</code>.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">in_print</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">price: </span><span class="o">...</span><span class="mi">100</span><span class="p">)</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = 'false' AND books.price &lt; 100
</span></code></pre>
</div>
<p>Если необходимо, чтобы сработало только последнее условие <code>where</code>, тогда можно использовать <a href="https://api.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-merge"><code>merge</code></a>.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">in_print</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span><span class="p">)</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = true
</span></code></pre>
</div>
<p>Важным предостережением является то, что <code>default_scope</code> переопределяется условиями <code>scope</code> и <code>where</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="o">..</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">scope</span> <span class="ss">:in_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">all</span>
<span class="go">SELECT books.* FROM books WHERE (year_published &gt;= 1969)
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">in_print</span>
<span class="go">SELECT books.* FROM books WHERE (year_published &gt;= 1969) AND books.out_of_print = false
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'price &gt; 50'</span><span class="p">)</span>
<span class="go">SELECT books.* FROM books WHERE (year_published &gt;= 1969) AND (price &gt; 50)
</span></code></pre>
</div>
<p>Как видите, <code>default_scope</code> объединяется как со <code>scope</code>, так и с <code>where</code> условиями.</p><h4 id='udalenie-vseh-skoupov' class='inside_page_header'><a href="#udalenie-vseh-skoupov">15.5.</a> Удаление всех скоупов</h4><p>Если хотите удалить скоупы по какой-то причине, можете использовать метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-unscoped"><code>unscoped</code></a>. Это особенно полезно, если в модели определен <code>default_scope</code>, и он не должен быть применен для конкретно этого запроса.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">load</span>
</code></pre>
</div>
<p>Этот метод удаляет все скоупы и выполняет обычный запрос к таблице.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span>
<span class="go">SELECT books.* FROM books
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span>
<span class="go">SELECT books.* FROM books
</span></code></pre>
</div>
<p><code>unscoped</code> также может принимать блок:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span> <span class="p">{</span> <span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span> <span class="p">}</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print
</span></code></pre>
</div>
<h3 id='dynamic-finders' class='inside_page_header'><a href="#dynamic-finders">16.</a>  Динамический поиск</h3><p>Для каждого поля (также называемого атрибутом), определенного в вашей таблице, Active Record предоставляет метод поиска. Например, если есть поле <code>first_name</code> в вашей модели <code>Customer</code>, вы автоматически получаете <code>find_by_first_name</code> от Active Record. Если также есть поле <code>locked</code> в модели <code>Customer</code>, вы также получаете <code>find_by_locked</code> метод.</p><p>Можете определить восклицательный знак (<code>!</code>) в конце динамического поиска, чтобы он вызвал ошибку <code>ActiveRecord::RecordNotFound</code>, если не возвратит ни одной записи, например так <code>Customer.find_by_first_name!(&quot;Ryan&quot;)</code></p><p>Если хотите искать и по <code>first_name</code>, и по <code>orders_count</code>, можете сцепить эти поиски вместе, просто написав &quot;<code>and</code>&quot; между полями, например, <code>Customer.find_by_first_name_and_orders_count(&quot;Ryan&quot;, 5)</code>.</p><h3 id='perechislenie' class='inside_page_header'><a href="#perechislenie">17.</a> Перечисление</h3><p>Перечисление позволяет определить массив значений для атрибута, и ссылаться на них по имени. Фактическим значением, хранимым в базе данных, будет целое число, соответствующее одному из значений.</p><p>Объявление перечисления:</p><ul><li>Создаст скоупы, которые можно использовать для поиска всех объектов имеющих или не имеющих одно из значений перечисления
</li><li>Создаст метод экземпляра, который можно использовать для определения, имеет ли объект определенное значение для перечисления
</li><li>Создаст метод экземпляра, который можно использовать для изменения значения перечисления у объекта
</li></ul><p>для каждого возможного значения перечисления.</p><p>Например, дано это определение <a href="https://api.rubyonrails.org/classes/ActiveRecord/Enum.html#method-i-enum"><code>enum</code></a>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">enum</span> <span class="ss">:status</span><span class="p">,</span> <span class="p">[</span><span class="ss">:shipped</span><span class="p">,</span> <span class="ss">:being_packaged</span><span class="p">,</span> <span class="ss">:complete</span><span class="p">,</span> <span class="ss">:cancelled</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Эти <a href="#scopes">скоупы</a> будут автоматически созданы, и их можно использовать, чтобы найти все объекты с или без определенного значения для <code>status</code>.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># все заказы со status == :shipped</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">not_shipped</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># все заказы со status != :shipped</span>
</code></pre>
</div>
<p>Эти методы экземпляра создаются автоматически и запрашивают, имеет ли модель это значение для перечисления <code>status</code>:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">.</span><span class="nf">shipped?</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">.</span><span class="nf">complete?</span>
<span class="p">=&gt;</span> <span class="kp">false</span>
</code></pre>
</div>
<p>Эти методы экземпляра создаются автоматически, и сначала обновляют значение <code>status</code> на названное значение, а затем запрашивают, был ли успешно установлен статус:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">.</span><span class="nf">shipped!</span>
<span class="go">UPDATE "orders" SET "status" = ?, "updated_at" = ? WHERE "orders"."id" = ?  [["status", 0], ["updated_at", "2019-01-24 07:13:08.524320"], ["id", 1]]
</span><span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre>
</div>
<p>Полную документацию об enum можно найти в <a href="https://api.rubyonrails.org/classes/ActiveRecord/Enum.html">документации Rails API</a>.</p><h3 id='method-chaining' class='inside_page_header'><a href="#method-chaining">18.</a>  Понимание цепочек методов</h3><p>В Active Record есть полезный приём программирования <a href="https://en.wikipedia.org/wiki/Method_chaining">Method Chaining</a>, который позволяет нам комбинировать множество Active Record методов.</p><p>Можно сцепить несколько методов в единое выражение, если предыдущий вызываемый метод возвращает <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html"><code>ActiveRecord::Relation</code></a>, такие как <code>all</code>, <code>where</code> и <code>joins</code>. Методы, которые возвращают одиночный объект (смотрите раздел <a href="#poluchenie-odinochnogo-ob-ekta">Получение одиночного объекта</a>) должны вызываться в конце.</p><p>Ниже представлены несколько примеров. Это руководство не покрывает все возможности, а только некоторые, для ознакомления. Когда вызывается Active Record метод, запрос не сразу генерируется и отправляется в базу. Запрос посылается только тогда, когда данные реально необходимы. Таким образом, каждый пример ниже генерирует только один запрос.</p><h4 id='poluchenie-otfiltrovannyh-dannyh-iz-neskolkih-tablits' class='inside_page_header'><a href="#poluchenie-otfiltrovannyh-dannyh-iz-neskolkih-tablits">18.1.</a> Получение отфильтрованных данных из нескольких таблиц</h4><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s1">'customers.id, customers.last_name, reviews.body'</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'reviews.created_at &gt; ?'</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">week</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
</code></pre>
</div>
<p>Результат должен быть примерно следующим:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">reviews</span><span class="p">.</span><span class="n">body</span>
<span class="k">FROM</span> <span class="n">customers</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span>
  <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="p">(</span><span class="n">reviews</span><span class="p">.</span><span class="n">created_at</span> <span class="o">&gt;</span> <span class="s1">'2019-01-08'</span><span class="p">)</span>
</code></pre>
</div>
<h4 id='poluchenie-opredelyonnyh-dannyh-iz-neskolkih-tablits' class='inside_page_header'><a href="#poluchenie-opredelyonnyh-dannyh-iz-neskolkih-tablits">18.2.</a> Получение определённых данных из нескольких таблиц</h4><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Book</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s1">'books.id, books.title, authors.first_name'</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:author</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">title: </span><span class="s1">'Abstraction and Specification in Program Development'</span><span class="p">)</span>
</code></pre>
</div>
<p>Выражение выше, сгенерирует следующий SQL-запрос:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="n">authors</span><span class="p">.</span><span class="n">first_name</span>
<span class="k">FROM</span> <span class="n">books</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">authors</span>
  <span class="k">ON</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="p">[[</span><span class="nv">"title"</span><span class="p">,</span> <span class="nv">"Abstraction and Specification in Program Development"</span><span class="p">]]</span>
<span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
</div>
<div class="note"><p>Обратите внимание, что если запросу соответствует несколько записей, <code>find_by</code> вернет только первую запись и проигнорирует остальные (смотрите <code>LIMIT 1</code> выше).</p></div><h3 id='poisk-ili-sozdanie-novogo-ob-ekta' class='inside_page_header'><a href="#poisk-ili-sozdanie-novogo-ob-ekta">19.</a> Поиск или создание нового объекта</h3><p>Часто бывает, что вам нужно найти запись или создать ее, если она не существует. Вы можете сделать это с помощью методов <code>find_or_create_by</code> и <code>find_or_create_by!</code>.</p><h4 id='find_or_create_by' class='inside_page_header'><a href="#find_or_create_by">19.1.</a> <code>find_or_create_by</code></h4><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a> проверяет, существует ли запись с определенными атрибутами. Если нет, то вызывается <code>create</code>. Давайте рассмотрим пример.</p><p>Предположим, вы хотите найти покупателя по имени &quot;Andy&quot;, и, если такого нет, создать его. Это можно сделать, выполнив:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">5</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Andy"</span><span class="p">,</span> <span class="ss">last_name: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">title: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">visits: </span><span class="mi">0</span><span class="p">,</span> <span class="ss">orders_count: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">lock_version: </span><span class="mi">0</span><span class="p">,</span> <span class="ss">created_at: </span><span class="s2">"2019-01-17 07:06:45"</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="s2">"2019-01-17 07:06:45"</span><span class="kt">&gt;</span>
</code></pre>
</div>
<p>SQL, генерируемый этим методом, будет выглядеть так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Andy'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">BEGIN</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">customers</span> <span class="p">(</span><span class="n">created_at</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">locked</span><span class="p">,</span> <span class="n">orders_count</span><span class="p">,</span> <span class="n">updated_at</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'2011-08-30 05:22:57'</span><span class="p">,</span> <span class="s1">'Andy'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">NULL</span><span class="p">,</span> <span class="s1">'2011-08-30 05:22:57'</span><span class="p">)</span>
<span class="k">COMMIT</span>
</code></pre>
</div>
<p><code>find_or_create_by</code> возвращает либо уже существующую запись, либо новую запись. В нашем случае, у нас еще нет покупателя с именем Andy, поэтому запись будет создана и возвращена.</p><p>Новая запись может быть не сохранена в базу данных; это зависит от того, прошли валидации или нет (подобно <code>create</code>).</p><p>Предположим, мы хотим установить атрибут &#39;locked&#39; как <code>false</code>, если создаем новую запись, но не хотим включать его в запрос. Таким образом, мы хотим найти покупателя по имени &quot;Andy&quot; или, если этот покупатель не существует, создать покупателя по имени &quot;Andy&quot;, который не заблокирован.</p><p>Этого можно достичь двумя способами. Первый - это использование <code>create_with</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">create_with</span><span class="p">(</span><span class="ss">locked: </span><span class="kp">false</span><span class="p">).</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
</code></pre>
</div>
<p>Второй способ - это использование блока:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
  <span class="n">c</span><span class="p">.</span><span class="nf">locked</span> <span class="o">=</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Блок будет выполнен, только если покупателя был создан. Во второй раз, при запуске этого кода, блок будет проигнорирован.</p><h4 id='find_or_create_by2' class='inside_page_header'><a href="#find_or_create_by2">19.2.</a> <code>find_or_create_by!</code></h4><p>Можно также использовать <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_create_by-21"><code>find_or_create_by!</code></a>, чтобы вызвать исключение, если новая запись невалидна. Валидации не раскрываются в этом руководстве, но давайте на момент предположим, что вы временно добавили</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">validates</span> <span class="ss">:orders_count</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
</code></pre>
</div>
<p>в модель <code>Customer</code>. Если попытаетесь создать нового <code>Customer</code> без передачи <code>orders_count</code>, запись будет невалидной и будет вызвано исключение:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_create_by!</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
<span class="go">ActiveRecord::RecordInvalid: Validation failed: Orders count can’t be blank
</span></code></pre>
</div>
<h4 id='find_or_initialize_by' class='inside_page_header'><a href="#find_or_initialize_by">19.3.</a> <code>find_or_initialize_by</code></h4><p>Метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_initialize_by"><code>find_or_initialize_by</code></a> работает похоже на <code>find_or_create_by</code>, но он вызывает не <code>create</code>, а <code>new</code>. Это означает, что новый экземпляр модели будет создан в памяти, но не будет сохранен в базу данных. Продолжая пример с <code>find_or_create_by</code>, теперь нам нужен покупатель по имени &#39;Nina&#39;:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_initialize_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Nina'</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Nina"</span><span class="p">,</span> <span class="ss">orders_count: </span><span class="mi">0</span><span class="p">,</span> <span class="ss">locked: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">created_at: </span><span class="s2">"2011-08-30 06:09:27"</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="s2">"2011-08-30 06:09:27"</span><span class="kt">&gt;</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span><span class="p">.</span><span class="nf">persisted?</span>
<span class="p">=&gt;</span> <span class="kp">false</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span><span class="p">.</span><span class="nf">new_record?</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre>
</div>
<p>Поскольку объект еще не сохранен в базу данных, сгенерированный SQL выглядит так:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Nina'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
</div>
<p>Когда захотите сохранить его в базу данных, просто вызовите <code>save</code>:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span><span class="p">.</span><span class="nf">save</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre>
</div>
<h3 id='poisk-s-pomoschyu-sql' class='inside_page_header'><a href="#poisk-s-pomoschyu-sql">20.</a> Поиск с помощью SQL</h3><p>Если вы предпочитаете использовать собственные запросы SQL для поиска записей в таблице, можете использовать <a href="https://api.rubyonrails.org/classes/ActiveRecord/Querying.html#method-i-find_by_sql"><code>find_by_sql</code></a>. Метод <code>find_by_sql</code> возвратит массив объектов, даже если лежащий в основе запрос вернет всего лишь одну запись. Например, можете запустить такой запрос:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by_sql</span><span class="p">(</span><span class="s2">"SELECT * FROM customers INNER JOIN orders ON customers.id = orders.customer_id ORDER BY customers.created_at desc"</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Lucas"</span> <span class="o">...</span><span class="kt">&gt;</span><span class="p">,</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Jan"</span> <span class="o">...</span><span class="kt">&gt;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</code></pre>
</div>
<p><code>find_by_sql</code> предоставляет простой способ создания произвольных запросов к базе данных и получения экземпляров объектов.</p><h4 id='select_all' class='inside_page_header'><a href="#select_all">20.1.</a> <code>select_all</code></h4><p>У <code>find_by_sql</code> есть близкий родственник, называемый <a href="https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-select_all"><code>connection.select_all</code></a>. <code>select_all</code> получит объекты из базы данных, используя произвольный SQL, как и в <code>find_by_sql</code>, но не создаст их экземпляры. Этот метод вернет экземпляр класса <code>ActiveRecord::Result</code> и вызов <code>to_a</code> на этом объекте вернет массив хэшей, где каждый хэш указывает на запись.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">select_all</span><span class="p">(</span><span class="s2">"SELECT first_name, created_at FROM customers WHERE id = '1'"</span><span class="p">).</span><span class="nf">to_a</span>
<span class="p">=&gt;</span> <span class="p">[{</span><span class="s2">"first_name"</span><span class="o">=&gt;</span><span class="s2">"Rafael"</span><span class="p">,</span> <span class="s2">"created_at"</span><span class="o">=&gt;</span><span class="s2">"2012-11-10 23:23:45.281189"</span><span class="p">},</span> <span class="p">{</span><span class="s2">"first_name"</span><span class="o">=&gt;</span><span class="s2">"Eileen"</span><span class="p">,</span> <span class="s2">"created_at"</span><span class="o">=&gt;</span><span class="s2">"2013-12-09 11:22:35.221282"</span><span class="p">}]</span>
</code></pre>
</div>
<h4 id='pluck' class='inside_page_header'><a href="#pluck">20.2.</a> <code>pluck</code></h4><p><a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-pluck"><code>pluck</code></a> может быть использован для подбора значения(-ий) из названного столбца(-ов) в текущем relation. Он принимает список имен столбцов как аргумент и возвращает массив значений определенных столбцов соответствующего типа данных.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="go">SELECT id FROM books WHERE out_of_print = true
</span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">distinct</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:status</span><span class="p">)</span>
<span class="go">SELECT DISTINCT status FROM orders
</span><span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"shipped"</span><span class="p">,</span> <span class="s2">"being_packed"</span><span class="p">,</span> <span class="s2">"cancelled"</span><span class="p">]</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">)</span>
<span class="go">SELECT customers.id, customers.first_name FROM customers
</span><span class="p">=&gt;</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"David"</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s2">"Fran"</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s2">"Jose"</span><span class="p">]]</span>
</code></pre>
</div>
<p><code>pluck</code> позволяет заменить такой код:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="n">c</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span>
<span class="c1"># или</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:id</span><span class="p">)</span>
<span class="c1"># или</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="nf">first_name</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
</div>
<p>на:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="c1"># или</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">)</span>
</code></pre>
</div>
<p>В отличие от <code>select</code>, <code>pluck</code> непосредственно конвертирует результат запроса в массив Ruby, без создания объектов <code>ActiveRecord</code>. Это может означать лучшую производительность для больших или часто используемых запросов. Однако, любые переопределения методов в модели будут недоступны. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nf">name</span>
    <span class="s2">"I am </span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">map</span> <span class="o">&amp;</span><span class="ss">:name</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"I am David"</span><span class="p">,</span> <span class="s2">"I am Jeremy"</span><span class="p">,</span> <span class="s2">"I am Jose"</span><span class="p">]</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"David"</span><span class="p">,</span> <span class="s2">"Jeremy"</span><span class="p">,</span> <span class="s2">"Jose"</span><span class="p">]</span>
</code></pre>
</div>
<p>Вы не ограничены запросом полей из одиночной таблицы, также можно запрашивать несколько таблиц.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:customer</span><span class="p">,</span> <span class="ss">:books</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="s2">"orders.created_at, customers.email, books.title"</span><span class="p">)</span>
</code></pre>
</div>
<p>Более того, в отличие от <code>select</code> и других скоупов <code>Relation</code>, <code>pluck</code> вызывает немедленный запрос, и поэтому не может быть соединен с любыми последующими скоупами, хотя он может работать со скоупами, подключенными ранее:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"David"</span><span class="p">]</span>
</code></pre>
</div>
<div class="note"><p>Следует знать, что использование <code>pluck</code> запустит нетерпеливую загрузку, если объект relation содержит включаемые значения, даже если нетерпеливая загрузка не нужна для запроса. Например:</p></div><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">assoc</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">assoc</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="go">SELECT "customers"."id" FROM "customers" LEFT OUTER JOIN "reviews" ON "reviews"."id" = "customers"."review_id"
</span></code></pre>
</div>
<p>Один из способов избежать этого — <code>unscope</code> на includes:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">assoc</span><span class="p">.</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:includes</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre>
</div>
<h4 id='pick' class='inside_page_header'><a href="#pick">20.3.</a> <code>pick</code></h4><p><a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-pick"><code>pick</code></a> может быть использован для подбора значения(-ий) из названного столбца(-ов) в текущем relation. Он принимает список имен столбцов как аргумент и возвращает первый ряд значений указанного столбца с соответствующим типом данных. <code>pick</code> это сокращение для <code>relation.limit(1).pluck(*column_names).first</code>, которой, в основном, полезно, когда у вас уже имеется relation, ограниченное одним рядом.</p><p><code>pick</code> позволяет заменить код, такой как:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">first</span>
</code></pre>
</div>
<p>на:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">pick</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre>
</div>
<h4 id='ids' class='inside_page_header'><a href="#ids">20.4.</a> <code>ids</code></h4><p><a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-ids"><code>ids</code></a> может быть использован для сбора всех ID для relation, используя первичный ключ таблицы.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">ids</span>
<span class="go">SELECT id FROM customers
</span></code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=</span> <span class="s2">"customer_id"</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">ids</span>
<span class="go">SELECT customer_id FROM customers
</span></code></pre>
</div>
<h3 id='suschestvovanie-ob-ektov' class='inside_page_header'><a href="#suschestvovanie-ob-ektov">21.</a> Существование объектов</h3><p>Если вы просто хотите проверить существование объекта, есть метод, называемый <a href="https://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-exists-3F"><code>exists?</code></a>. Этот метод запрашивает базу данных, используя тот же запрос, что и <code>find</code>, но вместо возврата объекта или коллекции объектов, он возвращает или <code>true</code>, или <code>false</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre>
</div>
<p>Метод <code>exists?</code> также принимает несколько значений, при этом возвращает <code>true</code>, если хотя бы одна из этих записей существует.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1"># или</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">first_name: </span><span class="p">[</span><span class="s1">'Jane'</span><span class="p">,</span> <span class="s1">'Sergei'</span><span class="p">])</span>
</code></pre>
</div>
<p>Даже возможно использовать <code>exists?</code> без аргументов на модели или relation:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">).</span><span class="nf">exists?</span>
</code></pre>
</div>
<p>Пример выше вернет <code>true</code>, если есть хотя бы один покупатель с <code>first_name</code> &#39;Ryan&#39;, и <code>false</code> в противном случае.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span>
</code></pre>
</div>
<p>Это возвратит <code>false</code>, если таблица <code>customers</code> пустая, и <code>true</code> в противном случае.</p><p>Для проверки на существование также можно использовать <code>any?</code> и <code>many?</code> на модели или relation. <code>many?</code> будет использовать SQL <code>count</code>, для определения, существует ли элемент.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># на модели</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">any?</span>
<span class="c1"># SELECT 1 FROM orders LIMIT 1</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">many?</span>
<span class="c1"># SELECT COUNT(*) FROM (SELECT 1 FROM orders LIMIT 2)</span>

<span class="c1"># на именованном скоупе</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span><span class="p">.</span><span class="nf">any?</span>
<span class="c1"># SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 1</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span><span class="p">.</span><span class="nf">many?</span>
<span class="c1"># SELECT COUNT(*) FROM (SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 2)</span>

<span class="c1"># на relation</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">any?</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">many?</span>

<span class="c1"># на связи</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">any?</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">many?</span>
</code></pre>
</div>
<h3 id='calculations' class='inside_page_header'><a href="#calculations">22.</a>  Вычисления</h3><p>Этот раздел использует <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-count"><code>count</code></a> для примера в этой преамбуле, но описанные опции применяются ко всем подразделам.</p><p>Все методы вычисления работают прямо на модели:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">count</span>
<span class="go">SELECT COUNT(*) FROM customers
</span></code></pre>
</div>
<p>Или на relation:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">).</span><span class="nf">count</span>
<span class="go">SELECT COUNT(*) FROM customers WHERE (first_name = 'Ryan')
</span></code></pre>
</div>
<p>Можно также использовать различные методы поиска на relation для выполнения сложных вычислений:</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="s2">"orders"</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">,</span> <span class="ss">orders: </span><span class="p">{</span> <span class="ss">status: </span><span class="s1">'shipped'</span> <span class="p">}).</span><span class="nf">count</span>
</code></pre>
</div>
<p>Что выполнит:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
  <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span> <span class="k">AND</span> <span class="n">orders</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</code></pre>
</div>
<p>при условии что в Order есть <code>enum status: [ :shipped, :being_packed, :cancelled ]</code></p><h4 id='count' class='inside_page_header'><a href="#count">22.1.</a> <code>count</code></h4><p>Если хотите увидеть, сколько записей есть в таблице модели, можете вызвать <code>Customer.count</code>, и он возвратит число. Если хотите быть более определенным и найти всех покупателей с присутствующим в базе данных титулом, используйте <code>Customer.count(:title)</code>.</p><p>Про опции смотрите выше в разделе <a href="#calculations">Вычисления</a>.</p><h4 id='average' class='inside_page_header'><a href="#average">22.2.</a> <code>average</code></h4><p>Если хотите увидеть среднее значение определенного показателя в одной из ваших таблиц, можно вызвать метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-average"><code>average</code></a> для класса, относящегося к таблице. Вызов этого метода выглядит так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre>
</div>
<p>Это возвратит число (возможно, с плавающей запятой, такое как 3.14159265), представляющее среднее значение поля.</p><p>Про опции смотрите выше в разделе <a href="#calculations">Вычисления</a>.</p><h4 id='minimum' class='inside_page_header'><a href="#minimum">22.3.</a> <code>minimum</code></h4><p>Если хотите найти минимальное значение поля в таблице, можете вызвать метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-minimum"><code>minimum</code></a> для класса, относящегося к таблице. Вызов этого метода выглядит так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre>
</div>
<p>Про опции смотрите выше в разделе <a href="#calculations">Вычисления</a>.</p><h4 id='maximum' class='inside_page_header'><a href="#maximum">22.4.</a> <code>maximum</code></h4><p>Если хотите найти максимальное значение поля в таблице, можете вызвать метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-maximum"><code>maximum</code></a> для класса, относящегося к таблице. Вызов этого метода выглядит так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre>
</div>
<p>Про опции смотрите выше в разделе <a href="#calculations">Вычисления</a>.</p><h4 id='sum' class='inside_page_header'><a href="#sum">22.5.</a> <code>sum</code></h4><p>Если хотите найти сумму полей для всех записей в таблице, можете вызвать метод <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-sum"><code>sum</code></a> для класса, относящегося к таблице. Вызов этого метода выглядит так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre>
</div>
<p>Про опции смотрите выше в разделе <a href="#calculations">Вычисления</a>.</p><h3 id='zapusk-explain' class='inside_page_header'><a href="#zapusk-explain">23.</a> Запуск EXPLAIN</h3><p>Можно запустить <a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-explain"><code>explain</code></a> на запросах, вызываемых в relations. Вывод EXPLAIN различается для каждой базы данных.</p><p>Например, запуск</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span>
</code></pre>
</div>
<p>может выдать</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="nv">`customers`</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">`customers`</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">`orders`</span> <span class="k">ON</span> <span class="nv">`orders`</span><span class="p">.</span><span class="nv">`customer_id`</span> <span class="o">=</span> <span class="nv">`customers`</span><span class="p">.</span><span class="nv">`id`</span> <span class="k">WHERE</span> <span class="nv">`customers`</span><span class="p">.</span><span class="nv">`id`</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">+</span><span class="c1">----+-------------+------------+-------+---------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>      <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+------------+-------+---------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">customers</span>  <span class="o">|</span> <span class="n">const</span> <span class="o">|</span> <span class="k">PRIMARY</span>       <span class="o">|</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">orders</span>     <span class="o">|</span> <span class="k">ALL</span>   <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+------------+-------+---------------+</span>
<span class="o">+</span><span class="c1">---------+---------+-------+------+-------------+</span>
<span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>   <span class="o">|</span> <span class="k">rows</span> <span class="o">|</span> <span class="n">Extra</span>       <span class="o">|</span>
<span class="o">+</span><span class="c1">---------+---------+-------+------+-------------+</span>
<span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">4</span>       <span class="o">|</span> <span class="n">const</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>             <span class="o">|</span>
<span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>    <span class="o">|</span> <span class="k">NULL</span>  <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">---------+---------+-------+------+-------------+</span>

<span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre>
</div>
<p>для MySQL и MariaDB.</p><p>Active Record применяет красивое форматирование, эмулирующее работу соответствующей оболочки базы данных. Таким образом, запуск того же запроса с адаптером PostgreSQL выдаст вместо этого</p><div class="code_container">
  <pre><code class="highlight plaintext">EXPLAIN SELECT "customers".* FROM "customers" INNER JOIN "orders" ON "orders"."customer_id" = "customers"."id" WHERE "customers"."id" = $1 [["id", 1]]
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop  (cost=4.33..20.85 rows=4 width=164)
    -&gt;  Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
          Index Cond: (id = '1'::bigint)
    -&gt;  Bitmap Heap Scan on orders  (cost=4.18..12.64 rows=4 width=8)
          Recheck Cond: (customer_id = '1'::bigint)
          -&gt;  Bitmap Index Scan on index_orders_on_customer_id  (cost=0.00..4.18 rows=4 width=0)
                Index Cond: (customer_id = '1'::bigint)
(7 rows)
</code></pre>
</div>
<p>Нетерпеливая загрузка может вызвать более одного запроса за раз, и некоторым запросам могут потребоваться результаты предыдущих. Поэтому <code>explain</code> фактически выполняет запрос, а затем запрашивает планы запросов. Например,</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span>
</code></pre>
</div>
<p>может выдать это для MySQL и MariaDB:</p><div class="code_container">
  <pre><code class="highlight plaintext">EXPLAIN SELECT `customers`.* FROM `customers`  WHERE `customers`.`id` = 1
+----+-------------+-----------+-------+---------------+
| id | select_type | table     | type  | possible_keys |
+----+-------------+-----------+-------+---------------+
|  1 | SIMPLE      | customers | const | PRIMARY       |
+----+-------------+-----------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN SELECT `orders`.* FROM `orders`  WHERE `orders`.`customer_id` IN (1)
+----+-------------+--------+------+---------------+
| id | select_type | table  | type | possible_keys |
+----+-------------+--------+------+---------------+
|  1 | SIMPLE      | orders | ALL  | NULL          |
+----+-------------+--------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)
</code></pre>
</div>
<p>и может выдать это для PostgreSQL:</p><div class="code_container">
  <pre><code class="highlight plaintext">  Customer Load (0.3ms)  SELECT "customers".* FROM "customers" WHERE "customers"."id" = $1  [["id", 1]]
  Order Load (0.3ms)  SELECT "orders".* FROM "orders" WHERE "orders"."customer_id" = $1  [["customer_id", 1]]
=&gt; EXPLAIN SELECT "customers".* FROM "customers" WHERE "customers"."id" = $1 [["id", 1]]
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
   Index Cond: (id = '1'::bigint)
(2 rows)
</code></pre>
</div>
<h4 id='optsii-explain' class='inside_page_header'><a href="#optsii-explain">23.1.</a> Опции Explain</h4><p>Для баз данных и адаптеров, поддерживающих их (в настоящее время PostgreSQL и MySQL), можно передать опции, чтобы предоставить углубленный анализ.</p><p>Для PostgreSQL, следующее:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span><span class="p">(</span><span class="ss">:analyze</span><span class="p">,</span> <span class="ss">:verbose</span><span class="p">)</span>
</code></pre>
</div>
<p>выдаст:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">EXPLAIN</span> <span class="p">(</span><span class="k">ANALYZE</span><span class="p">,</span> <span class="k">VERBOSE</span><span class="p">)</span> <span class="k">SELECT</span> <span class="nv">"shop_accounts"</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">"shop_accounts"</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">"customers"</span> <span class="k">ON</span> <span class="nv">"customers"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="nv">"shop_accounts"</span><span class="p">.</span><span class="nv">"customer_id"</span> <span class="k">WHERE</span> <span class="nv">"shop_accounts"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="p">[[</span><span class="nv">"id"</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                                                                   <span class="n">QUERY</span> <span class="n">PLAN</span>
<span class="c1">------------------------------------------------------------------------------------------------------------------------------------------------</span>
 <span class="n">Nested</span> <span class="n">Loop</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">30</span><span class="p">..</span><span class="mi">16</span><span class="p">.</span><span class="mi">37</span> <span class="k">rows</span><span class="o">=</span><span class="mi">1</span> <span class="n">width</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span> <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">003</span><span class="p">..</span><span class="mi">0</span><span class="p">.</span><span class="mi">004</span> <span class="k">rows</span><span class="o">=</span><span class="mi">0</span> <span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
   <span class="k">Output</span><span class="p">:</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">,</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_carrier_id</span>
   <span class="k">Inner</span> <span class="k">Unique</span><span class="p">:</span> <span class="k">true</span>
   <span class="o">-&gt;</span>  <span class="k">Index</span> <span class="n">Scan</span> <span class="k">using</span> <span class="n">shop_accounts_pkey</span> <span class="k">on</span> <span class="k">public</span><span class="p">.</span><span class="n">shop_accounts</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">15</span><span class="p">..</span><span class="mi">8</span><span class="p">.</span><span class="mi">17</span> <span class="k">rows</span><span class="o">=</span><span class="mi">1</span> <span class="n">width</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span> <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">003</span><span class="p">..</span><span class="mi">0</span><span class="p">.</span><span class="mi">003</span> <span class="k">rows</span><span class="o">=</span><span class="mi">0</span> <span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
         <span class="k">Output</span><span class="p">:</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">,</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_carrier_id</span>
         <span class="k">Index</span> <span class="n">Cond</span><span class="p">:</span> <span class="p">(</span><span class="n">shop_accounts</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="s1">'1'</span><span class="p">::</span><span class="nb">bigint</span><span class="p">)</span>
   <span class="o">-&gt;</span>  <span class="k">Index</span> <span class="k">Only</span> <span class="n">Scan</span> <span class="k">using</span> <span class="n">customers_pkey</span> <span class="k">on</span> <span class="k">public</span><span class="p">.</span><span class="n">customers</span>  <span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">15</span><span class="p">..</span><span class="mi">8</span><span class="p">.</span><span class="mi">17</span> <span class="k">rows</span><span class="o">=</span><span class="mi">1</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="n">never</span> <span class="n">executed</span><span class="p">)</span>
         <span class="k">Output</span><span class="p">:</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
         <span class="k">Index</span> <span class="n">Cond</span><span class="p">:</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">shop_accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">)</span>
         <span class="n">Heap</span> <span class="n">Fetches</span><span class="p">:</span> <span class="mi">0</span>
 <span class="n">Planning</span> <span class="nb">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">063</span> <span class="n">ms</span>
 <span class="n">Execution</span> <span class="nb">Time</span><span class="p">:</span> <span class="mi">0</span><span class="p">.</span><span class="mi">011</span> <span class="n">ms</span>
<span class="p">(</span><span class="mi">12</span> <span class="k">rows</span><span class="p">)</span>
</code></pre>
</div>
<p>Для MySQL или MariaDB, следующее:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span><span class="p">(</span><span class="ss">:analyze</span><span class="p">)</span>
</code></pre>
</div>
<p>выдаст:</p><div class="code_container">
  <pre><code class="highlight sql"><span class="k">ANALYZE</span> <span class="k">SELECT</span> <span class="nv">`shop_accounts`</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="nv">`shop_accounts`</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">`customers`</span> <span class="k">ON</span> <span class="nv">`customers`</span><span class="p">.</span><span class="nv">`id`</span> <span class="o">=</span> <span class="nv">`shop_accounts`</span><span class="p">.</span><span class="nv">`customer_id`</span> <span class="k">WHERE</span> <span class="nv">`shop_accounts`</span><span class="p">.</span><span class="n">id</span><span class="nv">` = 1
+----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | r_rows | filtered | r_filtered | Extra                          |
+----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+
|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL   | NULL     | NULL       | no matching row in const table |
+----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+
1 row in set (0.00 sec)
</span></code></pre>
</div>
<div class="note"><p>Опции EXPLAIN и ANALYZE варьируются для разных версий MySQL и MariaDB. (<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html">MySQL 5.7</a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">MySQL 8.0</a>, <a href="https://mariadb.com/kb/en/analyze-and-explain-statements/">MariaDB</a>)</p></div><h4 id='interpretatsiya-explain' class='inside_page_header'><a href="#interpretatsiya-explain">23.2.</a> Интерпретация EXPLAIN</h4><p>Интерпретация результатов EXPLAIN находится за рамками этого руководства. Может быть полезной следующая информация:</p><ul><li><p>SQLite3: <a href="https://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p></li><li><p>MySQL: <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">EXPLAIN Output Format</a></p></li><li><p>MariaDB: <a href="https://mariadb.com/kb/en/mariadb/explain/">EXPLAIN</a></p></li><li><p>PostgreSQL: <a href="https://postgrespro.ru/docs/postgrespro/current/using-explain">Using EXPLAIN</a></p></li></ul>

            <div class="banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

   <!-- bottom rusrails -->
   <ins class="adsbygoogle"
        style="display:inline-block;width:580px;height:400px"
        data-ad-client="ca-pub-7764391801669990"
        data-ad-slot="7566253867"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
          </div>
        </div>
        <div class="row-fluid">
          <div class="span12" id="footer">
            <p>
              <a target="blank" href="https://github.com/rusrails/rusrails"><img src="/assets/github-7cc23602a5ac2465f14c19492358a5a67dc24636761cc723e4d621cea0c09225.png" /></a>
              <a target="blank" href="http://twitter.com/rusrails"><img src="/assets/twitter-50e0e767c8793dec313a7dc5cfbcfe2067e3e89ea6ec64784eb7c6640f578758.png" /></a>
            </p>
            <p>
              <a href="https://creativecommons.org/licenses/by-sa/4.0/">Лицензия CC BY-SA 4.0</a>
              "Rails", "Ruby on Rails" и логотип Rails - торговые марки DHH
              <!-- Yandex.Metrika counter -->
<script>
  (function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter1006929 = new Ya.Metrika({id:1006929,
                    webvisor:true,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>

<noscript>
  <div>
    <img style="position:absolute; left:-9999px;" alt="" src="//mc.yandex.ru/watch/1006929" />
  </div>
</noscript>
<!-- /Yandex.Metrika counter -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-64955373-1', 'auto');
  ga('send', 'pageview');

  var trackOutboundLink = function(url) {
    ga('send', 'event', 'outbound', 'click', url, {
      'transport': 'beacon',
      'hitCallback': function(){ }
    });
  }
</script>

            </p>
          </div>
        </div>
      </div>
    </div>
    <div class="to_top" style="display: block">
      <div class="to_top_panel"></div>
    </div>
    <script src="/assets/application-8ee447905888b153d8458707061a14b1f15f69b6733e871a3ad91d80ae89e87b.js"></script>
  </body>
</html>
