<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8">
<meta content="Ruby on Rails, Ruby, Rails, Rails 3, Rails 4, Rails 5, Rails 6, Rails 6.0, Rails 6.1, Rails 7.0, Rails 7.1 руководство, начинающим, самоучитель, manual, мануал, справочник, учебник, примеры, Руби, рельсы" name="keywords"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" name="description"/>
<meta content="product" property="twitter:card"/>
<meta content="@rusrails" property="twitter:site"/>
<meta content="Rusrails: Engine для начинающих" property="twitter:title"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" property="twitter:description"/>
<meta content="@rusrails" property="twitter:creator"/>
<meta content="http://rusrails.ru/assets/rusrails.png" property="twitter:image"/>
<meta content="website" property="og:type"/>
<meta content="Rusrails: Engine для начинающих" property="og:title"/>
<meta content="Ruby on Rails руководства, учебники, статьи на русском языке" property="og:description"/>
<meta content="http://localhost:3000/engines" property="og:url"/>
<meta content="http://rusrails.ru/assets/rusrails.png" property="og:image"/>
    <title>
      Rusrails: Engine для начинающих
    </title>
    <link rel="stylesheet" media="screen" href="/assets/application-4f65588939909a694017a295c9ca934821f6a6358454c26c5360579d7ee0054d.css" />
  </head>
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="brand" href="/"></a>
          <ul class="nav pull-right top-menu">
            <li>
              <a href="/">Главная</a>
            </li>
            <li class="dropdown">
              <a class="index-popover" href="#">
                Содержание
                <b class="caret"></b>
</a>              <div class="index-popover-content hide">
                  <ul><li><p><strong>С чего начать?</strong></p><ul><li><a href="/getting-started">Rails для начинающих</a>
</li></ul></li><li><p><strong>Модели</strong></p><ul><li><a href="/active-record-basics">Основы Active Record</a>
</li><li><a href="/active-record-migrations">Миграции Active Record</a>
</li><li><a href="/active-record-validations">Валидации Active Record</a>
</li><li><a href="/active-record-callbacks">Колбэки Active Record</a>
</li><li><a href="/active-record-associations">Связи (ассоциации) Active Record</a>
</li><li><a href="/active-record-querying">Интерфейс запросов Active Record</a>
</li><li><a href="/active-model-basics">Основы Active Model</a>
</li></ul></li><li><p><strong>Вью</strong></p><ul><li><a href="/action-view-overview">Обзор Action View</a>
</li><li><a href="/layouts-and-rendering">Макеты и рендеринг в Rails</a>
</li><li><a href="/action-view-helpers">Хелперы Action View</a>
</li><li><a href="/form-helpers">Хелперы форм в Action View</a>
</li></ul></li><li><p><strong>Контроллеры</strong></p><ul><li><a href="/action-controller-overview">Обзор Action Controller</a>
</li><li><a href="/routing">Роутинг в Rails</a>
</li></ul></li><li><p><strong>Другие компоненты</strong></p><ul><li><a href="/active-support-core-extensions">Расширения ядра Active Support</a>
</li><li><a href="/action-mailer-basics">Основы Action Mailer</a>
</li><li><a href="/action-mailbox-basics">Основы Action Mailbox</a>
</li><li><a href="/action-text-overview">Обзор Action Text</a>
</li><li><a href="/active_job_basics">Основы Active Job</a>
</li><li><a href="/active_storage_overview">Обзор Active Storage</a>
</li><li><a href="/action-cable-overview">Обзор Action Cable</a>
</li></ul></li><li><p><strong>Копаем глубже</strong></p><ul><li><a href="/i18n">API интернационализации Rails (I18n)</a>
</li><li><a href="/testing">Тестирование приложений на Rails</a>
</li><li><a href="/security">Безопасность приложений на Rails</a>
</li><li><a href="/error-reporting">Отчет об ошибках в приложениях Rails</a>
</li></ul></li></ul><p>next_column</p><ul><li><p><strong>Копаем глубже</strong></p><ul><li><a href="/debugging-rails-applications">Отладка приложений на Rails</a>
</li><li><a href="/configuring">Конфигурирование приложений на Rails</a>
</li><li><a href="/command-line">Командная строка Rails</a>
</li><li><a href="/asset-pipeline">Asset Pipeline</a>
</li><li><a href="/working-with-javascript-in-rails">Работа с JavaScript в Rails</a>
</li><li><a href="/initialization">Процесс инициализации в Rails</a>
</li><li><a href="/autoloading-and-reloading-constants">Автозагрузка и перезагрузка констант</a>
</li><li><a href="/classic-to-zeitwerk-howto">Как перейти с Classic на Zeitwerk</a>
</li><li><a href="/caching-with-rails">Кэширование с Rails: Обзор</a>
</li><li><a href="/active-support-instrumentation">Инструментарий Active Support</a>
</li><li><a href="/api-app">Использование Rails для API-приложений</a>
</li><li><a href="/active-record-postgresql">Active Record для PostgreSQL</a>
</li><li><a href="/active-record-multiple-databases">Несколько баз данных с Active Record</a>
</li><li><a href="/active-record-encryption">Шифрование Active Record</a>
</li></ul></li><li><p><strong>Расширяем Rails</strong></p><ul><li><a href="/plugins">Основы создания плагинов Rails</a>
</li><li><a href="/rails-on-rack">Rails on Rack</a>
</li><li><a href="/generators">Создание и настройка генераторов и шаблонов Rails</a>
</li><li><a href="/engines">Engine для начинающих</a>
</li><li><a href="/threading_and_code_execution">Треды и выполнение кода в Rails</a>
</li><li><a href="/rails-application-templates">Шаблоны приложения Rails</a>
</li></ul></li><li><p><strong>Вносим вклад в Ruby on Rails</strong></p><ul><li><a href="/contributing_to_ruby_on_rails">Вносим вклад в Ruby on Rails</a>
</li><li><a href="/api_documentation_guidelines">Рекомендации по документированию API</a>
</li><li><a href="/ruby_on_rails_guides_guidelines">Рекомендации для руководств по Ruby on Rails</a>
</li><li><a href="/development_dependencies_install">Установка зависимостей для разработки</a>
</li><li><a href="/maintenance-policy">Политика поддержки (версий)</a>
</li></ul></li><li><p><strong>Заметки о релизах</strong></p><ul><li><a href="/upgrading-ruby-on-rails">Апгрейд Ruby on Rails</a>
</li><li><a href="/7_1_release_notes">Версия 7.1 - ?</a>
</li><li><a href="/7_0_release_notes">Версия 7.0 - Декабрь 2021</a>
</li><li><a href="/6_1_release_notes">Версия 6.1 - Декабрь 2020</a>
</li><li><a href="/6_0_release_notes">Версия 6.0 - Август 2019</a>
</li></ul></li></ul>
              </div>
            </li>
            <li>
              <a href="/search">Поиск</a>
            </li>
            <li>
              <a target="blank" href="http://api.rusrails.ru">Ruby &amp; Rails API</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content-wrapper">
      <div class="container-fluid">
        <div class="row-fluid">
          <div class="span3 pull-right">
            <div class="well social">
              <h4>Принимаем пожелания и пул-реквесты!</h4>
              <iframe allowtransparency="true" frameborder="0" height="30" src="http://ghbtns.com/github-btn.html?user=rusrails&repo=rusrails&type=watch&count=true&size=large" width="180"></iframe>
              <p></p>
              <a class="twitter-follow-button" data-lang="ru" href="https://twitter.com/rusrails"></a>
            </div>
              <div class="well menu">
                    <ul class="nav nav-list">
      <li>
        <h4>
          <a href="#chto-takoe-engine">1. Что такое engine?</a>
</h4>      </li>
      <li>
        <h4>
          <a href="#sozdanie-engine">2. Создание engine</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#vnutri-engine">2.1. Внутри Engine</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#kritichnye-fayly">2.1.1. Критичные файлы</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#direktoriya-app">2.1.2. Директория <code>app</code></a>
</h6>      </li>
      <li>
        <h6>
          <a href="#direktoriya-bin">2.1.3. Директория <code>bin</code></a>
</h6>      </li>
      <li>
        <h6>
          <a href="#test-directory">2.1.4.  Директория <code>test</code></a>
</h6>      </li>
      <li>
        <h4>
          <a href="#predostavlyaem-funktsionalnost-engine">3. Предоставляем функциональность engine</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#sozdaem-resurs-article">3.1. Создаем ресурс Article</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#sozdanie-resursa-kommentariev">3.2. Создание ресурса комментариев</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#vnedrenie-v-prilozhenie">4. Внедрение в приложение</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#montirovanie-engine">4.1. Монтирование Engine</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#nastroyka-engine">4.2. Настройка engine</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#ispolzovanie-klassa-predostavlennogo-prilozheniem">4.3. Использование класса, предоставленного приложением</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#ispolzovanie-modeli-predostavlennoy-prilozheniem">4.3.1. Использование модели, предоставленной приложением</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#ispolzovanie-kontrollera-predostavlennogo-prilozheniem">4.3.2. Использование контроллера, предоставленного приложением</a>
</h6>      </li>
      <li>
        <h5>
          <a href="#konfigurirovanie-engine">4.4. Конфигурирование Engine</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#ustanovka-konfiguratsionnyh-nastroek-v-prilozhenii">4.4.1. Установка конфигурационных настроек в приложении</a>
</h6>      </li>
      <li>
        <h6>
          <a href="#konfiguratsiya-engine-obschego-haraktera">4.4.2. Конфигурация Engine общего характера</a>
</h6>      </li>
      <li>
        <h4>
          <a href="#testirovanie-engine">5. Тестирование engine</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#funktsionalnye-testy">5.1. Функциональные тесты</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#uluchshenie-funktsionalnosti-engine">6. Улучшение функциональности engine</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#pereopredelenie-modeley-i-kontrollerov">6.1. Переопределение моделей и контроллеров</a>
</h5>      </li>
      <li>
        <h6>
          <a href="#pereotkrytie-suschestvuyuschih-klassov-s-ispolzovaniem-class_eval">6.1.1. Переоткрытие существующих классов с использованием <code>class_eval</code></a>
</h6>      </li>
      <li>
        <h6>
          <a href="#izmenenie-suschestvuyuschih-klassov-s-ispolzovaniem-activesupport-concern">6.1.2. Изменение существующих классов с использованием ActiveSupport::Concern</a>
</h6>      </li>
      <li>
        <h5>
          <a href="#avtozagruzka-i-engine">6.2. Автозагрузка и Engine</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#pereopredelenie-vyu">6.3. Переопределение вью</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#routes">6.4.  Маршруты</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#resursy-assets">6.5. Ресурсы (assets)</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#otdelnye-resursy-i-prekompilyatsiya">6.6. Отдельные ресурсы и прекомпиляция</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#zavisimosti-ot-drugih-gemov">6.7. Зависимости от других гемов</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#huki-zagruzki-i-konfiguratsii">7. Хуки загрузки и конфигурации</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#izbegayte-zagruzki-freymvorkov-rails">7.1. Избегайте загрузки фреймворков Rails</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#kogda-vyzyvayutsya-huki">7.2. Когда вызываются хуки</a>
</h5>      </li>
      <li>
        <h4>
          <a href="#modifitsirovanie-koda-dlya-ispolzovaniya-hukov-zagruzki">8. Модифицирование кода для использования хуков загрузки</a>
</h4>      </li>
      <li>
        <h5>
          <a href="#dostupnye-huki-zagruzki">8.1. Доступные хуки загрузки</a>
</h5>      </li>
      <li>
        <h5>
          <a href="#dostupnye-huki-nastroyki">8.2. Доступные хуки настройки</a>
</h5>      </li>
</ul>

              </div>
            <div class="well banner300 banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<!-- sidebar rusrails -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-7764391801669990"
     data-ad-slot="6089520660"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
          </div>
          <div class="span9 content pull-left">
            <div class="banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <!-- top rusrails -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:980px;height:120px"
       data-ad-client="ca-pub-7764391801669990"
       data-ad-slot="4891989065"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
              <h2 id='engine-dlya-nachinayuschih' class='inside_page_header'> Engine для начинающих</h2><p>В этом руководстве вы узнаете об engine, и как они могут быть использованы для предоставления дополнительной функциональности содержащим их приложениям с помощью понятного и простого для понимания интерфейса.</p><p>После прочтения этого руководства, вы узнаете:</p><ul><li>Зачем нужен engine.
</li><li>Как создать engine.
</li><li>Как встраивать особенности в engine.
</li><li>Как внедрять engine в приложение.
</li><li>Как переопределить функциональность engine из приложения.
</li><li>Как избежать загрузки фреймворков Rails с помощью хуков для загрузки и настройки.
</li></ul><h3 id='chto-takoe-engine' class='inside_page_header'><a href="#chto-takoe-engine">1.</a> Что такое engine?</h3><p>Engine можно рассматривать как миниатюрное приложение, предоставляющее функциональность содержащим его приложениям. Приложение Rails фактически всего лишь &quot;прокачанный&quot; engine с классом <code>Rails::Application</code>, унаследовавшим большую часть своего поведения от <code>Rails::Engine</code>.</p><p>Следовательно, об engine и приложении можно говорить как примерно об одном и том же, с небольшими различиями, как вы увидите в этом руководстве. Engine и приложение также используют одинаковую структуру.</p><p>Engine также близок к плагину, они оба имеют одинаковую структуру директории <code>lib</code> и оба создаются с помощью генератора <code>rails plugin new</code>. Разница в том, что engine рассматривается Rails как &quot;full plugin&quot; (на что указывает опция <code>--full</code>, передаваемая в команду генератора). Фактически, тут мы будем использовать опцию <code>--mountable</code>, включающую все особенности <code>--full</code> и кое-что еще. Впрочем, в этом руководстве эти &quot;full plugins&quot; будут называться просто &quot;engine&quot;. Engine <strong>может</strong> быть плагином, а плагин <strong>может</strong> быть engine.</p><p>Engine, который будет создан в этом руководстве, называется &quot;blorgh&quot;. Этот engine предоставит функциональность блога содержащим его приложениям, позволяя создавать новые статьи и комментарии. В начале этого руководства мы поработаем отдельно с самим engine, но в последующих разделах посмотрим, как внедрить его в приложение.</p><p>Engine также может быть отделен от содержащих его приложений. Это означает, что приложение может иметь маршрутный хелпер, такой как <code>articles_path</code>, и использовать engine, также предоставляющий путь с именем <code>articles_path</code>, и они оба не будут конфликтовать. Наряду с этим, контроллеры, модели и имена таблиц также выделены в пространство имен. Вы узнаете, как это сделать, позже в этом руководстве.</p><p>Важно все время помнить, что приложение <strong>всегда</strong> должно иметь приоритет над его engine. Приложение - это объект, имеющий последнее слово в том, что происходит в его среде. Engine должен только улучшать ее, но не изменять радикально.</p><p>Для демонстрации других engine, смотрите <a href="https://github.com/plataformatec/devise">Devise</a>, engine, предоставляющий аутентификацию для содержащих его приложений, или <a href="https://github.com/thredded/thredded">Thredded</a>, engine, предоставляющий функциональность форума. Также имеется <a href="https://github.com/spree/spree">Spree</a>, предоставляющий платформу электронной коммерции, и <a href="https://github.com/refinery/refinerycms">Refinery CMS</a>, CMS engine.</p><p>Наконец, engine не был бы возможен без работы James Adam, Piotr Sarnacki, Rails Core Team, и ряда других людей. Если вы с ними встретитесь, не забудьте поблагодарить!</p><h3 id='sozdanie-engine' class='inside_page_header'><a href="#sozdanie-engine">2.</a> Создание engine</h3><p>Чтобы создать engine, необходимо запустить генератор плагинов и передать ему подходящие для нужд опции. Для примера с &quot;blorgh&quot;, нужно создать &quot;монтируемый&quot; engine, запустив в терминале эту команду:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">rails </span>plugin new blorgh <span class="nt">--mountable</span>
</code></pre>
</div>
<p>Можно просмотреть полный список опций для генератора плагина, написав:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">rails </span>plugin <span class="nt">--help</span>
</code></pre>
</div>
<p>Опция <code>--mountable</code> сообщает генератору, что вы хотите создать &quot;монтируемый&quot; и изолированный engine. Этот генератор предоставляет ту же структуру скелета, как и с опцией <code>--full</code>. Опция <code>--full</code> сообщает генератору, что вы хотите создать engine, включая скелет следующей структуры:</p><ul><li>Дерево директории <code>app</code>
</li><li><p>Файл <code>config/routes.rb</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
<span class="k">end</span>
</code></pre>
</div>
</li><li><p>Файл <code>lib/blorgh/engine.rb</code>, идентичный по функции стандартному файлу приложения Rails <code>config/application.rb</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
</li></ul><p>Опция <code>--mountable</code> добавит к опции <code>--full</code>:</p><ul><li>Файлы манифестов ресурсов (<code>blorgh_manifest.js</code> и <code>application.css</code>)
</li><li>Пустой <code>ApplicationController</code> в пространстве имен
</li><li>Пустой <code>ApplicationHelper</code> в пространстве имен
</li><li>Шаблон макета вью для engine
</li><li><p>Изоляцию в пространстве имен для <code>config/routes.rb</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
<span class="k">end</span>
</code></pre>
</div>
</li><li><p>Изоляцию в пространстве имен для <code>lib/blorgh/engine.rb</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
    <span class="n">isolate_namespace</span> <span class="no">Blorgh</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
</li></ul><p>Кроме того, опция <code>--mountable</code> сообщает генератору смонтировать engine в пустом тестовом приложении, расположенном в <code>test/dummy</code>, поместив следующую строку в маршрутный файл пустого приложения <code>test/dummy/config/routes.rb</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">mount</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span> <span class="o">=&gt;</span> <span class="s2">"/blorgh"</span>
</code></pre>
</div>
<h4 id='vnutri-engine' class='inside_page_header'><a href="#vnutri-engine">2.1.</a> Внутри Engine</h4><h5 id='kritichnye-fayly' class='inside_page_header'><a href="#kritichnye-fayly">2.1.1.</a> Критичные файлы</h5><p>В корне директории нового engine есть файл <code>blorgh.gemspec</code>. Позже, когда вы будете включать engine в приложение, это нужно будет сделать с помощью следующей строчки в <code>Gemfile</code> приложения:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">gem</span> <span class="s1">'blorgh'</span><span class="p">,</span> <span class="ss">path: </span><span class="s1">'engines/blorgh'</span>
</code></pre>
</div>
<p>Не забудьте запустить <code>bundle install</code>, как обычно. Если указать его как гем в <code>Gemfile</code>, Bundler так его и загрузит, спарсив файл <code>blorgh.gemspec</code>, и затребовав файл в директории <code>lib</code> по имени <code>lib/blorgh.rb</code>. Этот файл требует файл <code>blorgh/engine.rb</code> (расположенный в <code>lib/blorgh/engine.rb</code>) и определяет базовый модуль по имени <code>Blorgh</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"blorgh/engine"</span>

<span class="k">module</span> <span class="nn">Blorgh</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="info"><p>В некоторых engine этот файл используется для размещения глобальных конфигурационных опций для engine. Это относительно хорошая идея, так что, если хотите предложить конфигурационные опции, файл, в котором определен <code>module</code> вашего engine, подходит для этого. Поместите методы в модуль и можно продолжать.</p></div><p><code>lib/blorgh/engine.rb</code> это основной класс для engine:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
    <span class="n">isolate_namespace</span> <span class="no">Blorgh</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Унаследованный от класса <code>Rails::Engine</code>, этот гем информирует Rails, что по определенному пути есть engine, и должным образом монтирует engine в приложение, выполняя задачи, такие как добавление директории <code>app</code> из engine к путям загрузки для моделей, рассыльщиков, контроллеров и вью.</p><p>Метод <code>isolate_namespace</code> заслуживает особого внимания. Этот вызов ответственен за изолирование контроллеров, моделей, маршрутов и прочего в их собственное пространство имен, подальше от подобных компонентов приложения. Без этого есть вероятность, что компоненты engine могут &quot;просочиться&quot; в приложение, вызвав нежелательные разрушения, или что важные компоненты engine могут быть переопределены таким же образом названными вещами в приложении. Один из примеров таких конфликтов - хелперы. Без вызова <code>isolate_namespace</code>, хелперы engine будут включены в контроллеры приложения.</p><div class="note"><p><strong>Настойчиво</strong> рекомендуется оставить строчку <code>isolate_namespace</code> в определении класса <code>Engine</code>. Без этого созданные в engine классы <strong>могут</strong> конфликтовать с приложением.</p></div><p>Эта изоляция в пространство имен означает, что модель, созданная с помощью <code>bin/rails g model</code>, например <code>bin/rails g model article</code>, не будет называться <code>Article</code>, а будет помещена в пространство имен и названа <code>Blorgh::Article</code>. Кроме того, таблица для модели будет помещена в пространство имен, и станет <code>blorgh_articles</code>, а не просто <code>articles</code>. Подобно пространству имен моделей, контроллер с именем <code>ArticlesController</code> будет <code>Blorgh::ArticlesController</code>, и вью для этого контроллера будут не в <code>app/views/articles</code>, а в <code>app/views/blorgh/articles</code>. Рассыльщики, задания и хелперы также помещены в пространство имен.</p><p>Наконец, маршруты также будут изолированы в engine. Это одна из наиболее важных частей относительно пространства имен, и будет обсуждена позже в разделе <a href="#routes">Маршруты</a> этого руководства.</p><h5 id='direktoriya-app' class='inside_page_header'><a href="#direktoriya-app">2.1.2.</a> Директория <code>app</code></h5><p>В директории <code>app</code> имеются стандартные директории <code>assets</code>, <code>controllers</code>, <code>helpers</code>, <code>jobs</code>, <code>mailers</code>, <code>models</code> и <code>views</code>, с которыми вы уже знакомы по приложению. Мы рассмотрим модели в следующем разделе, когда будем писать engine.</p><p>В директории <code>app/assets</code> имеются директории <code>images</code> и <code>stylesheets</code>, которые, опять же, должны быть знакомы по приложению. Имеется одно отличие - каждая директория содержит поддиректорию с именем engine. Поскольку этот engine будет помещен в пространство имен, его ресурсы также будут помещены.</p><p>В директории <code>app/controllers</code> имеется директория <code>blorgh</code>, содержащая файл с именем <code>application_controller.rb</code>. Этот файл предоставит любую общую функциональность для контроллеров engine. Директория <code>blorgh</code> - то место, в котором будут другие контроллеры engine. Помещая их в этой директории, вы предотвращаете их от возможного конфликта с идентично названными контроллерами других engine или даже приложения.</p><div class="note"><p>Класс <code>ApplicationController</code> в engine называется так же, как и в приложении Rails, чтобы было проще преобразовать ваше приложение в engine.</p></div><div class="note"><p>Если родительское приложение запускается в режиме <code>classic</code>, можно попасть в ситуацию, в которой контроллер вашего engine наследуется от контроллера основного приложения, а не от контроллера приложения engine. Лучшим способом предотвращения этого является переключение на режим <code>zeitwerk</code> в родительском приложении. В противном случае, используйте <code>require_dependency</code>, чтобы убедиться, что контроллер engine загружен. Например:</p></div><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># НУЖНО ТОЛЬКО В РЕЖИМЕ `classic`.</span>
<span class="n">require_dependency</span> <span class="s2">"blorgh/application_controller"</span>

<span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">ArticlesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="warning"><p>Не используйте <code>require</code>, так как он сломает автоматическую перезагрузку классов в среде development - использование <code>require_dependency</code> гарантирует, что классы загружаются и выгружаются правильным способом.</p></div><p>Так же, как и для <code>app/controllers</code>, вы обнаружите поддиректорию <code>blorgh</code> в директориях <code>app/helpers</code>, <code>app/jobs</code>, <code>app/mailers</code> и <code>app/models</code>, содержащую связанный файл <code>application_*.rb</code> для размещения общего функционала. Помещая свои файлы в эту директорию и пространство имен, вы предотвращаете их от возможного пересечения с идентично названными элементами других engine или даже приложения.</p><p>Наконец, директория <code>app/views</code> содержит папку <code>layouts</code>, содержащую файл <code>blorgh/application.html.erb</code>. Этот файл позволяет определить макет для engine. Если этот engine будет использоваться как автономный, следует поместить любые настройки макета в этот файл, а не в файл <code>app/views/layouts/application.html.erb</code> приложения.</p><p>Если не хотите навязывать макет пользователям engine, удалите этот файл и ссылайтесь на другой макет в контроллерах вашего engine.</p><h5 id='direktoriya-bin' class='inside_page_header'><a href="#direktoriya-bin">2.1.3.</a> Директория <code>bin</code></h5><p>Эта директория содержит один файл, <code>bin/rails</code>, позволяющий использовать подкоманды и генераторы <code>rails</code>, как вы это делаете для приложения. Это означает, что можно создать новые контроллеры и модели для этого engine, просто запуская подобные команды:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate model
</code></pre>
</div>
<p>Помните, что все созданное с помощью этих команд в engine, имеющим <code>isolate_namespace</code> в классе <code>Engine</code>, будет помещено в пространство имен.</p><h5 id='test-directory' class='inside_page_header'><a href="#test-directory">2.1.4.</a>  Директория <code>test</code></h5><p>В директории <code>test</code> будут тесты для engine. Для тестирования engine, там будет урезанная версия приложения Rails, вложенная в <code>test/dummy</code>. Это приложение смонтирует в файле <code>test/dummy/config/routes.rb</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="n">mount</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span> <span class="o">=&gt;</span> <span class="s2">"/blorgh"</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Эта строчка монтирует engine по пути <code>/blorgh</code>, что делает его доступным в приложении только по этому пути.</p><p>В директории test имеется директория <code>test/integration</code>, в которой должны быть расположены интеграционные тесты для engine. Также могут быть созданы иные директории в <code>test</code>. Для примера, можно создать директорию <code>test/models</code> для тестов ваших моделей.</p><h3 id='predostavlyaem-funktsionalnost-engine' class='inside_page_header'><a href="#predostavlyaem-funktsionalnost-engine">3.</a> Предоставляем функциональность engine</h3><p>Engine, раскрываемый в этом руководстве, предоставляет функциональность отправки статей и комментирования, и излагается подобно в руководстве <a href="/getting-started">Rails для начинающих</a>, с некоторыми новыми особенностями.</p><div class="note"><p>Для этого раздела убедитесь, что запускаете команды в корне директории engine <code>blorgh</code>.</p></div><h4 id='sozdaem-resurs-article' class='inside_page_header'><a href="#sozdaem-resurs-article">3.1.</a> Создаем ресурс Article</h4><p>Первыми вещами для создания блога являются модель <code>Article</code> и соответствующий контроллер. Чтобы их создать быстро, воспользуемся генератором скаффолдов Rails.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate scaffold article title:string text:text
</code></pre>
</div>
<p>Эта команда выведет такую информацию:</p><div class="code_container">
  <pre><code class="highlight plaintext">invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_articles.rb
create    app/models/blorgh/article.rb
invoke    test_unit
create      test/models/blorgh/article_test.rb
create      test/fixtures/blorgh/articles.yml
invoke  resource_route
 route    resources :articles
invoke  scaffold_controller
create    app/controllers/blorgh/articles_controller.rb
invoke    erb
create      app/views/blorgh/articles
create      app/views/blorgh/articles/index.html.erb
create      app/views/blorgh/articles/edit.html.erb
create      app/views/blorgh/articles/show.html.erb
create      app/views/blorgh/articles/new.html.erb
create      app/views/blorgh/articles/_form.html.erb
invoke    test_unit
create      test/controllers/blorgh/articles_controller_test.rb
create      test/system/blorgh/articles_test.rb
invoke    helper
create      app/helpers/blorgh/articles_helper.rb
invoke      test_unit
</code></pre>
</div>
<p>Первое, что сделает генератор скаффолда, - это вызовет генератор <code>active_record</code>, который создаст миграцию и модель для ресурса. Отметьте, однако, что миграция называется <code>create_blorgh_articles</code> вместо обычной <code>create_articles</code>. Это происходит благодаря методу <code>isolate_namespace</code>, вызванному в определении класса <code>Blorgh::Engine</code>. Модель также помещена в пространство имен, размещена в <code>app/models/blorgh/article.rb</code>, а не в <code>app/models/article.rb</code>, благодаря вызову <code>isolate_namespace</code> в классе <code>Engine</code>.</p><p>Далее для этой модели вызывается генератор <code>test_unit</code>, создающий тест модели в <code>test/models/blorgh/article_test.rb</code> (а не в <code>test/models/article_test.rb</code>) и фикстуру в <code>test/fixtures/blorgh/articles.yml</code> (а не в <code>test/fixtures/articles.yml</code>).</p><p>После этого для ресурса вставляется строчка в файл <code>config/routes.rb</code> engine. Эта строчка - просто <code>resources :articles</code>, файл <code>config/routes.rb</code> engine стал таким:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="n">resources</span> <span class="ss">:articles</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Отметьте, что маршруты отрисовываются в объекте <code>Blorgh::Engine</code>, а не в классе <code>YourApp::Application</code>. Это так, поскольку маршруты engine ограничены самим engine и могут быть смонтированы в определенной точке, как показано в разделе <a href="#test-directory">Директория <code>test</code></a>. Также по этой причине маршруты engine изолированы от маршрутов приложения. Раздел <a href="#routes">Маршруты</a> руководства описывает это подробнее.</p><p>Затем вызывается генератор <code>scaffold_controller</code>, создавая контроллер с именем <code>Blorgh::ArticlesController</code> (в <code>app/controllers/blorgh/articles_controller.rb</code>) и соответствующие вью в <code>app/views/blorgh/articles</code>. Этот генератор также создает тесты для контроллера (<code>test/controllers/blorgh/articles_controller_test.rb</code> и <code>test/system/blorgh/articles_test.rb</code>) и хелпер (<code>app/helpers/blorgh/articles_helper.rb</code>).</p><p>Все, что этот генератор создает, аккуратно помещается в пространство имен. Класс контроллера определяется в модуле <code>Blorgh</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">ArticlesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="note"><p>Класс <code>ArticlesController</code> наследуется от <code>Blorgh::ApplicationController</code>, а не от <code>ApplicationController</code> приложения.</p></div><p>Хелпер в <code>app/helpers/blorgh/articles_helper.rb</code> также имеет пространство имен:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">module</span> <span class="nn">ArticlesHelper</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Это помогает предотвратить конфликты с любым другим engine или приложением, которые также могут иметь ресурс article.</p><p>Можно понаблюдать, что имеет engine на текущий момент, запустив <code>bin/rails db:migrate</code> в корне нашего engine, чтобы запустить миграцию, созданную генератором скаффолда, а затем запустив <code>bin/rails server</code> в <code>test/dummy</code>. Если открыть <code>http://localhost:3000/blorgh/articles</code>, можно увидеть созданный скаффолд по умолчанию. Проверьте! Вы только что создали первые функции вашего первого engine.</p><p>Также можно поиграть с консолью, <code>bin/rails console</code> будет работать так же, как и для приложения Rails. Помните: модель <code>Article</code> лежит в пространстве имен, поэтому, чтобы к ней обратиться, следует вызвать ее как <code>Blorgh::Article</code>.</p><div class="code_container">
  <pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Blorgh</span><span class="o">::</span><span class="no">Article</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Blorgh</span><span class="o">::</span><span class="no">Article</span> <span class="ss">id: </span><span class="mi">1</span> <span class="o">...</span><span class="kt">&gt;</span>
</code></pre>
</div>
<p>Наконец нужно сделать так, чтобы ресурс <code>articles</code> этого engine был в корне engine. Когда кто-либо перейдет в корень пути, в котором смонтирован engine, ему должен быть показан перечень статей. Чтобы это произошло, следующая строчка должна быть вставлена в файл <code>config/routes.rb</code> в engine:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">root</span> <span class="ss">to: </span><span class="s2">"articles#index"</span>
</code></pre>
</div>
<p>Теперь пользователям нужно всего лишь перейти в корень engine, чтобы увидеть все статьи, без посещения <code>/articles</code>. Это означает, что вместо <code>http://localhost:3000/blorgh/articles</code>, теперь можно перейти на <code>http://localhost:3000/blorgh</code>.</p><h4 id='sozdanie-resursa-kommentariev' class='inside_page_header'><a href="#sozdanie-resursa-kommentariev">3.2.</a> Создание ресурса комментариев</h4><p>Теперь, когда engine может создавать новые статьи, необходимо добавить функциональность комментирования. Для этого необходимо создать модель комментария, контроллер комментария и модифицировать скаффолд статей для отображения комментариев и позволения пользователям создавать новые.</p><p>Из корня engine запустите генератор моделей. Скажите ему создать модель <code>Comment</code> с соответствующей таблицей, имеющей два столбца: числовой <code>article_id</code> и текстовый <code>text</code>.</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate model Comment article_id:integer text:text
</code></pre>
</div>
<p>Это выдаст следующее:</p><div class="code_container">
  <pre><code class="highlight plaintext">invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_comments.rb
create    app/models/blorgh/comment.rb
invoke    test_unit
create      test/models/blorgh/comment_test.rb
create      test/fixtures/blorgh/comments.yml
</code></pre>
</div>
<p>Вызов этого генератора создаст только необходимые для модели файлы, поместит их в пространство имен в директории <code>blorgh</code> и создаст класс модели по имени <code>Blorgh::Comment</code>. Теперь запустите миграцию, чтобы создать таблицу blorgh_comments:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>db:migrate
</code></pre>
</div>
<p>Чтобы отображать комментарии на статью, отредактируйте <code>app/views/blorgh/articles/show.html.erb</code> и добавьте эту строчку до ссылки &quot;Edit&quot;:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="nt">&lt;h3&gt;</span>Comments<span class="nt">&lt;/h3&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">render</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">comments</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<p>Эта строчка требует, чтобы была связь <code>has_many</code> для комментариев, определенная в модели <code>Blorgh::Article</code>, которой сейчас нет. Чтобы ее определить, откройте <code>app/models/blorgh/article.rb</code> и добавьте эту строчку в модель:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">has_many</span> <span class="ss">:comments</span>
</code></pre>
</div>
<p>Превратив модель в следующее:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
    <span class="n">has_many</span> <span class="ss">:comments</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="note"><p>Поскольку <code>has_many</code> определена в классе внутри модуля <code>Blorgh</code>, Rails знает, что вы хотите использовать модель <code>Blorgh::Comment</code> для этих объектов, поэтому тут нет необходимости указывать это с использованием опции <code>:class_name</code>.</p></div><p>Затем необходима форма для создания комментариев к статье. Чтобы ее добавить, поместите эту строчку после вызова <code>render @article.comments</code> в <code>app/views/blorgh/articles/show.html.erb</code>:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">render</span> <span class="s2">"blorgh/comments/form"</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<p>Затем необходимо, чтобы существовал партиал, который рендерит эта строчка. Создайте новую директорию <code>app/views/blorgh/comments</code> и в ней новый файл по имени <code>_form.html.erb</code>, содержащий следующий код для создания необходимого партиала:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="nt">&lt;h3&gt;</span>New comment<span class="nt">&lt;/h3&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">form_with</span> <span class="ss">model: </span><span class="p">[</span><span class="vi">@article</span><span class="p">,</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">build</span><span class="p">]</span> <span class="k">do</span> <span class="o">|</span><span class="n">form</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;p&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">label</span> <span class="ss">:text</span> <span class="cp">%&gt;</span><span class="nt">&lt;br&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">text_area</span> <span class="ss">:text</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/p&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">submit</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<p>При подтверждении этой формы, она попытается выполнить запрос <code>POST</code> по маршруту <code>/articles/:article_id/comments</code> в engine. Сейчас этот маршрут не существует, но может быть создан с помощью изменения строчки <code>resources :articles</code> в <code>config/routes.rb</code> на эти строчки:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">resources</span> <span class="ss">:articles</span> <span class="k">do</span>
  <span class="n">resources</span> <span class="ss">:comments</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Это создаст вложенный маршрут для комментариев, что и требует форма.</p><p>Теперь маршрут существует, но контроллер, на который ведет маршрут, нет. Для его создания запустите команду из корня engine:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>g controller comments
</code></pre>
</div>
<p>Это создаст следующие вещи:</p><div class="code_container">
  <pre><code class="highlight plaintext">create  app/controllers/blorgh/comments_controller.rb
invoke  erb
 exist    app/views/blorgh/comments
invoke  test_unit
create    test/controllers/blorgh/comments_controller_test.rb
invoke  helper
create    app/helpers/blorgh/comments_helper.rb
invoke    test_unit
</code></pre>
</div>
<p>Форма сделает запрос <code>POST</code> к <code>/articles/:article_id/comments</code>, который связан с экшном <code>create</code> в <code>Blorgh::CommentsController</code>. Этот экшн нужно создать и поместить следующие строчки в определение класса в <code>app/controllers/blorgh/comments_controller.rb</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">def</span> <span class="nf">create</span>
  <span class="vi">@article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:article_id</span><span class="p">])</span>
  <span class="vi">@comment</span> <span class="o">=</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">comment_params</span><span class="p">)</span>
  <span class="n">flash</span><span class="p">[</span><span class="ss">:notice</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Comment has been created!"</span>
  <span class="n">redirect_to</span> <span class="n">articles_path</span>
<span class="k">end</span>

<span class="kp">private</span>

<span class="k">def</span> <span class="nf">comment_params</span>
  <span class="n">params</span><span class="p">.</span><span class="nf">require</span><span class="p">(</span><span class="ss">:comment</span><span class="p">).</span><span class="nf">permit</span><span class="p">(</span><span class="ss">:text</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Это последняя часть, требуемая для работы формы нового комментария. Однако, отображение комментариев еще не закончено. Если создадите новый комментарий сейчас, то увидите эту ошибку:</p><div class="code_container">
  <pre><code class="highlight plaintext">Missing partial blorgh/comments/_comment with {:handlers=&gt;[:erb, :builder], :formats=&gt;[:html], :locale=&gt;[:en, :en]}. Searched in:
  * "/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views"
  * "/Users/ryan/Sites/side_projects/blorgh/app/views"
</code></pre>
</div>
<p>Engine не может найти партиал, требуемый для рендеринга комментариев. Rails сперва ищет его в директории приложения (<code>test/dummy</code>) <code>app/views</code>, а затем в директории engine <code>app/views</code>. Когда он не нашел его, выдал эту ошибку. Engine знает, что нужно искать в <code>blorgh/comments/_comment</code>, поскольку объект модели, которую он получает, класса <code>Blorgh::Comment</code>.</p><p>Сейчас этот партиал будет ответственен за рендеринг только текста комментария. Создайте новый файл <code>app/views/blorgh/comments/_comment.html.erb</code> и поместите в него эту строчку:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">comment_counter</span> <span class="o">+</span> <span class="mi">1</span> <span class="cp">%&gt;</span>. <span class="cp">&lt;%=</span> <span class="n">comment</span><span class="p">.</span><span class="nf">text</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<p>Локальная переменная <code>comment_counter</code> дается нам вызовом <code>&lt;%= render @article.comments %&gt;</code>, она определяется автоматически, и счетчик увеличивается с итерацией для каждого комментария. Он используется в этом примере для отображения числа рядом с каждым созданным комментарием.</p><p>Мы завершили функцию комментирования engine блога. Теперь настало время использовать его в приложении.</p><h3 id='vnedrenie-v-prilozhenie' class='inside_page_header'><a href="#vnedrenie-v-prilozhenie">4.</a> Внедрение в приложение</h3><p>Использовать engine в приложении очень просто. Этот раздел раскрывает, как монтировать engine в приложение требуемые начальные настройки, а также как присоединить engine к классу <code>User</code>, представленному приложением, для обеспечения принадлежности статей и комментариев в engine.</p><h4 id='montirovanie-engine' class='inside_page_header'><a href="#montirovanie-engine">4.1.</a> Монтирование Engine</h4><p>Сначала необходимо определить engine в <code>Gemfile</code> приложения. Если у вас нет под рукой готового приложения для тестирования, создайте новое с использованием команды <code>rails new</code> вне директории engine:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">rails </span>new unicorn
</code></pre>
</div>
<p>Обычно определение engine в <code>Gemfile</code> выполняется как определение обычного повседневного гема.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">gem</span> <span class="s1">'devise'</span>
</code></pre>
</div>
<p>Однако, поскольку вы разрабатываете engine <code>blorgh</code> на своей локальной машине, необходимо указать опцию <code>:path</code> в <code>Gemfile</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">gem</span> <span class="s1">'blorgh'</span><span class="p">,</span> <span class="ss">path: </span><span class="s1">'engines/blorgh'</span>
</code></pre>
</div>
<p>Затем запустите <code>bundle</code> для установки гема.</p><p>Как было сказано ранее, при помещении гема в <code>Gemfile</code>, он будет загружен вместе с Rails, Он сначала затребует <code>lib/blorgh.rb</code> в engine, затем <code>lib/blorgh/engine.rb</code>, который является файлом, определяющим основную функциональность для engine.</p><p>Чтобы функциональность engine была доступна в приложении, необходимо его смонтировать в файле <code>config/routes.rb</code> приложения:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">mount</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span><span class="p">,</span> <span class="ss">at: </span><span class="s2">"/blog"</span>
</code></pre>
</div>
<p>Эта строчка смонтирует engine в <code>/blog</code> приложения. Сделав его доступным в <code>http://localhost:3000/blog</code>, когда приложение запущено с помощью <code>bin/rails server</code>.</p><div class="note"><p>Другие engine, такие как Devise, управляют этим немного по-другому, позволяя указывать в маршрутах свои хелперы (такие как <code>devise_for</code>). Эти хелперы делают примерно то же самое, монтируя части настраиваемой функциональности engine на предопределенные пути.</p></div><h4 id='nastroyka-engine' class='inside_page_header'><a href="#nastroyka-engine">4.2.</a> Настройка engine</h4><p>Engine содержит миграции для таблиц <code>blorgh_articles</code> и <code>blorgh_comments</code>, которые необходимо создать в базе данных приложения, чтобы модели engine могли делать правильные запросы к ним. Чтобы скопировать эти миграции в приложение, запустите следующую команду из корня приложения:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>blorgh:install:migrations
</code></pre>
</div>
<p>Если имеется несколько engine, из которых необходимо скопировать миграции, используйте <code>railties:install:migrations</code>:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>railties:install:migrations
</code></pre>
</div>
<p>Эта команда при первом запуске скопирует все миграции из engine. При следующем запуске она скопирует лишь те миграции, которые еще не были скопированы. Первый запуск этой команды выдаст что-то подобное:</p><div class="code_container">
  <pre><code class="highlight plaintext">Copied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorgh
Copied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh
</code></pre>
</div>
<p>Первая временная метка (<code>[timestamp_1]</code>) будет текущим временем, а вторая временная метка (<code>[timestamp_2]</code>) будет текущим временем плюс секунда. Причиной для этого является то, что миграции для engine выполняются после всех существующих миграций приложения.</p><p>Для запуска этих миграций в контексте приложения просто выполните <code>bin/rails db:migrate</code>. При входе в engine по адресу <code>http://localhost:3000/blog</code>, статей не будет, поскольку таблица, созданная в приложении, отличается от той, что была создана в engine. Сходите, поиграйте с только что смонтированным engine. Он точно такой же, как когда он был только engine.</p><p>Если хотите выполнить миграции только от одного engine, можно определить <code>SCOPE</code>:</p><div class="code_container">
  <pre><code class="highlight console"><span class="go">bin/rails db:migrate SCOPE=blorgh
</span></code></pre>
</div>
<p>Это полезно, если хотите откатить миграции перед их удалением. Чтобы откатить все миграции от engine blorgh, следует запустить такой код:</p><div class="code_container">
  <pre><code class="highlight console"><span class="go">bin/rails db:migrate SCOPE=blorgh VERSION=0
</span></code></pre>
</div>
<h4 id='ispolzovanie-klassa-predostavlennogo-prilozheniem' class='inside_page_header'><a href="#ispolzovanie-klassa-predostavlennogo-prilozheniem">4.3.</a> Использование класса, предоставленного приложением</h4><h5 id='ispolzovanie-modeli-predostavlennoy-prilozheniem' class='inside_page_header'><a href="#ispolzovanie-modeli-predostavlennoy-prilozheniem">4.3.1.</a> Использование модели, предоставленной приложением</h5><p>При создании engine, может возникнуть желание использовать определенные классы приложения для обеспечения связей между частями engine и частями приложения. В случае engine <code>blorgh</code> есть смысл в том, чтобы статьи и комментарии имели авторов.</p><p>Типичное приложении имеет класс <code>User</code>, предоставляющий авторов статей и комментариев. Но возможен случай, когда приложение называет этот класс по-другому, скажем <code>Person</code>. По этой причине engine не должен быть жестко связанным с классом <code>User</code>.</p><p>В нашем случае, для упрощения, в приложении будет класс с именем <code>User</code>, представляющий пользователей приложения (мы сделаем его настраиваемым в дальнейшем). Он может быть создан с помощью этой команды в приложении:</p><div class="code_container">
  <pre><code class="highlight console"><span class="go">bin/rails generate model user name:string
</span></code></pre>
</div>
<p>Далее должна быть запущена команда <code>bin/rails db:migrate</code>, чтобы для дальнейшего использовании в приложении создалась таблица <code>users</code>.</p><p>Также для упрощения, в форме статьи будет новое текстовое поле с именем <code>author_name</code>, в которое пользователи смогут вписать свое имя. Затем engine примет это имя и либо создаст новый объект <code>User</code> для него, либо найдет того, кто уже имеет такое имя. Engine затем свяжет статью с найденным или созданным объектом <code>User</code>.</p><p>Сначала нужно добавить текстовое поле <code>author_name</code> в партиал <code>app/views/blorgh/articles/_form.html.erb</code> внутри engine. Добавьте этот код перед полем <code>title</code>:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"field"</span><span class="nt">&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">label</span> <span class="ss">:author_name</span> <span class="cp">%&gt;</span><span class="nt">&lt;br&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">form</span><span class="p">.</span><span class="nf">text_field</span> <span class="ss">:author_name</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre>
</div>
<p>Затем необходимо обновить метод <code>Blorgh::ArticlesController#article_params</code> для разрешения параметров новой формы:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">def</span> <span class="nf">article_params</span>
  <span class="n">params</span><span class="p">.</span><span class="nf">require</span><span class="p">(</span><span class="ss">:article</span><span class="p">).</span><span class="nf">permit</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:text</span><span class="p">,</span> <span class="ss">:author_name</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>
<p>В модели <code>Blorgh::Article</code> должен быть некоторый код, преобразующий поле <code>author_name</code> в фактический объект <code>User</code> и привязывающий его как <code>author</code> статьи до того, как статья будет сохранена. Это потребует настройки <code>attr_accessor</code> для этого поля, таким образом, для него будут определены методы сеттера и геттера.</p><p>Для этого необходимо добавить <code>attr_accessor</code> для <code>author_name</code>, связь для author и вызов <code>before_validation</code> в <code>app/models/blorgh/article.rb</code>. Связь <code>author</code> будет пока что жестко завязана на класс <code>User</code>.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">attr_accessor</span> <span class="ss">:author_name</span>
<span class="n">belongs_to</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>

<span class="n">before_validation</span> <span class="ss">:set_author</span>

<span class="kp">private</span>
  <span class="k">def</span> <span class="nf">set_author</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">author</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">name: </span><span class="n">author_name</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre>
</div>
<p>Представив объект связи <code>author</code> классом <code>User</code>, установлена связь между engine и приложением. Должен быть способ связывания записей в таблице <code>blorgh_articles</code> с записями в таблице <code>users</code>. Поскольку связь называется <code>author</code>, столбец <code>author_id</code> должен быть добавлен в таблицу <code>blorgh_articles</code>.</p><p>Для создания этого нового столбца запустите команду внутри engine:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>generate migration add_author_id_to_blorgh_articles author_id:integer
</code></pre>
</div>
<div class="note"><p>Благодаря имени миграции и определению столбца после него, Rails автоматически узнает, что вы хотите добавить столбец в определенную таблицу и запишет это в миграцию. Вам не нужно больше ничего делать.</p></div><p>Нужно запустить эту миграцию в приложении. Для этого, сперва ее нужно скопировать с помощью команды:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>blorgh:install:migrations
</code></pre>
</div>
<p>Отметьте, что сейчас будет скопирована только <em>одна</em> миграция. Это так, потому что первые две миграции уже были скопированы при первом вызове этой команды.</p><div class="code_container">
  <pre><code class="highlight plaintext">NOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
NOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
Copied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh
</code></pre>
</div>
<p>Запустите эту миграцию с помощью:</p><div class="code_container">
  <pre><code class="highlight console"><span class="gp">$</span><span class="w"> </span><span class="nb">bin/rails </span>db:migrate
</code></pre>
</div>
<p>Теперь, когда все на месте, в дальнейшем будет происходить связывание автора - представленного записью в таблице <code>users</code> - со статьей, представленной таблицей <code>blorgh_articles</code> из engine.</p><p>Наконец, на странице статьи должно отображаться имя автора. Добавьте нижеследующий код над выводом &quot;Title&quot; в <code>app/views/blorgh/articles/show.html.erb</code>:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="nt">&lt;p&gt;</span>
  <span class="nt">&lt;b&gt;</span>Author:<span class="nt">&lt;/b&gt;</span>
  <span class="cp">&lt;%=</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;/p&gt;</span>
</code></pre>
</div>
<h5 id='ispolzovanie-kontrollera-predostavlennogo-prilozheniem' class='inside_page_header'><a href="#ispolzovanie-kontrollera-predostavlennogo-prilozheniem">4.3.2.</a> Использование контроллера, предоставленного приложением</h5><p>Поскольку обычно контроллеры Rails имеют общий код для таких вещей, как переменные сессии для аутентификации и доступа, по умолчанию они наследуются от <code>ApplicationController</code>. Однако engine Rails помещен в пространство имен для запуска, независимого от основного приложения, поэтому каждый engine получает <code>ApplicationController</code> в своем пространстве имен. Это пространство имен предотвращает коллизии кода, но часто контроллерам engine необходимо получить доступ к методам <code>ApplicationController</code> основного приложения. Легче всего получить этот доступ, изменив <code>ApplicationController</code> в пространстве имен engine, унаследовав его от <code>ApplicationController</code> основного приложения. Для нашего Blorgh engine это может быть выполнено, изменив <code>app/controllers/blorgh/application_controller.rb</code> подобным образом:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">ApplicationController</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>По умолчанию контроллеры engine наследуются от <code>Blorgh::ApplicationController</code>. Поэтому после такого изменения они получат доступ к <code>ApplicationController</code> основного приложения, как будто они являются частью основного приложения.</p><p>Это изменение требует, чтобы engine запускался из приложения Rails, в котором имеется <code>ApplicationController</code>.</p><h4 id='konfigurirovanie-engine' class='inside_page_header'><a href="#konfigurirovanie-engine">4.4.</a> Конфигурирование Engine</h4><p>Этот раздел раскрывает как сделать класс <code>User</code> конфигурируемым, а затем даны общие советы по конфигурированию engine.</p><h5 id='ustanovka-konfiguratsionnyh-nastroek-v-prilozhenii' class='inside_page_header'><a href="#ustanovka-konfiguratsionnyh-nastroek-v-prilozhenii">4.4.1.</a> Установка конфигурационных настроек в приложении</h5><p>Следующим шагом нужно сделать настраиваемым для engine класс, представленный как <code>User</code> в приложении. Это потому, как объяснялось ранее, что этот класс не всегда будет <code>User</code>. Для этого у engine будет конфигурационная настройка по имени <code>author_class</code>, используемая для определения, какой класс представляет пользователей в приложении.</p><p>Для определения этой конфигурационной настройки следует использовать <code>mattr_accessor</code> в модуле <code>Blorgh</code>. Добавьте эту строчку в <code>lib/blorgh.rb</code> внутри engine:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">mattr_accessor</span> <span class="ss">:author_class</span>
</code></pre>
</div>
<p>Этот метод работает подобно его братьям <code>attr_accessor</code> и <code>cattr_accessor</code>, но предоставляет методы сеттера и геттера для модуля с определенным именем. Для его использования к нему следует обратиться с использованием <code>Blorgh.author_class</code>.</p><p>Следующим шагом является переключение модели <code>Blorgh::Article</code> на эту новую настройку. Измените <code>belongs_to</code> в этой модели (<code>app/models/blorgh/article.rb</code>), на это:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">belongs_to</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">class_name: </span><span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span>
</code></pre>
</div>
<p>Метод <code>set_author</code> в модели <code>Blorgh::Article</code> должен тоже использовать тот класс:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">self</span><span class="p">.</span><span class="nf">author</span> <span class="o">=</span> <span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span><span class="p">.</span><span class="nf">constantize</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">name: </span><span class="n">author_name</span><span class="p">)</span>
</code></pre>
</div>
<p>Для предотвращения вызова <code>constantize</code> на <code>author_class</code> каждый раз, можно вместо этого переопределить метод геттера <code>author_class</code> внутри модуля <code>Blorgh</code> в файле <code>lib/blorgh.rb</code>, чтобы он всегда вызывал <code>constantize</code> на сохраненном значении до возврата значения:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">author_class</span>
  <span class="vc">@@author_class</span><span class="p">.</span><span class="nf">constantize</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Это позволит изменить написанный выше код для <code>set_author</code> так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">self</span><span class="p">.</span><span class="nf">author</span> <span class="o">=</span> <span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">name: </span><span class="n">author_name</span><span class="p">)</span>
</code></pre>
</div>
<p>Результат стал более коротким и более очевидным в своем поведении. Метод <code>author_class</code> должен всегда возвращать объект <code>Class</code>.</p><p>Поскольку мы изменили метод <code>author_class</code>, чтобы он возвращал <code>Class</code> вместо <code>String</code>, мы также должны модифицировать определение <code>belongs_to</code> в модели <code>Blorgh::Article</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">belongs_to</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">class_name: </span><span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span><span class="p">.</span><span class="nf">to_s</span>
</code></pre>
</div>
<p>Чтобы установить эту конфигурационную настройку в приложении, следует использовать инициализатор. При использовании инициализатора, конфигурация установится до того, как запустится приложение и вызовутся модели engine, которые могут зависеть от существования этих конфигурационных настроек.</p><p>Создайте инициализатор <code>config/initializers/blorgh.rb</code> в приложении, в котором установлен engine <code>blorgh</code>, и поместите в него такое содержимое:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Blorgh</span><span class="p">.</span><span class="nf">author_class</span> <span class="o">=</span> <span class="s2">"User"</span>
</code></pre>
</div>
<div class="warning"><p>Тут важно использовать строковую версию класса, а не сам класс. Если использовать класс, Rails попытается загрузить этот класс и затем обратиться к соответствующей таблице, что приведет к проблемам, если таблица еще не существует. Следовательно, должна быть использована строка, а затем преобразована в класс с помощью <code>constantize</code> позже в engine.</p></div><p>Попытайтесь создать новую статью. Вы увидите, что все работает так же, как и прежде, за исключением того, что engine использует конфигурационную настройку в <code>config/initializers/blorgh.rb</code>, чтобы узнать, какой класс использовать.</p><p>Нет каких-либо строгих ограничений, каким должен быть класс, есть только каким должно быть API для класса. Engine просто требует, чтобы этот класс определял метод <code>find_or_create_by</code>, возвращающий объект этого класса для связи со статьей при ее создании. Этот объект, разумеется, должен иметь некоторый идентификатор, по которому на него можно сослаться.</p><h5 id='konfiguratsiya-engine-obschego-haraktera' class='inside_page_header'><a href="#konfiguratsiya-engine-obschego-haraktera">4.4.2.</a> Конфигурация Engine общего характера</h5><p>Может случиться так, что вы захотите использовать для engine инициализаторы, интернационализацию или другие конфигурационные опции. Эти вещи вполне возможны, поскольку Rails engine имеет почти такую же функциональность, как и приложение Rails. Фактически, функциональность приложения Rails - это супер надстройка над тем, что предоставляет engine!</p><p>Если хотите использовать инициализатор - код, который должен выполниться до загрузки engine - поместите его в папку <code>config/initializers</code>. функциональность этой директории объясняется в разделе <a href="/configuring#initializers">Инициализаторы</a> руководства по конфигурированию, и работает абсолютно так же, как и директория <code>config/initializers</code> в приложении. То же самое касается стандартных инициализаторов.</p><p>Что касается локалей, просто поместите файлы локалей в директории <code>config/locales</code>, так же, как это делается в приложении.</p><h3 id='testirovanie-engine' class='inside_page_header'><a href="#testirovanie-engine">5.</a> Тестирование engine</h3><p>В созданном engine есть небольшое пустое приложение в <code>test/dummy</code>. Это приложение используется как точка монтирования для engine, чтобы максимально упростить тестирование engine. Это приложение можно расширить, сгенерировав контроллеры, модели или вью из этой директории, и использовать их для тестирования своего engine.</p><p>Директорию <code>test</code> следует рассматривать как обычную среду тестирования Rails, допускающую юнит, функциональные и интеграционные тесты.</p><h4 id='funktsionalnye-testy' class='inside_page_header'><a href="#funktsionalnye-testy">5.1.</a> Функциональные тесты</h4><p>Следует принять во внимание при написании функциональных тестов, что тесты будут запущены для приложения - приложения <code>test/dummy</code> - а не для вашего engine. Это так благодаря настройке тестового окружения; engine нуждается в приложении, как хосту для тестирования его основной функциональности, особенно контроллеров. Это означает, что если сделать обычный <code>GET</code> к контроллеру в функциональном тесте для контроллера:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">FooControllerTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
    <span class="kp">include</span> <span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">url_helpers</span>

    <span class="k">def</span> <span class="nf">test_index</span>
      <span class="n">get</span> <span class="n">foos_url</span>
      <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Он не будет работать правильно. Это так, поскольку приложение не знает, как направить эти запросы в engine, пока вы явно не скажете <strong>как</strong>. Для этого необходимо установить значение переменной экземпляра <code>@routes</code> набором маршрутов engine в коде setup:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">FooControllerTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
    <span class="kp">include</span> <span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">url_helpers</span>

    <span class="n">setup</span> <span class="k">do</span>
      <span class="vi">@routes</span> <span class="o">=</span> <span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">test_index</span>
      <span class="n">get</span> <span class="n">foos_url</span>
      <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Это сообщит приложению, что вы все еще хотите выполнить запрос <code>GET</code> к экшну <code>index</code> этого контроллера, но вы хотите использовать тут маршрут engine, а не приложения.</p><p>Это также позволит убедиться в тестах, что хелперы URL engine работают так, как ожидается.</p><h3 id='uluchshenie-funktsionalnosti-engine' class='inside_page_header'><a href="#uluchshenie-funktsionalnosti-engine">6.</a> Улучшение функциональности engine</h3><p>Этот раздел объяснит, как добавить или переопределить MVC-функциональность engine из основного приложения Rails.</p><h4 id='pereopredelenie-modeley-i-kontrollerov' class='inside_page_header'><a href="#pereopredelenie-modeley-i-kontrollerov">6.1.</a> Переопределение моделей и контроллеров</h4><p>Модели и контроллеры engine могут быть переоткрыты в родительском приложении, чтобы их расширить или декорировать.</p><p>Переопределения могут быть организованы в выделенной директории <code>app/overrides</code>, игнорируемой автозагрузчиком, которая предварительно загружается в колбэке <code>to_prepare</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># config/application.rb</span>
<span class="k">module</span> <span class="nn">MyApp</span>
  <span class="k">class</span> <span class="nc">Application</span> <span class="o">&lt;</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Application</span>
    <span class="c1"># ...</span>

    <span class="n">overrides</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="si">}</span><span class="s2">/app/overrides"</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">autoloaders</span><span class="p">.</span><span class="nf">main</span><span class="p">.</span><span class="nf">ignore</span><span class="p">(</span><span class="n">overrides</span><span class="p">)</span>

    <span class="n">config</span><span class="p">.</span><span class="nf">to_prepare</span> <span class="k">do</span>
      <span class="no">Dir</span><span class="p">.</span><span class="nf">glob</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">overrides</span><span class="si">}</span><span class="s2">/**/*_override.rb"</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">override</span><span class="o">|</span>
        <span class="nb">load</span> <span class="n">override</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h5 id='pereotkrytie-suschestvuyuschih-klassov-s-ispolzovaniem-class_eval' class='inside_page_header'><a href="#pereotkrytie-suschestvuyuschih-klassov-s-ispolzovaniem-class_eval">6.1.1.</a> Переоткрытие существующих классов с использованием <code>class_eval</code></h5><p>Например, чтобы переопределить модель engine</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Blorgh/app/models/blorgh/article.rb</span>
<span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<p>нужно всего лишь создать файл, <em>переоткрывающий</em> этот класс:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># MyApp/app/overrides/models/blorgh/article_override.rb</span>
<span class="no">Blorgh</span><span class="o">::</span><span class="no">Article</span><span class="p">.</span><span class="nf">class_eval</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Очень важно, что переопределение переоткрывает этот класс или модуль. Использование ключевых слов <code>class</code> или <code>module</code> определили бы их, если они еще не существуют в памяти, что было бы неправильным, так как определение находится в engine. Использование <code>class_eval</code>, как показано выше, гарантирует, что вы переоткрываете.</p><h5 id='izmenenie-suschestvuyuschih-klassov-s-ispolzovaniem-activesupport-concern' class='inside_page_header'><a href="#izmenenie-suschestvuyuschih-klassov-s-ispolzovaniem-activesupport-concern">6.1.2.</a> Изменение существующих классов с использованием ActiveSupport::Concern</h5><p>Использование <code>Class#class_eval</code> хорошо подходит для простых корректировок, но для более сложных модификаций следует рассмотреть использование <a href="https://api.rubyonrails.org/classes/ActiveSupport/Concern.html"><code>ActiveSupport::Concern</code></a>. <code>ActiveSupport::Concern</code> управляет порядком загрузки взаимосвязанных зависимостей во время выполнения, что позволяет существенно модулировать ваш код.</p><p><strong>Добавление</strong> <code>Article#time_since_created</code> и <strong>Переопределение</strong> <code>Article#summary</code>:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># MyApp/app/models/blorgh/article.rb</span>

<span class="k">class</span> <span class="nc">Blorgh::Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="kp">include</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Concerns</span><span class="o">::</span><span class="no">Models</span><span class="o">::</span><span class="no">Article</span>

  <span class="k">def</span> <span class="nf">time_since_created</span>
    <span class="no">Time</span><span class="p">.</span><span class="nf">current</span> <span class="o">-</span> <span class="n">created_at</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">summary</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">title</span><span class="si">}</span><span class="s2"> - </span><span class="si">#{</span><span class="n">truncate</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Blorgh/app/models/blorgh/article.rb</span>
<span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
    <span class="kp">include</span> <span class="no">Blorgh</span><span class="o">::</span><span class="no">Concerns</span><span class="o">::</span><span class="no">Models</span><span class="o">::</span><span class="no">Article</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<div class="code_container">
  <pre><code class="highlight ruby"><span class="c1"># Blorgh/lib/concerns/models/article.rb</span>

<span class="k">module</span> <span class="nn">Blorgh::Concerns::Models::Article</span>
  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>

  <span class="c1"># 'included do' приводит к тому, что блок будет вычислен в контексте,</span>
  <span class="c1"># в котором модуль подключен (т.е. Blorgh::Article),</span>
  <span class="c1"># а не в самом модуле.</span>
  <span class="n">included</span> <span class="k">do</span>
    <span class="nb">attr_accessor</span> <span class="ss">:author_name</span>
    <span class="n">belongs_to</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>

    <span class="n">before_validation</span> <span class="ss">:set_author</span>

    <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">set_author</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">author</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">name: </span><span class="n">author_name</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">summary</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">title</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">module</span> <span class="nn">ClassMethods</span>
    <span class="k">def</span> <span class="nf">some_class_method</span>
      <span class="s1">'some class method string'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='avtozagruzka-i-engine' class='inside_page_header'><a href="#avtozagruzka-i-engine">6.2.</a> Автозагрузка и Engine</h4><p>Обратитесь к руководству <a href="/autoloading-and-reloading-constants#autoloading-and-engines">Автозагрузка и перезагрузка констант</a>
guide for more information about autoloading and engines.</p><h4 id='pereopredelenie-vyu' class='inside_page_header'><a href="#pereopredelenie-vyu">6.3.</a> Переопределение вью</h4><p>Когда Rails ищет вью для рендеринга, он сперва смотрит в директорию <code>app/views</code> приложения. Если он не может найти там вью, он проверит директории <code>app/views</code> всех engine, имеющих эту директорию.</p><p>Когда приложение хочет отрендерить вью для экшна <code>index</code> в <code>Blorgh::ArticlesController</code>, он сперва пытается найти путь <code>app/views/blorgh/articles/index.html.erb</code> внутри приложения. Если не сможет найти, то будет искать внутри engine.</p><p>Можно переопределить эту вью в приложении, просто создав файл <code>app/views/blorgh/articles/index.html.erb</code>. Можно полностью изменить то, что эта вью должна обычно выводить.</p><p>Попробуйте так сделать, создав новый файл <code>app/views/blorgh/articles/index.html.erb</code> и поместив в него:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="nt">&lt;h1&gt;</span>Articles<span class="nt">&lt;/h1&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"New Article"</span><span class="p">,</span> <span class="n">new_article_path</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%</span> <span class="vi">@articles</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">article</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;h2&gt;</span><span class="cp">&lt;%=</span> <span class="n">article</span><span class="p">.</span><span class="nf">title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;small&gt;</span>By <span class="cp">&lt;%=</span> <span class="n">article</span><span class="p">.</span><span class="nf">author</span> <span class="cp">%&gt;</span><span class="nt">&lt;/small&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">simple_format</span><span class="p">(</span><span class="n">article</span><span class="p">.</span><span class="nf">text</span><span class="p">)</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;hr&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<h4 id='routes' class='inside_page_header'><a href="#routes">6.4.</a>  Маршруты</h4><p>По умолчанию маршруты в engine изолированы от приложения. Это выполняется с помощью вызова <code>isolate_namespace</code> в классе <code>Engine</code>. По сути это означает, что приложение и его engine могут иметь одинаково названные маршруты, и не будет никакого конфликта.</p><p>Маршруты в engine отрисовываются в классе <code>Engine</code> в <code>config/routes.rb</code>, подобно:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">Blorgh</span><span class="o">::</span><span class="no">Engine</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="n">resources</span> <span class="ss">:articles</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Имея подобные изолированные маршруты, если захотите сослаться на часть engine из приложения, необходимо воспользоваться прокси методом маршрутов engine. Вызов обычных маршрутных методов, таких как <code>articles_path</code>, может привести в нежелательное место расположения, если и приложение, и engine определяют такой хелпер.</p><p>Ссылка в следующем примере приведет на <code>articles_path</code> приложения, если шаблон был отрендерен из приложения, или на <code>articles_path</code> engine, если был отрендерен в engine:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Blog articles"</span><span class="p">,</span> <span class="n">articles_path</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<p>Чтобы этот маршрут всегда использовал маршрутный метод хелпера <code>articles_path</code> engine, необходимо вызвать метод на маршрутном прокси методе, имеющем то же имя, что и engine.</p><div class="code_container">
  <pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Blog articles"</span><span class="p">,</span> <span class="n">blorgh</span><span class="p">.</span><span class="nf">articles_path</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<p>Можно обратиться к приложению из engine подобным образом, используя хелпер <code>main_app</code>:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Home"</span><span class="p">,</span> <span class="n">main_app</span><span class="p">.</span><span class="nf">root_path</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<p>Если это использовать в engine, он <strong>всегда</strong> будет вести на корень приложения. Если опустить вызов метода &quot;маршрутного прокси&quot; <code>main_app</code>, он потенциально может вести на корень engine или приложения, в зависимости от того, где был вызван.</p><p>Если шаблон, рендерящийся из engine, попытается использовать один из методов маршрутного хелпера приложения, это может привести к вызову неопределенного метода. Если вы с этим столкнулись, убедитесь, что не пытаетесь вызвать из engine маршрутный метод приложения без префикса <code>main_app</code>.</p><h4 id='resursy-assets' class='inside_page_header'><a href="#resursy-assets">6.5.</a> Ресурсы (assets)</h4><p>Ресурсы в engine работают так же, как и в полноценном приложении. Поскольку класс engine наследуется от <code>Rails::Engine</code>, приложение будет знать, что следует искать ресурсы в директориях engine <code>app/assets</code> и <code>lib/assets</code>.</p><p>Подобно остальным компонентам engine, ресурсы также будут помещены в пространство имен. Это означает, что если имеется ресурс по имени <code>style.css</code>, он должен быть помещен в <code>app/assets/stylesheets/[engine name]/style.css</code>, а не в <code>app/assets/stylesheets/style.css</code>. Если этот ресурс не будет помещен в пространство имен, то есть вероятность, что в приложении есть идентично названный ресурс, в этом случае ресурс приложения будет иметь преимущество, а ресурс в engine будет проигнорирован.</p><p>Представим, что у вас есть ресурс <code>app/assets/stylesheets/blorgh/style.css</code>. Чтобы включить его в приложение, используйте <code>stylesheet_link_tag</code> и сошлитесь на ресурс так, как он находится в engine:</p><div class="code_container">
  <pre><code class="highlight erb"><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s2">"blorgh/style.css"</span> <span class="cp">%&gt;</span>
</code></pre>
</div>
<p>Также можно определить эти ресурсы как зависимости для других ресурсов, используя выражения Asset Pipeline в обрабатываемых файлах:</p><div class="code_container">
  <pre><code class="highlight css"><span class="c">/*
 *= require blorgh/style
 */</span>
</code></pre>
</div>
<div class="info"><p>Помните, что для использования языков, таких как Sass или CoffeeScript, следует подключить соответствующую библиотеку в <code>.gemspec</code> вашего engine.</p></div><h4 id='otdelnye-resursy-i-prekompilyatsiya' class='inside_page_header'><a href="#otdelnye-resursy-i-prekompilyatsiya">6.6.</a> Отдельные ресурсы и прекомпиляция</h4><p>Бывают ситуации, когда ресурсы engine не требуются приложению. Например, скажем, вы создали административную функциональность, существующую только для engine. В этом случае приложению не нужно требовать <code>admin.css</code> или <code>admin.js</code>. Только административному макету гема необходимы эти ресурсы. Нет смысла, чтобы приложение включало <code>&quot;blorg/admin.css&quot;</code> в свои таблицы стилей. В такой ситуации следует явно определить эти ресурсы для прекомпиляции.
Это сообщит Sprockets добавить ресурсы engine при вызове <code>bin/rails assets:precompile</code>.</p><p>Ресурсы для прекомпиляции можно определить в <code>engine.rb</code></p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">initializer</span> <span class="s2">"blorgh.assets.precompile"</span> <span class="k">do</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span>
  <span class="n">app</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">assets</span><span class="p">.</span><span class="nf">precompile</span> <span class="o">+=</span> <span class="sx">%w( admin.js admin.css )</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Более подробно читайте в руководстве <a href="/asset-pipeline">Asset Pipeline</a>.</p><h4 id='zavisimosti-ot-drugih-gemov' class='inside_page_header'><a href="#zavisimosti-ot-drugih-gemov">6.7.</a> Зависимости от других гемов</h4><p>Зависимости от гемов в engine должны быть определены в файле <code>.gemspec</code> в корне engine. Причиной для этого является то, что engine может быть установлен как гем. Если определить зависимости в <code>Gemfile</code>, они могут быть не распознаны при традиционной установке гема, и быть не установленными, вызвав неработоспособность engine.</p><p>Для определения зависимости, которая должна быть установлена вместе с engine во время традиционного <code>gem install</code>, определите ее в блоке <code>Gem::Specification</code> в файле <code>.gemspec</code> в engine:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">s</span><span class="p">.</span><span class="nf">add_dependency</span> <span class="s2">"moo"</span>
</code></pre>
</div>
<p>Для определения зависимости, которая должна быть установлена только при разработке приложения, определите это так:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="n">s</span><span class="p">.</span><span class="nf">add_development_dependency</span> <span class="s2">"moo"</span>
</code></pre>
</div>
<p>Оба типа зависимостей будут установлены при запуске <code>bundle install</code>  внутри приложения. Зависимости development для гема будут использованы только когда будут запущена разработка и тесты для engine.</p><p>Отметьте, что если вы захотите немедленно затребовать зависимости при затребовании engine, следует их затребовать до инициализации engine. Например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="nb">require</span> <span class="s2">"other_engine/engine"</span>
<span class="nb">require</span> <span class="s2">"yet_another_engine/engine"</span>

<span class="k">module</span> <span class="nn">MyEngine</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>
<h3 id='huki-zagruzki-i-konfiguratsii' class='inside_page_header'><a href="#huki-zagruzki-i-konfiguratsii">7.</a> Хуки загрузки и конфигурации</h3><p>При загрузке приложения часто может быть ссылка на код Rails. Rails отвечает за порядок загрузки этих фреймворков, поэтому когда вы загружаете фреймворки, такие как <code>ActiveRecord::Base</code>, преждевременно вы нарушаете неявный контракт, который ваше приложение имеет с Rails. Более того, загружая код, такой как <code>ActiveRecord::Base</code> при запуске вашего приложения, вы загружаете целые фреймворки, которые могут замедлять время запуска и могут привести к конфликтам с порядком загрузки и запуском вашего приложения.</p><p>Хуки загрузки и конфигурации - это API, который позволяет вам подключиться к этому процессу инициализации без нарушения контракта загрузки с помощью Rails. Это также позволит уменьшить снижение производительности запуска и избежать конфликтов.</p><h4 id='izbegayte-zagruzki-freymvorkov-rails' class='inside_page_header'><a href="#izbegayte-zagruzki-freymvorkov-rails">7.1.</a> Избегайте загрузки фреймворков Rails</h4><p>Поскольку Ruby является динамическим языком, некоторый код будет вызывать различные фреймворки Rails для загрузки. Возьмем этот фрагмент, например:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">include</span><span class="p">(</span><span class="no">MyActiveRecordHelper</span><span class="p">)</span>
</code></pre>
</div>
<p>Этот фрагмент означает, что когда этот файл загружен, он будет взаимодействовать с <code>ActiveRecord::Base</code>. Это взаимодействие заставляет Ruby искать определение этой константы и затребовать ее. Это приводит к загрузке всего фреймворка Active Record при запуске.</p><p><code>ActiveSupport.on_load</code> - это механизм, который может быть использован для того, чтобы отложить загрузку кода до тех пор, пока он действительно не понадобится. Вышеуказанный фрагмент можно изменить на:</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">ActiveSupport</span><span class="p">.</span><span class="nf">on_load</span><span class="p">(</span><span class="ss">:active_record</span><span class="p">)</span> <span class="k">do</span>
  <span class="kp">include</span> <span class="no">MyActiveRecordHelper</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Этот новый фрагмент будет включать <code>MyActiveRecordHelper</code>, только когда загружается <code>ActiveRecord::Base</code>.</p><h4 id='kogda-vyzyvayutsya-huki' class='inside_page_header'><a href="#kogda-vyzyvayutsya-huki">7.2.</a> Когда вызываются хуки</h4><p>В фреймворке Rails эти хуки вызываются, когда загружается конкретная библиотека. Например, когда загружается <code>ActionController::Base</code>, вызывается хук <code>:action_controller_base</code>. Это означает, что все вызовы <code>ActiveSupport.on_load</code> с помощью <code>:action_controller_base</code> хуков будут вызываться в контексте <code>ActionController::Base</code> (это значит, что <code>self</code> будет <code>ActionController::Base</code>).</p><h3 id='modifitsirovanie-koda-dlya-ispolzovaniya-hukov-zagruzki' class='inside_page_header'><a href="#modifitsirovanie-koda-dlya-ispolzovaniya-hukov-zagruzki">8.</a> Модифицирование кода для использования хуков загрузки</h3><p>Модифицирование кода, как правило, достаточно простое. Если есть строчка кода, которая ссылается на фреймворк Rails, такой как <code>ActiveRecord::Base</code>, можно обернуть этот код в хук загрузки.</p><p><strong>Изменение вызовов <code>include</code></strong></p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">include</span><span class="p">(</span><span class="no">MyActiveRecordHelper</span><span class="p">)</span>
</code></pre>
</div>
<p>станет</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">ActiveSupport</span><span class="p">.</span><span class="nf">on_load</span><span class="p">(</span><span class="ss">:active_record</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># self ссылается здесь на ActiveRecord::Base,</span>
  <span class="c1"># поэтому мы можем вызывать .include</span>
  <span class="kp">include</span> <span class="no">MyActiveRecordHelper</span>
<span class="k">end</span>
</code></pre>
</div>
<p><strong>Изменение вызовов <code>prepend</code></strong></p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">prepend</span><span class="p">(</span><span class="no">MyActionControllerHelper</span><span class="p">)</span>
</code></pre>
</div>
<p>станет</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">ActiveSupport</span><span class="p">.</span><span class="nf">on_load</span><span class="p">(</span><span class="ss">:action_controller_base</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># self ссылается здесь на ActionController::Base,</span>
  <span class="c1"># поэтому мы можем вызывать .prepend</span>
  <span class="n">prepend</span> <span class="no">MyActionControllerHelper</span>
<span class="k">end</span>
</code></pre>
</div>
<p><strong>Изменение вызовов методов класса</strong></p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">include_root_in_json</span> <span class="o">=</span> <span class="kp">true</span>
</code></pre>
</div>
<p>станет</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="no">ActiveSupport</span><span class="p">.</span><span class="nf">on_load</span><span class="p">(</span><span class="ss">:active_record</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># self ссылается здесь на ActiveRecord::Base</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">include_root_in_json</span> <span class="o">=</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre>
</div>
<h4 id='dostupnye-huki-zagruzki' class='inside_page_header'><a href="#dostupnye-huki-zagruzki">8.1.</a> Доступные хуки загрузки</h4><p>Это хуки загрузки, которые можно использовать в своем коде. Чтобы подключиться к процессу инициализации одного из следующих классов, используйте соответствующий ему доступный хук.</p><table class='table table-striped'><tr>
<th>Класс</th>
<th>Хук</th>
</tr>
<tr>
<td><code>ActionCable</code></td>
<td><code>action_cable</code></td>
</tr>
<tr>
<td><code>ActionCable::Channel::Base</code></td>
<td><code>action_cable_channel</code></td>
</tr>
<tr>
<td><code>ActionCable::Connection::Base</code></td>
<td><code>action_cable_connection</code></td>
</tr>
<tr>
<td><code>ActionCable::Connection::TestCase</code></td>
<td><code>action_cable_connection_test_case</code></td>
</tr>
<tr>
<td><code>ActionController::API</code></td>
<td><code>action_controller_api</code></td>
</tr>
<tr>
<td><code>ActionController::API</code></td>
<td><code>action_controller</code></td>
</tr>
<tr>
<td><code>ActionController::Base</code></td>
<td><code>action_controller_base</code></td>
</tr>
<tr>
<td><code>ActionController::Base</code></td>
<td><code>action_controller</code></td>
</tr>
<tr>
<td><code>ActionController::TestCase</code></td>
<td><code>action_controller_test_case</code></td>
</tr>
<tr>
<td><code>ActionDispatch::IntegrationTest</code></td>
<td><code>action_dispatch_integration_test</code></td>
</tr>
<tr>
<td><code>ActionDispatch::Response</code></td>
<td><code>action_dispatch_response</code></td>
</tr>
<tr>
<td><code>ActionDispatch::Request</code></td>
<td><code>action_dispatch_request</code></td>
</tr>
<tr>
<td><code>ActionDispatch::SystemTestCase</code></td>
<td><code>action_dispatch_system_test_case</code></td>
</tr>
<tr>
<td><code>ActionMailbox::Base</code></td>
<td><code>action_mailbox</code></td>
</tr>
<tr>
<td><code>ActionMailbox::InboundEmail</code></td>
<td><code>action_mailbox_inbound_email</code></td>
</tr>
<tr>
<td><code>ActionMailbox::Record</code></td>
<td><code>action_mailbox_record</code></td>
</tr>
<tr>
<td><code>ActionMailbox::TestCase</code></td>
<td><code>action_mailbox_test_case</code></td>
</tr>
<tr>
<td><code>ActionMailer::Base</code></td>
<td><code>action_mailer</code></td>
</tr>
<tr>
<td><code>ActionMailer::TestCase</code></td>
<td><code>action_mailer_test_case</code></td>
</tr>
<tr>
<td><code>ActionText::Content</code></td>
<td><code>action_text_content</code></td>
</tr>
<tr>
<td><code>ActionText::Record</code></td>
<td><code>action_text_record</code></td>
</tr>
<tr>
<td><code>ActionText::RichText</code></td>
<td><code>action_text_rich_text</code></td>
</tr>
<tr>
<td><code>ActionView::Base</code></td>
<td><code>action_view</code></td>
</tr>
<tr>
<td><code>ActionView::TestCase</code></td>
<td><code>action_view_test_case</code></td>
</tr>
<tr>
<td><code>ActiveJob::Base</code></td>
<td><code>active_job</code></td>
</tr>
<tr>
<td><code>ActiveJob::TestCase</code></td>
<td><code>active_job_test_case</code></td>
</tr>
<tr>
<td><code>ActiveRecord::Base</code></td>
<td><code>active_record</code></td>
</tr>
<tr>
<td><code>ActiveStorage::Attachment</code></td>
<td><code>active_storage_attachment</code></td>
</tr>
<tr>
<td><code>ActiveStorage::VariantRecord</code></td>
<td><code>active_storage_variant_record</code></td>
</tr>
<tr>
<td><code>ActiveStorage::Blob</code></td>
<td><code>active_storage_blob</code></td>
</tr>
<tr>
<td><code>ActiveStorage::Record</code></td>
<td><code>active_storage_record</code></td>
</tr>
<tr>
<td><code>ActiveSupport::TestCase</code></td>
<td><code>active_support_test_case</code></td>
</tr>
<tr>
<td><code>i18n</code></td>
<td><code>i18n</code></td>
</tr>
</table><h4 id='dostupnye-huki-nastroyki' class='inside_page_header'><a href="#dostupnye-huki-nastroyki">8.2.</a> Доступные хуки настройки</h4><p>Хуки настройки не подключаются к какому-либо конкретному фреймворку, вместо этого они запускаются в контексте всего приложения.</p><table class='table table-striped'><tr>
<th>Хук</th>
<th>Случаи применения</th>
</tr>
<tr>
<td><code>before_configuration</code></td>
<td>Первый настраиваемый блок для запуска. Вызывается до запуска любых инициализаторов.</td>
</tr>
<tr>
<td><code>before_initialize</code></td>
<td>Второй настраиваемый блок для запуска. Вызывается перед инициализацией фреймворков.</td>
</tr>
<tr>
<td><code>before_eager_load</code></td>
<td>Третий настраиваемый блок для запуска. Не запускается, если для <a href="/configuring#config-eager-load"><code>config.eager_load</code></a> установлено значение false.</td>
</tr>
<tr>
<td><code>after_initialize</code></td>
<td>Последний настраиваемый блок для запуска. Вызывается после инициализации фреймворков.</td>
</tr>
</table><p>Хуки настройки могут вызываться в классе Engine.</p><div class="code_container">
  <pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">Blorgh</span>
  <span class="k">class</span> <span class="nc">Engine</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">Engine</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">before_configuration</span> <span class="k">do</span>
      <span class="nb">puts</span> <span class="s1">'I am called before any initializers'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>


            <div class="banner">
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

   <!-- bottom rusrails -->
   <ins class="adsbygoogle"
        style="display:inline-block;width:580px;height:400px"
        data-ad-client="ca-pub-7764391801669990"
        data-ad-slot="7566253867"></ins>


<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            </div>
          </div>
        </div>
        <div class="row-fluid">
          <div class="span12" id="footer">
            <p>
              <a target="blank" href="https://github.com/rusrails/rusrails"><img src="/assets/github-7cc23602a5ac2465f14c19492358a5a67dc24636761cc723e4d621cea0c09225.png" /></a>
              <a target="blank" href="http://twitter.com/rusrails"><img src="/assets/twitter-50e0e767c8793dec313a7dc5cfbcfe2067e3e89ea6ec64784eb7c6640f578758.png" /></a>
            </p>
            <p>
              <a href="https://creativecommons.org/licenses/by-sa/4.0/">Лицензия CC BY-SA 4.0</a>
              "Rails", "Ruby on Rails" и логотип Rails - торговые марки DHH
              <!-- Yandex.Metrika counter -->
<script>
  (function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter1006929 = new Ya.Metrika({id:1006929,
                    webvisor:true,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>

<noscript>
  <div>
    <img style="position:absolute; left:-9999px;" alt="" src="//mc.yandex.ru/watch/1006929" />
  </div>
</noscript>
<!-- /Yandex.Metrika counter -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-64955373-1', 'auto');
  ga('send', 'pageview');

  var trackOutboundLink = function(url) {
    ga('send', 'event', 'outbound', 'click', url, {
      'transport': 'beacon',
      'hitCallback': function(){ }
    });
  }
</script>

            </p>
          </div>
        </div>
      </div>
    </div>
    <div class="to_top" style="display: block">
      <div class="to_top_panel"></div>
    </div>
    <script src="/assets/application-8ee447905888b153d8458707061a14b1f15f69b6733e871a3ad91d80ae89e87b.js"></script>
  </body>
</html>
